---------- BEGINNING CSV FILE WRITING ----------
/**
*
@file
GEDCOMparser.h
*
@author
Student2
*
@source
file
that
has
all
the
extra
functions
definitions
to
create,
print
&
delete
a
GEDCOM
object
**/
#ifndef
GEDCOMPARSER_H
#define
GEDCOMPARSER_H
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
"LinkedListAPI.h"
//For
simplicity,
the
examples
we
will
use
will
only
use
the
ASCII
subset
of
these
encodings
typedef
enum
cSet
{ANSEL,
UTF8,
UNICODE,
ASCII}
CharSet;
//error
code
enum
typedef
enum
eCode
{OK,
INV_FILE,
INV_GEDCOM,
INV_HEADER,
INV_RECORD,
OTHER_ERROR}
ErrorCode;
//Represents
a
generic
event,
e.g.
individual
event,
family
event,
etc.
typedef
struct
{
//The
max
length
of
this
field
is
known
from
the
GEDCOM
spec,
so
we
can
use
a
statically
allocated
array
char
type[5];
//Empty
string
if
not
provided
char*
date;
//Empty
string
if
not
provided
char*
place;
//All
other
event
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Event;
//Represents
a
generic
field.
typedef
struct
{
//Field
tag.
Must
not
be
NULL/empty.
char*
tag;
//Field
value.
Must
not
be
NULL/empty.
char*
value;
}
Field;
//Represents
a
submitter
record.
This
is
a
separate
type/struct,
in
case
we
decide
to
expand
it
in
later
assignments
typedef
struct
{
//Submitter
name
has
a
max
length
and
only
appears
once,
so
we
can
hardcode
it
char
submitterName[61];
//All
other
submitter
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
//Submitted
address.
We
use
a
C99
flexible
array
member,
which
we
will
discuss
in
class.
char
address[];
}
Submitter;
/*
Represents
the
GEDCOM
header
Only
includes
required
fields
("line
values"
in
GEDCOM
terminology)
Note
that
while
GEDCOM_FORM
is
required,
but
for
us
it
will
always
be
Lineage-Linked
*/
typedef
struct
{
//Header
source
-
i.e.
software
that
produced
the
GEDCOM
file
char
source[249];
//GEDCOM
version
float
gedcVersion;
//Encoding.
We
use
an
enum,
since
there
are
only
4
possible
values.
CharSet
encoding;
//Reference
to
the
submitter
record
Submitter*
submitter;
//All
other
header
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Header;
//Represends
GEDCOM
individual
record
typedef
struct
{
//Set
to
empty
string
if
not
present
in
file
char*
givenName;
//Set
to
empty
string
if
not
present
in
file
char*
surname;
//Collection
of
individual
events.
All
objects
in
the
list
will
be
of
type
Event.
It
may
be
empty.
List
events;
//Collection
of
family
references.
All
objects
in
the
list
will
be
of
type
Family.
It
may
be
empty.
List
families;
//All
other
individual
record
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Individual;
//Represends
GEDCOM
family
record
typedef
struct
{
//Wife
reference
(can
be
null)
Individual*
wife;
//Husband
reference
(can
be
null)
Individual*
husband;
//List
of
child
references.
All
objects
in
the
list
will
be
of
type
Individual.
It
may
be
empty.
List
children;
//Collection
of
family
events.
All
objects
in
the
list
will
be
of
type
Event.
It
may
be
empty.
List
events;
//List
of
other
fields
in
the
family
record.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Family;
//Represents
a
GEDCOM
object
typedef
struct
{
//Header.
Must
not
be
NULL.
Header*
header;
//Family
records.
All
objects
in
the
list
will
be
of
type
Family.
It
may
be
empty.
List
families;
//Must
contain
type
//Individual
records.
All
objects
in
the
list
will
be
of
type
Individual.
It
may
be
empty.
List
individuals;
//Must
contain
type
Family
//Submitter.
Must
not
be
NULL.
Submitter*
submitter;
//All
other
records
should
be
ignored
for
now
}
GEDCOMobject;
//Error
type
typedef
struct
{
ErrorCode
type;
int
line;
}
GEDCOMerror;
//*****************************************
GEDCOOM
object
functions
*****************************************
/**
Function
to
create
a
GEDCOM
object
based
on
the
contents
of
an
GEDCOM
file.
*@pre
File
name
cannot
be
an
empty
string
or
NULL.
File
name
must
have
the
.ged
extension.
File
represented
by
this
name
must
exist
and
must
be
readable.
*@post
Either:
A
valid
GEDCOM
has
been
created,
its
address
was
stored
in
the
variable
obj,
and
OK
was
returned
or
An
error
occurred,
the
GEDCOM
was
not
created,
all
temporary
memory
was
freed,
obj
was
set
to
NULL,
and
the
appropriate
error
code
was
returned
*@return
the
error
code
indicating
success
or
the
error
encountered
when
parsing
the
GEDCOM
*@param
fileName
-
a
string
containing
the
name
of
the
GEDCOM
file
*@param
a
double
pointer
to
a
GEDCOMobject
struct
that
needs
to
be
allocated
**/
GEDCOMerror
createGEDCOM(char*
fileName,
GEDCOMobject**
obj);
/**
Function
to
create
a
string
representation
of
a
GEDCOMobject.
*@pre
GEDCOMobject
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOMobject
has
not
been
modified
in
any
way,
and
a
string
representing
the
GEDCOM
contents
has
been
created
*@return
a
string
contaning
a
humanly
readable
representation
of
a
GEDCOMobject
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
char*
printGEDCOM(const
GEDCOMobject*
obj);
/**
Function
to
delete
all
GEDCOM
object
content
and
free
all
the
memory.
*@pre
GEDCOM
object
exists,
is
not
null,
and
has
not
been
freed
*@post
GEDCOM
object
had
been
freed
*@return
none
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
void
deleteGEDCOM(GEDCOMobject*
obj);
/**
Function
to
"convert"
the
GEDCOMerror
into
a
humanly
redabale
string.
*@return
a
string
contaning
a
humanly
readable
representation
of
the
error
code
*@param
err
-
an
error
struct
**/
char*
printError(GEDCOMerror
err);
/**
Function
that
searches
for
an
individual
in
the
list
using
a
comparator
function.
*
If
an
individual
is
found,
a
pointer
to
the
Individual
record
*
Returns
NULL
if
the
individual
is
not
found.
*@pre
GEDCOM
object
exists,is
not
NULL,
and
is
valid.
Comparator
function
has
been
provided.
*@post
GEDCOM
object
remains
unchanged.
*@return
The
Individual
record
associated
with
the
person
that
matches
the
search
criteria.
If
the
Individual
record
is
not
found,
return
NULL.
*If
multiple
records
match
the
search
criteria,
return
the
first
one.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
compare
-
a
pointer
to
comparator
fuction
for
customizing
the
search
*@param
person
-
a
pointer
to
search
data,
which
contains
seach
criteria
*Note:
while
the
arguments
of
compare()
and
person
are
all
void,
it
is
assumed
that
records
they
point
to
are
*
all
of
the
same
type
-
just
like
arguments
to
the
compare()
function
in
the
List
struct
**/
Individual*
findPerson(const
GEDCOMobject*
familyRecord,
bool
(*compare)(const
void*
first,
const
void*
second),
const
void*
person);
/**
Function
to
return
a
list
of
all
descendants
of
an
individual
in
a
GEDCOM
*@pre
GEDCOM
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOM
object
has
not
been
modified
in
any
way,
and
a
list
of
descendants
has
been
created
*@return
a
list
of
descendants.
The
list
may
be
empty.
All
list
members
must
be
of
type
Individual,
and
can
appear
in
any
order.
*All
list
members
must
be
COPIES
of
the
Individual
records
in
the
GEDCOM
file.
If
the
returned
list
is
freed,
the
original
GEDCOM
*must
remain
unaffected.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
person
-
the
Individual
record
whose
descendants
we
want
**/
List
getDescendants(const
GEDCOMobject*
familyRecord,
const
Individual*
person);
//************************************************************************************************************
//******************************************
List
helper
functions
*******************************************
void
deleteEvent(void*
toBeDeleted);
int
compareEvents(const
void*
first,const
void*
second);
char*
printEvent(void*
toBePrinted);
void
deleteIndividual(void*
toBeDeleted);
int
compareIndividuals(const
void*
first,const
void*
second);
char*
printIndividual(void*
toBePrinted);
void
deleteFamily(void*
toBeDeleted);
int
compareFamilies(const
void*
first,const
void*
second);
char*
printFamily(void*
toBePrinted);
void
deleteField(void*
toBeDeleted);
int
compareFields(const
void*
first,const
void*
second);
char*
printField(void*
toBePrinted);
//************************************************************************************************************
#endif
/**
*
@file
LinkedListAPI.c
*
@author
Student2
*
@source
file
that
lists
the
function
definitions
for
a
doubly
linked
list
**/
#ifndef
_LIST_API_
#define
_LIST_API_
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
<assert.h>
/**
*
Node
of
a
linked
list.
This
list
is
doubly
linked,
meaning
that
it
has
points
to
both
the
node
immediately
in
front
*
of
it,
as
well
as
the
node
immediately
behind
it.
**/
typedef
struct
listNode{
void*
data;
struct
listNode*
previous;
struct
listNode*
next;
}
Node;
/**
*
Metadata
head
of
the
list.
*
Contains
no
actual
data
but
contains
*
information
about
the
list
(head
and
tail)
as
well
as
the
function
pointers
*
for
working
with
the
abstracted
list
data.
**/
typedef
struct
listHead{
Node*
head;
Node*
tail;
int
length;
void
(*deleteData)(void*
toBeDeleted);
int
(*compare)(const
void*
first,const
void*
second);
char*
(*printData)(void*
toBePrinted);
}
List;
/**
*
List
iterator
structure.
*
It
represents
an
abstract
object
for
iterating
through
the
list.
*
The
list
implemntation
is
hidden
from
the
user
**/
typedef
struct
iter{
Node*
current;
}
ListIterator;
/**
Function
to
initialize
the
list
metadata
head
with
the
appropriate
function
pointers.
*@return
the
list
struct
*@param
printFunction
function
pointer
to
print
a
single
node
of
the
list
*@param
deleteFunction
function
pointer
to
delete
a
single
piece
of
data
from
the
list
*@param
compareFunction
function
pointer
to
compare
two
nodes
of
the
list
in
order
to
test
for
equality
or
order
**/
List
initializeList(char*
(*printFunction)(void*
toBePrinted),void
(*deleteFunction)(void*
toBeDeleted),int
(*compareFunction)(const
void*
first,const
void*
second));
/**Function
for
creating
a
node
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
data
should
be
of
same
size
of
void
pointer
on
the
users
machine
to
avoid
size
conflicts.
data
must
be
valid.
*data
must
be
cast
to
void
pointer
before
being
added.
*@post
data
is
valid
to
be
added
to
a
linked
list
*@return
On
success
returns
a
node
that
can
be
added
to
a
linked
list.
On
failure,
returns
NULL.
*@param
data
-
is
a
void
*
pointer
to
any
data
type.
Data
must
be
allocated
on
the
heap.
**/
Node*
initializeNode(void*
data);
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertFront(List*
list,
void*
toBeAdded);
/**Inserts
a
Node
at
the
back
of
a
linked
list.
*List
metadata
is
updated
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertBack(List*
list,
void*
toBeAdded);
/**
Clears
the
contents
linked
list,
freeing
all
memory
asspociated
with
these
contents.
*
uses
the
supplied
function
pointer
to
release
allocated
memory
for
the
data
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
List-type
dummy
node
**/
void
clearList(List*
list);
/**
Uses
the
comparison
function
pointer
to
place
the
element
in
the
*
appropriate
position
in
the
list.
*
should
be
used
as
the
only
insert
function
if
a
sorted
list
is
required.
*@pre
List
exists
and
has
memory
allocated
to
it.
Node
to
be
added
is
valid.
*@post
The
node
to
be
added
will
be
placed
immediately
before
or
after
the
first
occurrence
of
a
related
node
*@param
list
a
pointer
to
the
dummy
head
of
the
list
containing
function
pointers
for
delete
and
compare,
as
well
as
a
pointer
to
the
first
and
last
element
of
the
list.
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertSorted(List*
list,
void*
toBeAdded);
/**
Removes
data
from
from
the
list,
deletes
the
node
and
frees
the
memory,
*
changes
pointer
values
of
surrounding
nodes
to
maintain
list
structure.
*
returns
the
data
*
You
can
assume
that
the
list
contains
no
duplicates
*@pre
List
must
exist
and
have
memory
allocated
to
it
*@post
If
toBeDeleted
was
found,
the
node
associated
with
it
is
removed
from
the
list
and
freed.
*The
list
is
re-linked.
Otherwise
the
List
is
unchanged.
*@param
list
pointer
to
the
dummy
head
of
the
list
containing
deleteFunction
function
pointer
*@param
toBeDeleted
pointer
to
data
that
is
to
be
removed
from
the
list
*@return
on
success:
void
*
pointer
to
data
on
failure:
NULL
**/
void*
deleteDataFromList(List*
list,
void*
toBeDeleted);
/**Returns
a
pointer
to
the
data
at
the
front
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
head
of
the
list
**/
void*
getFromFront(List
list);
/**Returns
a
pointer
to
the
data
at
the
back
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
tail
of
the
list
**/
void*
getFromBack(List
list);
/**Returns
a
string
that
contains
a
string
representation
of
the
list
traversed
from
head
to
tail.
Utilize
the
list's
printData
function
pointer
to
create
the
string.
returned
string
must
be
freed
by
the
calling
function.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
Pointer
to
linked
list
dummy
head.
*@return
on
success:
char
*
to
string
representation
of
list
(must
be
freed
after
use).
on
failure:
NULL
**/
char*
toString(List
list);
/**
Function
for
creating
an
iterator
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
List
exists
and
is
valid
*@post
List
remains
unchanged.
The
iterator
has
been
allocated
and
points
to
the
head
of
the
list.
*@return
The
newly
created
iterator
object.
*@param
list
-
a
pointer
to
the
list
to
iterate
over.
**/
ListIterator
createIterator(List
list);
/**
Function
that
returns
the
next
element
of
the
list
through
the
iterator.
*
This
function
returns
the
data
at
head
of
the
list
the
first
time
it
is
called
after.
*
the
iterator
was
created.
Every
subsequent
call
returns
the
data
associated
with
the
next
element.
*
Returns
NULL
once
the
end
of
the
iterator
is
reached.
*@pre
List
exists
and
is
valid.
Iterator
exists
and
is
valid.
*@post
List
remains
unchanged.
The
iterator
points
to
the
next
element
on
the
list.
*@return
The
data
associated
with
the
list
element
that
the
iterator
pointed
to
when
the
function
was
called.
*@param
iter
-
an
iterator
to
a
list.
**/
void*
nextElement(ListIterator*
iter);
/**Returns
the
number
of
elements
in
the
list.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
-
the
list
struct.
*@return
on
success:
number
of
eleemnts
in
the
list
(0
or
more).
on
failure:
-1
(e.g.
list
not
initlized
correctly)
**/
int
getLength(List
list);
/**
Function
that
searches
for
an
element
in
the
list
using
a
comparator
function.
*
If
an
element
is
found,
a
pointer
to
the
data
of
that
element
is
returned
*
Returns
NULL
if
the
element
is
not
found.
*@pre
List
exists
and
is
valid.
Comparator
function
has
been
provided.
*@post
List
remains
unchanged.
*@return
The
data
associated
with
the
list
element
that
matches
the
search
criteria.
If
element
is
not
found,
return
NULL.
*@param
list
-
a
list
sruct
*@param
customCompare
-
a
pointer
to
comparator
fuction
for
customizing
the
search
*@param
searchRecord
-
a
pointer
to
search
data,
which
contains
seach
criteria
*Note:
while
the
arguments
of
compare()
and
searchRecord
are
all
void,
it
is
assumed
that
records
they
point
to
are
*
all
of
the
same
type
-
just
like
arguments
to
the
compare()
function
in
the
List
struct
**/
void*
findElement(List
list,
bool
(*customCompare)(const
void*
first,const
void*
second),
const
void*
searchRecord);
#endif
/**
*
@file
GEDCOMutilities.h
*
@author
Student2
*
@source
file
that
has
all
the
necessary
function
declarations
to
assist
with
creating
a
GEDCOM
object
**/
#include
<stdbool.h>
#include
"GEDCOMparser.h"
//Struct
to
store
pointers
to
each
individual
and
their
IDcode
typedef
struct
{
void*
pointerAddress;
char*
IDcode;
}
RecordCode;
//States
for
reading
in
a
file
typedef
enum
currentState
{NONE,
EOL,
FULL_EOL,
DONE}
currentState;
/**
Function
that
verifies
that
the
filename
information
is
valid
*@pre
filename
exists
*@return
true
if
valid,
false
if
not
valid
*@param
pointer
to
filename
to
be
validated
**/
bool
checkFile(char*
fileName);
/**
Function
that
will
iterate
through
a
list
and
free
each
node
(and
not
the
data
inside)
*@pre
list
exists
*@param
list
pointer
to
the
List-type
dummy
node
**/
void
clearListNodes(List*
list);
/**
Function
that
creates
a
readable
string
of
child
information
*@pre
individual
exists
*@return
char*
of
all
child
data
*@param
pointer
to
individual
to
be
printed
**/
char*
printChild(void*
toBePrinted);
/**
Function
that
frees
all
elements
of
the
RecordCode
struct
*@pre
RecordCode
exists
*@param
pointer
to
RecordCode
to
be
deleted
**/
void
deleteRecordCode(void*
toBeDeleted);
/**
Function
that
compares
the
elements
of
two
RecordCode
structs
*@pre
RecordCodes
exists
*@return
0
if
equal,
or
a
#
greater
or
less
than
0
if
not
equal
*@param
pointer
to
two
RecordCodes
to
be
compared
**/
int
compareRecordCodes(const
void*
first,const
void*
second);
/**
Function
that
compares
the
IDcodes
of
two
RecordCode
structs
*@pre
RecordCodes
exists
*@return
true
if
equal,
or
faalse
if
not
equal
*@param
pointer
to
two
RecordCodes
to
be
compared
**/
bool
compareIDCodes(const
void*
first,const
void*
second);
/**
Function
that
creates
a
readable
string
of
RecordCode
information
*@pre
RecordCode
exists
*@return
char*
of
all
RecordCode
data
*@param
pointer
to
RecordCode
to
be
printed
**/
char*
printRecordCode(void*
toBePrinted);
/**
Function
that
reads
a
file
character
by
character
until
hitting
the
EOL
and
then
returns
a
string
of
all
characters
read.
*@pre
fp
exists
*@return
char*
of
one
line
in
the
file
*@param
fp
of
location
in
file
**/
char*
getNextLine(FILE
*
fp);
/**
Function
that
frees
all
elements
of
the
get
descendants
list
of
individual
copies
*@pre
Individual
copy
exists
*@param
pointer
to
Individual
copy
to
be
deleted
**/
void
deleteIndividualCopy(void*
toBeDeleted);
/**
Function
that
copies
over
all
the
elements
of
one
Individual
into
another
*@pre
Individual
to
copy
exists
*@param
pointer
to
Individual
to
be
copied
**/
Individual
*
copyIndividual(const
Individual
*
person);
/**
Function
that
recursively
finds
all
descendants
of
an
individual
and
adds
copies
of
them
to
an
individuals
list
*@pre
Individual
exists,
descendants
list
has
been
initialized
and
families
list
is
not
empty
*@param
pointer
to
Individual
to
find
descendants
of,
list
of
their
families
and
the
descendants
list
to
add
to
**/
Individual*
addChildToList(List
*
descendants,
List
families,
const
Individual
*
person);
/**
Function
that
loops
through
a
string
and
verifies
all
characters
are
digits
*@pre
string
exists
*@return
true
if
it
is
all
digits,
false
if
not
*@param
string
to
check
**/
bool
isStringDigit(char
*str);
/**
Function
that
verifies
that
the
pointer
allocated
is
not
NULL
*@return
OK
if
true,
OTHER_ERROR
if
false
*@param
pointer
to
be
validated
**/
GEDCOMerror
checkIfMallocNull(void
*
pointer);
/**
Function
that
loops
through
the
GEDC
section
of
the
header
and
obtains
relevant
information
for
the
GEDCOM
object
*@pre
fp
exists
and
obj
exists
*@return
error
if
there
was
an
issue
with
the
parsing,
OK
if
no
issues
*@param
fp
of
location
in
file,
obj
to
store
information
found,
current
line
to
keep
track
of
line
in
file
**/
GEDCOMerror
parseGEDC(FILE*
fp,
GEDCOMobject**
obj,
int*
currentLine);
/**
Function
that
loops
through
the
header
section
of
the
file
and
obtains
relevant
information
for
the
GEDCOM
object
*@pre
fp
exists
and
obj
exists
*@return
error
if
there
was
an
issue
with
the
parsing,
OK
if
no
issues
*@param
fp
of
location
in
file,
obj
to
store
information
found,
current
line
to
keep
track
of
line
in
file
**/
GEDCOMerror
parseHeader(FILE
*fp,
GEDCOMobject**
obj,
int*
currentLine);
/**
Function
that
loops
through
the
event
section
of
an
individual
or
family
and
obtains
relevant
information
for
the
GEDCOM
object
*@pre
fp
exists
and
either
tempIndi
or
tempFam
exists
*@return
error
if
there
was
an
issue
with
the
parsing,
OK
if
no
issues
*@param
fp
of
location
in
file,
Individual
or
Family
to
store
event
in,
current
line
to
keep
track
of
line
in
file
**/
GEDCOMerror
parseEvent(FILE*
fp,
Individual
**tempIndi,
Family
**
tempFam,
int
*
currentLine);
/**
Function
that
is
a
series
of
if
statements
to
detect
whether
or
not
a
tag
is
a
individual
event
*@pre
tag
exists
*@return
true
if
it
an
event,
false
if
it
not
*@param
tag
to
check
if
signalling
start
of
event
**/
bool
checkIfIndiEvent(char*
tag);
/**
Function
that
loops
through
the
individual
section
of
the
file
and
obtains
relevant
information
for
the
GEDCOM
object
*@pre
fp
exists
and
obj
exists
*@return
error
if
there
was
an
issue
with
the
parsing,
OK
if
no
issues
*@param
fp
of
location
in
file,
obj
to
store
information
found,
current
line
to
keep
track
of
line
in
file,
list
to
insert
individuals
*
IDcode
and
pointer
**/
GEDCOMerror
parseIndividual(FILE*
fp,
GEDCOMobject**
obj,
int
*
currentLine,
List*
indiListPtr);
/**
Function
that
loops
through
the
submitter
section
of
the
file
and
obtains
relevant
information
for
the
GEDCOM
object
*@pre
fp
exists
and
obj
exists
*@return
error
if
there
was
an
issue
with
the
parsing,
OK
if
no
issues
*@param
fp
of
location
in
file,
obj
to
store
information
found,
current
line
to
keep
track
of
line
in
file
**/
GEDCOMerror
parseSubmitter(FILE*
fp,
GEDCOMobject**
obj,
int*
currentLine);
/**
Function
that
is
a
series
of
if
statements
to
detect
whether
or
not
a
tag
is
a
family
event
*@pre
tag
exists
*@return
true
if
it
an
event,
false
if
it
not
*@param
tag
to
check
if
signalling
start
of
event
**/
bool
checkIfFamEvent(char*
tag);
/**
Function
that
loops
through
the
family
section
of
the
file
and
obtains
relevant
information
for
the
GEDCOM
object
*@pre
fp
exists,
obj
exists
&
list
of
RecordCodes
is
populated
*@return
error
if
there
was
an
issue
with
the
parsing,
OK
if
no
issues
*@param
fp
of
location
in
file,
obj
to
store
information
found,
current
line
to
keep
track
of
line
in
file,
list
of
*
individuals
to
iterate
through
and
add
into
each
family
**/
GEDCOMerror
parseFamily(FILE*
fp,
GEDCOMobject**
obj,
int*
currentLine,
List*
indiListPtr);
/**
Function
that
loops
through
the
file
and
calls
the
relevant
parser
for
each
section
in
the
file
*@pre
fp
exists
and
obj
exists
*@return
error
if
there
was
an
issue
with
the
parsing,
OK
if
no
issues
*@param
fp
of
location
in
file,
obj
to
store
information
found
**/
GEDCOMerror
parseFile(FILE*
fp,
GEDCOMobject**
obj,
List
*
indiListPtr);
/**
*
@file
LinkedListAPI.c
*
@author
Dennis
Nikitenko,
repurposed
by
Jovana
Kusic
*
@studentID
0955683
*
@date
January
2018
*
@source
file
that
implements
a
doubly
linked
list
**/
#include
"LinkedListAPI.h"
/**
Function
to
initialize
the
list
metadata
head
to
the
appropriate
function
pointers.
Allocates
memory
to
the
struct.
*@return
pointer
to
the
list
head
*@param
printFunction
function
pointer
to
print
a
single
node
of
the
list
*@param
deleteFunction
function
pointer
to
delete
a
single
piece
of
data
from
the
list
*@param
compareFunction
function
pointer
to
compare
two
nodes
of
the
list
in
order
to
test
for
equality
or
order
**/
List
initializeList(char*
(*printFunction)(void*
toBePrinted),void
(*deleteFunction)(void*
toBeDeleted),int
(*compareFunction)(const
void*
first,const
void*
second)){
List
tmpList;
//Asserts
create
a
partial
function...
assert(printFunction
!=
NULL);
assert(deleteFunction
!=
NULL);
assert(compareFunction
!=
NULL);
tmpList.head
=
NULL;
tmpList.tail
=
NULL;
tmpList.length
=
0;
tmpList.deleteData
=
deleteFunction;
tmpList.compare
=
compareFunction;
tmpList.printData
=
printFunction;
return
tmpList;
}
/**
Deletes
the
entire
linked
list,
freeing
all
memory.
*
uses
the
supplied
function
pointer
to
release
allocated
memory
for
the
data
*
returns
NULL
on
success
or
the
head
of
the
list
on
failure.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
List-type
dummy
node
*@return
on
success:
NULL,
on
failure:
head
of
list
**/
void
clearList(List*
list){
if
(list
==
NULL){
return;
}
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
return;
}
Node*
tmp;
while
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
!=
NULL){
list->deleteData(list->head->data);
string start = 6
string start = 23
string start = 29
NUMBER OF arrows IN WORD list->deleteData(list->head->data); : 3
tmp
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
list->head->next;
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->next; : 2
free(tmp);
}
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
NULL;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
NULL;
}
/**Function
for
creating
a
node
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
data
should
be
of
same
size
of
void
pointer
on
the
users
machine
to
avoid
size
conflicts.
data
must
be
valid.
*data
must
be
cast
to
void
pointer
before
being
added.
*@post
data
is
valid
to
be
added
to
a
linked
list
*@return
On
success
returns
a
node
that
can
be
added
to
a
linked
list.
On
failure,
returns
NULL.
*@param
data
-
is
a
void
*
pointer
to
any
data
type.
Data
must
be
allocated
on
the
heap.
**/
Node*
initializeNode(void*
data){
Node*
tmpNode;
tmpNode
=
(Node*)malloc(sizeof(Node));
if
(tmpNode
==
NULL){
return
NULL;
}
tmpNode->data
string start = 9
NUMBER OF arrows IN WORD tmpNode->data : 1
=
data;
tmpNode->previous
string start = 9
NUMBER OF arrows IN WORD tmpNode->previous : 1
=
NULL;
tmpNode->next
string start = 9
NUMBER OF arrows IN WORD tmpNode->next : 1
=
NULL;
return
tmpNode;
}
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertBack(List*
list,
void*
toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
Node*
newNode
=
initializeNode(toBeAdded);
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
}else{
newNode->previous
string start = 9
NUMBER OF arrows IN WORD newNode->previous : 1
=
list->tail;
string start = 6
NUMBER OF arrows IN WORD list->tail; : 1
list->tail->next
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->tail->next : 2
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
newNode;
}
list->length++;
string start = 6
NUMBER OF arrows IN WORD list->length++; : 1
}
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertFront(List*
list,
void*
toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
Node*
newNode
=
initializeNode(toBeAdded);
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
}else{
newNode->next
string start = 9
NUMBER OF arrows IN WORD newNode->next : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
list->head->previous
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->previous : 2
=
newNode;
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
}
list->length++;
string start = 6
NUMBER OF arrows IN WORD list->length++; : 1
}
/**Returns
a
pointer
to
the
data
at
the
front
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
head
of
the
list
**/
void*
getFromFront(List
list){
if
(list.head
==
NULL){
return
NULL;
}
return
list.head->data;
string start = 11
NUMBER OF arrows IN WORD list.head->data; : 1
}
/**Returns
a
pointer
to
the
data
at
the
back
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
tail
of
the
list
**/
void*
getFromBack(List
list){
if
(list.tail
==
NULL){
return
NULL;
}
return
list.tail->data;
string start = 11
NUMBER OF arrows IN WORD list.tail->data; : 1
}
void*
deleteDataFromList(List*
list,
void*
toBeDeleted){
if
(list
==
NULL
||
toBeDeleted
==
NULL){
return
NULL;
}
Node*
tmp
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
while(tmp
!=
NULL){
if
(list->compare(toBeDeleted,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeDeleted, : 1
tmp->data)
string start = 5
NUMBER OF arrows IN WORD tmp->data) : 1
==
0){
//Unlink
the
node
Node*
delNode
=
tmp;
if
(tmp->previous
string start = 6
NUMBER OF arrows IN WORD (tmp->previous : 1
!=
NULL){
tmp->previous->next
string start = 5
string start = 15
NUMBER OF arrows IN WORD tmp->previous->next : 2
=
delNode->next;
string start = 9
NUMBER OF arrows IN WORD delNode->next; : 1
}else{
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
delNode->next;
string start = 9
NUMBER OF arrows IN WORD delNode->next; : 1
}
if
(tmp->next
string start = 6
NUMBER OF arrows IN WORD (tmp->next : 1
!=
NULL){
tmp->next->previous
string start = 5
string start = 11
NUMBER OF arrows IN WORD tmp->next->previous : 2
=
delNode->previous;
string start = 9
NUMBER OF arrows IN WORD delNode->previous; : 1
}else{
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
delNode->previous;
string start = 9
NUMBER OF arrows IN WORD delNode->previous; : 1
}
void*
data
=
delNode->data;
string start = 9
NUMBER OF arrows IN WORD delNode->data; : 1
free(delNode);
list->length--;
string start = 6
NUMBER OF arrows IN WORD list->length--; : 1
return
data;
}else{
tmp
=
tmp->next;
string start = 5
NUMBER OF arrows IN WORD tmp->next; : 1
}
}
list->length--;
string start = 6
NUMBER OF arrows IN WORD list->length--; : 1
return
NULL;
}
/**
Uses
the
comparison
function
pointer
to
place
the
element
in
the
*
appropriate
position
in
the
list.
*
should
be
used
as
the
only
insert
function
if
a
sorted
list
is
required.
*@pre
List
exists
and
has
memory
allocated
to
it.
Node
to
be
added
is
valid.
*@post
The
node
to
be
added
will
be
placed
immediately
before
or
after
the
first
occurrence
of
a
related
node
*@param
list
a
pointer
to
the
dummy
head
of
the
list
containing
function
pointers
for
delete
and
compare,
as
well
as
a
pointer
to
the
first
and
last
element
of
the
list.
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertSorted(List
*list,
void
*toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL){
insertBack(list,
toBeAdded);
return;
}
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
list->head->data)
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->data) : 2
<=
0){
insertFront(list,
toBeAdded);
return;
}
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
list->tail->data)
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->tail->data) : 2
>
0){
insertBack(list,
toBeAdded);
return;
}
Node*
currNode
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
while
(currNode
!=
NULL){
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
currNode->data)
string start = 10
NUMBER OF arrows IN WORD currNode->data) : 1
<=
0){
char*
currDescr
=
list->printData(currNode->data);
string start = 6
string start = 26
NUMBER OF arrows IN WORD list->printData(currNode->data); : 2
char*
newDescr
=
list->printData(toBeAdded);
string start = 6
NUMBER OF arrows IN WORD list->printData(toBeAdded); : 1
free(currDescr);
free(newDescr);
Node*
newNode
=
initializeNode(toBeAdded);
newNode->next
string start = 9
NUMBER OF arrows IN WORD newNode->next : 1
=
currNode;
newNode->previous
string start = 9
NUMBER OF arrows IN WORD newNode->previous : 1
=
currNode->previous;
string start = 10
NUMBER OF arrows IN WORD currNode->previous; : 1
currNode->previous->next
string start = 10
string start = 20
NUMBER OF arrows IN WORD currNode->previous->next : 2
=
newNode;
currNode->previous
string start = 10
NUMBER OF arrows IN WORD currNode->previous : 1
=
newNode;
list->length++;
string start = 6
NUMBER OF arrows IN WORD list->length++; : 1
return;
}
currNode
=
currNode->next;
string start = 10
NUMBER OF arrows IN WORD currNode->next; : 1
}
list->length++;
string start = 6
NUMBER OF arrows IN WORD list->length++; : 1
return;
}
/**Returns
a
string
that
contains
a
string
representation
of
the
list
traversed
from
head
to
tail.
Utilize
an
iterator
and
the
list's
printData
function
pointer
to
create
the
string.
returned
string
must
be
freed
by
the
calling
function.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
Pointer
to
linked
list
dummy
head.
*@return
on
success:
char
*
to
string
representation
of
list
(must
be
freed
after
use).
on
failure:
NULL
**/
char*
toString(List
list){
ListIterator
iter
=
createIterator(list);
char*
str;
str
=
(char*)malloc(sizeof(char));
strcpy(str,
"");
void*
elem;
while(
(elem
=
nextElement(&iter))
!=
NULL){
char*
currDescr
=
list.printData(elem);
int
newLen
=
strlen(str)+50+strlen(currDescr);
str
=
(char*)realloc(str,
newLen);
strcat(str,
"\n");
strcat(str,
currDescr);
free(currDescr);
}
return
str;
}
ListIterator
createIterator(List
list){
ListIterator
iter;
iter.current
=
list.head;
return
iter;
}
void*
nextElement(ListIterator*
iter){
Node*
tmp
=
iter->current;
string start = 6
NUMBER OF arrows IN WORD iter->current; : 1
if
(tmp
!=
NULL){
iter->current
string start = 6
NUMBER OF arrows IN WORD iter->current : 1
=
iter->current->next;
string start = 6
string start = 15
NUMBER OF arrows IN WORD iter->current->next; : 2
return
tmp->data;
string start = 5
NUMBER OF arrows IN WORD tmp->data; : 1
}else{
return
NULL;
}
}
int
getLength
(List
list){
int
counter
=
0;
if(list.head
==
NULL
||
list.tail
==
NULL){
list.length
=
counter;
return
-1;
}
Node*
current
=
list.head;
while(current
!=
NULL){
counter++;
current
=
current->next;
string start = 9
NUMBER OF arrows IN WORD current->next; : 1
}
list.length
=
counter;;
return
list.length;
}
void*
findElement(List
list,
bool
(*customCompare)(const
void*
first,
const
void*
second),
const
void*
searchRecord){
if(list.head
==
NULL
||
customCompare
==
NULL){
return
NULL;
}
Node*
current
=
list.head;
while(current
!=
NULL){
if(customCompare(current->data,
string start = 26
NUMBER OF arrows IN WORD if(customCompare(current->data, : 1
searchRecord)
==
true){
return
current->data;
string start = 9
NUMBER OF arrows IN WORD current->data; : 1
}
current
=
current->next;
string start = 9
NUMBER OF arrows IN WORD current->next; : 1
}
return
NULL;
}
/**
*
@file
GEDCOMutilities.c
*
@author
Jovana
Kusic
*
@studentID
0955683
*
@date
January
2018
*
@source
file
that
has
all
the
necessary
extra
functions
to
assist
with
creating
a
GEDCOM
object
**/
#include
"GEDCOMutilities.h"
#include
"GEDCOMparser.h"
#include
"LinkedListAPI.h"
#include
<string.h>
#include
<ctype.h>
#include
<stdbool.h>
#define
DEBUG
0
//-------------------------------------------------------FILE
CHECKING-------------------------------------------------------
bool
checkFile(char*
fileName){
bool
periodFound
=
false;
//Check
if
filename
is
NULL
or
empty
if(fileName
==
NULL
||
strcmp(fileName,"")
==
0){
return
false;
}
//Check
if
filename
has
the
proper
extension
for(int
i
=
strlen(fileName);
i
>=
0;
i--){
if(fileName[i]
==
'.'){
periodFound
=
true;
//hidden
files
allowed?
remove
i
==
0
if(strncmp(&fileName[i],
".ged\0",
5)
!=
0
||
i
==
0){
return
false;
}
i
=
0;
}
}
//Check
if
filename
has
a
period
if(periodFound
==
false){
return
false;
}
return
true;
}
//-------------------------------------------------------DEALING
WITH
CHILDREN-------------------------------------------------------
void
clearListNodes(List*
list){
if
(list
==
NULL){
return;
}
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
return;
}
Node*
tmp;
while
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
!=
NULL){
tmp
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
list->head->next;
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->next; : 2
free(tmp);
}
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
NULL;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
NULL;
}
char*
printChild(void*
toBePrinted){
Individual*
indiPrint
=
(Individual*)toBePrinted;
int
lengthOfString
=
strlen(indiPrint->givenName)
string start = 18
NUMBER OF arrows IN WORD strlen(indiPrint->givenName) : 1
+
2
+
strlen(indiPrint->surname)
string start = 18
NUMBER OF arrows IN WORD strlen(indiPrint->surname) : 1
+
2;
char*
str;
str
=
(char*)malloc(sizeof(char)*
(lengthOfString
+
100));
strcpy(str,
"Child:
");
strcat(str,
indiPrint->givenName);
string start = 11
NUMBER OF arrows IN WORD indiPrint->givenName); : 1
strcat(str,
"
");
strcat(str,
indiPrint->surname);
string start = 11
NUMBER OF arrows IN WORD indiPrint->surname); : 1
return
str;
}
//-------------------------------------------------------RECORD
CODE
FUNCTIONS-------------------------------------------------------
void
deleteRecordCode(void*
toBeDeleted){
if(toBeDeleted
==
NULL){
return;
}
RecordCode*
tempRC
=
(RecordCode*)toBeDeleted;
free(tempRC->IDcode);
string start = 13
NUMBER OF arrows IN WORD free(tempRC->IDcode); : 1
free(tempRC);
}
int
compareRecordCodes(const
void*
first,const
void*
second){
return
0;
}
bool
compareIDCodes(const
void*
first,const
void*
second){
if(first
==
NULL
||
second
==
NULL){
return
-2;
}
RecordCode*
tempFirst
=
(RecordCode*)first;
char*
tempSecond
=
(char*)second;
if(tempFirst
==
NULL
||
tempSecond
==
NULL){
return
-2;
}
if(strcmp(tempFirst->IDcode,
string start = 21
NUMBER OF arrows IN WORD if(strcmp(tempFirst->IDcode, : 1
tempSecond)
==
0){
return
true;
}
return
false;
}
char*
printRecordCode(void*
toBePrinted){
RecordCode*
RCPrint
=
(RecordCode*)toBePrinted;
char*
str
=
malloc(sizeof(char)
*
strlen(RCPrint->IDcode)
string start = 16
NUMBER OF arrows IN WORD strlen(RCPrint->IDcode) : 1
+10);
strcpy(str,
RCPrint->IDcode);
string start = 9
NUMBER OF arrows IN WORD RCPrint->IDcode); : 1
strcat(str,
"\n");
return
str;
}
//-------------------------------------------------------LINE
READING-------------------------------------------------------
char*
getNextLine(FILE
*
fp){
if(fp
==
NULL){
if(DEBUG){
fprintf(stderr,"GETNEXTLINE():
fp
is
NULL");
}
return
NULL;
}
//Allocates
space
for
next
line
to
read
char*
newLine
=
malloc(sizeof(char)*
1000);
for(int
i
=
0;
i
<
1000;
i++){
newLine[i]
=
'\0';
}
char*
errorLine
=
malloc(sizeof(char)*
(strlen("invalid")
+
10));
strcpy(errorLine,
"invalid\0");
newLine[0]
=
'\0';
if(newLine
==
NULL){
if(DEBUG){
fprintf(stderr,"GETNEXTLINE():
newLine
is
NULL");
}
return
NULL;
}
if(ftell(fp)
!=
0){
if(fseek(fp,
-1,
SEEK_CUR)
!=
0){
if(DEBUG){
fprintf(stderr,"GETNEXTLINE():
fseek
failed");
}
return
NULL;
}
}
int
index
=
0;
bool
stillReading
=
true;
char
c
=
'\0';
currentState
state
=
NONE;
while(stillReading){
//Grabs
each
character
in
the
file
if((c
=
fgetc(fp))
==
EOF
){
//Checking
if
character
read
is
EOF
if(index
>
1){
break;
}
else
{
//Free
EOF
read
free(newLine);
return
NULL;
}
}
//Changes
state
to
EOL
bc
EOL
delimiter
found
if(state
==
NONE
&&
(c
==
'\n'
||
c
==
'\r')){
state
=
EOL;
//EOL
so
stop
reading
}
else
if(state
==
EOL){
break;
//NONE
state
saves
new
character
and
moves
pointer
}
else
if(state
==
NONE){
newLine[index]
=
c;
index++;
}
}
newLine[index]
=
'\0';
if(strlen(newLine)
>
255){
free(newLine);
return
errorLine;
}
free(errorLine);
return
newLine;
}
//-------------------------------------------------------GET
DESCENDANT
HELPERS-------------------------------------------------------
void
deleteIndividualCopy(void*
toBeDeleted){
if(toBeDeleted
==
NULL){
return;
}
Individual*
tempIndi
=
(Individual*)toBeDeleted;
if(tempIndi
==
NULL){
return;
}
//Do
not
delete
lists
free(tempIndi->givenName);
string start = 15
NUMBER OF arrows IN WORD free(tempIndi->givenName); : 1
tempIndi->givenName
string start = 10
NUMBER OF arrows IN WORD tempIndi->givenName : 1
=
NULL;
free(tempIndi->surname);
string start = 15
NUMBER OF arrows IN WORD free(tempIndi->surname); : 1
tempIndi->surname
string start = 10
NUMBER OF arrows IN WORD tempIndi->surname : 1
=
NULL;
free(tempIndi);
tempIndi
=
NULL;
}
Individual
*
copyIndividual(const
Individual
*
person){
Individual
*
copyIndi
=
malloc(sizeof(Individual));
copyIndi->givenName
string start = 10
NUMBER OF arrows IN WORD copyIndi->givenName : 1
=
malloc(sizeof(char)*
(strlen(person->givenName)
string start = 16
NUMBER OF arrows IN WORD (strlen(person->givenName) : 1
+1));
strcpy(copyIndi->givenName,
string start = 17
NUMBER OF arrows IN WORD strcpy(copyIndi->givenName, : 1
person->givenName);
string start = 8
NUMBER OF arrows IN WORD person->givenName); : 1
copyIndi->surname
string start = 10
NUMBER OF arrows IN WORD copyIndi->surname : 1
=
malloc(sizeof(char)*
(strlen(person->surname)
string start = 16
NUMBER OF arrows IN WORD (strlen(person->surname) : 1
+1));
strcpy(copyIndi->surname,
string start = 17
NUMBER OF arrows IN WORD strcpy(copyIndi->surname, : 1
person->surname);
string start = 8
NUMBER OF arrows IN WORD person->surname); : 1
copyIndi->events
string start = 10
NUMBER OF arrows IN WORD copyIndi->events : 1
=
person->events;
string start = 8
NUMBER OF arrows IN WORD person->events; : 1
copyIndi->families
string start = 10
NUMBER OF arrows IN WORD copyIndi->families : 1
=
person->families;
string start = 8
NUMBER OF arrows IN WORD person->families; : 1
copyIndi->otherFields
string start = 10
NUMBER OF arrows IN WORD copyIndi->otherFields : 1
=
person->otherFields;
string start = 8
NUMBER OF arrows IN WORD person->otherFields; : 1
return
copyIndi;
}
Individual*
addChildToList(List
*
descendants,
List
families,
const
Individual
*
person){
Individual*
tempIndi
=
NULL;
//Base
case,
no
more
families
to
iterate
through
if(getLength(families)
==
0){
return
tempIndi;
}
//Loops
through
families
list
looking
for
families
where
they
are
a
spouse
ListIterator
iterFamily
=
createIterator(families);
void*
famElement
=
NULL;
while((famElement
=
nextElement(&iterFamily))
!=
NULL){
Family
*
tempFam
=
(Family*)famElement;
//Check
if
spouse
by
using
individual
pointers
if(tempFam->wife
string start = 12
NUMBER OF arrows IN WORD if(tempFam->wife : 1
==
person
||
tempFam->husband
string start = 9
NUMBER OF arrows IN WORD tempFam->husband : 1
==
person){
//Loops
through
childrens
list
and
recursing
through
any
of
their
families
ListIterator
iterChild
=
createIterator(tempFam->children);
string start = 24
NUMBER OF arrows IN WORD createIterator(tempFam->children); : 1
void*
indiElement
=
NULL;
while((indiElement
=
nextElement(&iterChild))
!=
NULL){
tempIndi
=
(Individual*)indiElement;
//Create
copy
Individual
*
copyIndi
=
copyIndividual(tempIndi);
//Insert
copy
into
descendants
insertBack(descendants,
copyIndi);
//Recurse
into
childs
families
list
tempIndi
=
addChildToList(descendants,
tempIndi->families,
string start = 10
NUMBER OF arrows IN WORD tempIndi->families, : 1
tempIndi);
}
}
}
return
tempIndi;
}
//-------------------------------------------------------VALIDATION
FUNCTIONS-------------------------------------------------------
bool
isStringDigit(char
*str){
//Verifies
a
string
is
a
valid
digit
if(str
!=
NULL){
while(*str){
if(!isdigit(*str)){
return
false;
}
else
{
str++;
}
}
}
return
true;
}
GEDCOMerror
checkIfMallocNull(void
*
pointer){
GEDCOMerror
foundError;
foundError.type
=
OK;
foundError.line
=
-1;
if(pointer
==
NULL){
foundError.type
=
OTHER_ERROR;
}
return
foundError;
}
//-------------------------------------------------------PARSE
HEADER-------------------------------------------------------
GEDCOMerror
parseGEDC(FILE*
fp,
GEDCOMobject**
obj,
int*
currentLine){
GEDCOMerror
foundError;
foundError.type
=
OK;
foundError.line
=
-1;
int
currentNum
=
0,
prevNum
=
1;
bool
keepLooping
=
true;
bool
foundVERS
=
false,
foundFORM
=
false;
char*
line;
while(keepLooping){
line
=
getNextLine(fp);
//Verify
line
is
not
too
long
if(strcmp(line,
"invalid")
==
0){
(*currentLine)++;
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
//Tokenize
line
int
lineSize
=
strlen(line);
if(lineSize
>
0){
(*currentLine)++;
char
*lineNum
=
strtok(line,
"
\t");
//Checks
validity
of
line
numbers
if(!isStringDigit(lineNum)){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
currentNum
=
atoi(lineNum);
if(currentNum
!=
prevNum
&&
currentNum
!=
prevNum-1
&&
currentNum
!=
prevNum+1){
if(currentNum
>
prevNum
&&
currentNum
!=
prevNum+1){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
prevNum
=
currentNum;
char
*tag
=
strtok(NULL,
"
\t");
if(tag
==
NULL
||
strlen(tag)
>
31){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
char
*value
=
strtok(NULL,
"\0");
//Inserts
gedc
version
if
found
if(strcmp(lineNum,
"2")==0
&&
strcmp(tag,
"VERS")==0){
if(value
==
NULL
||
strlen(value)
>
15){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
//ADD
MISSING
.#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
if(atof(value)
==
0
&&
strcmp(value,
"0")
==
0){
(*obj)->header->gedcVersion
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->gedcVersion : 2
=
atof(value);
foundVERS
=
true;
}
else
if(atof(value)
!=
0){
(*obj)->header->gedcVersion
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->gedcVersion : 2
=
atof(value);
foundVERS
=
true;
}
else
{
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
//Inserts
form
value
in
other
fields
if
found
}
else
if(strcmp(lineNum,
"2")==0
&&
strcmp(tag,
"FORM")==0){
Field
*tempField
=
malloc(sizeof(Field));
foundError
=
checkIfMallocNull(tempField);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
tempField->tag
string start = 11
NUMBER OF arrows IN WORD tempField->tag : 1
=
malloc(sizeof(char)*
(strlen(tag)
+1));
foundError
=
checkIfMallocNull(tempField->tag);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->tag); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->tag,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->tag, : 1
tag);
if(value
==
NULL){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
free(tempField->tag);
string start = 16
NUMBER OF arrows IN WORD free(tempField->tag); : 1
free(tempField);
return
foundError;
}
else
{
tempField->value
string start = 11
NUMBER OF arrows IN WORD tempField->value : 1
=
malloc(sizeof(char)*(strlen(value)
+1));
foundError
=
checkIfMallocNull(tempField->value);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->value); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->value,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->value, : 1
value);
}
insertBack(&(*obj)->header->otherFields,
string start = 20
string start = 28
NUMBER OF arrows IN WORD insertBack(&(*obj)->header->otherFields, : 2
(void*)tempField);
foundFORM
=
true;
//Checks
for
next
line
that
is
not
a
part
of
GEDC
}
else
if(strcmp(lineNum,
"1")==0){
//Returns
fp
to
before
reading
that
line
and
exits
fseek(fp,
-lineSize-1,
SEEK_CUR);
(*currentLine)--;
free(line);
if(foundVERS
==
false
||
foundFORM
==
false){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
}
return
foundError;
}
}
free(line);
}
return
foundError;
}
GEDCOMerror
parseHeader(FILE
*fp,
GEDCOMobject**
obj,
int*
currentLine){
GEDCOMerror
foundError;
foundError.type
=
OK;
foundError.line
=
-1;
int
prevNum
=
0;
int
currentNum
=
0;
bool
foundSUBM
=
false,
foundCHAR
=
false,
foundGEDC
=
false,
foundSOUR
=
false;
char
*line;
bool
isFirstLine
=
true;
while((line
=
getNextLine(fp))
!=
NULL){
//Verify
line
is
not
too
long
if(strcmp(line,
"invalid")
==
0){
(*currentLine)++;
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
//printf("%s\n",
line);
int
lineSize
=
strlen(line);
if(lineSize
>
0){
(*currentLine)++;
char
*lineNum
=
strtok(line,
"
\t");
//Checks
validity
of
line
numbers
if(!isStringDigit(lineNum)){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
currentNum
=
atoi(lineNum);
if(currentNum
!=
prevNum
&&
currentNum
!=
prevNum-1
&&
currentNum
!=
prevNum+1){
if(currentNum
>
prevNum
&&
currentNum
!=
prevNum+1){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
prevNum
=
currentNum;
//Tokenize
line
char
*tag
=
strtok(NULL,
"
\t");
if(tag
==
NULL
||
strlen(tag)
>
31){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
char
*value
=
strtok(NULL,
"\0");
if(isFirstLine
==
true){
//Checks
to
make
sure
first
line
has
a
HEAD
tag
if(strcmp(lineNum,
"0")
!=
0
||
strcmp(tag,
"HEAD")
!=
0){
foundError.type
=
INV_GEDCOM;
foundError.line
=
-1;
free(line);
return
foundError;
}
isFirstLine
=
false;
//Checks
to
see
if
done
reading
in
header
}
else
if(strcmp(lineNum,
"0")
==
0){
//Moves
back
fp
by
one
line
fseek(fp,
-lineSize-1,
SEEK_CUR);
(*currentLine)--;
free(line);
//Checks
to
make
sure
all
madatory
parts
of
header
were
found
if(foundSOUR
==
false
||
foundCHAR
==
false
||
foundSUBM
==
false
||
foundGEDC
==
false){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
}
return
foundError;
}
else
if(strcmp(tag,
"SOUR")
==
0){
if(value
!=
NULL){
strcpy((*obj)->header->source,
string start = 15
string start = 23
NUMBER OF arrows IN WORD strcpy((*obj)->header->source, : 2
value);
foundSOUR
=
true;
}
else
{
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
else
if(strcmp(tag,
"CHAR")
==
0){
if(value
==
NULL){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
if(strcmp(value,
"ANSEL")==0){
(*obj)->header->encoding
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->encoding : 2
=
ANSEL;
}
else
if(strcmp(value,
"ASCII")==0){
(*obj)->header->encoding
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->encoding : 2
=
ASCII;
}
else
if(strcmp(value,
"UTF-8")==0
||
strcmp(value,
"UTF8")==0){
(*obj)->header->encoding
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->encoding : 2
=
UTF8;
}
else
if(strcmp(value,
"UNICODE")==0){
(*obj)->header->encoding
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->encoding : 2
=
UNICODE;
}
else
{
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
foundCHAR
=
true;
}
else
if(strcmp(tag,
"SUBM")
==
0){
//If
more
than
one
submitter,
error
if(foundSUBM
==
true){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
else
if(value
!=
NULL){
//Makes
space
for
a
submitter
(*obj)->header->submitter
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->submitter : 2
=
malloc(sizeof(Submitter));
foundError
=
checkIfMallocNull((*obj)->header->submitter);
string start = 26
string start = 34
NUMBER OF arrows IN WORD checkIfMallocNull((*obj)->header->submitter); : 2
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
//Stores
pointer
tag
to
reference
and
replace
later
strcpy((*obj)->header->submitter->submitterName,
string start = 15
string start = 23
string start = 34
NUMBER OF arrows IN WORD strcpy((*obj)->header->submitter->submitterName, : 3
value);
foundSUBM
=
true;
}
else
{
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
else
if(strcmp(tag,
"GEDC")
==
0){
foundError
=
parseGEDC(fp,
obj,
currentLine);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
foundGEDC
=
true;
}
else
{
//Make
space
for
a
new
otherfields
node
Field
*tempField
=
malloc(sizeof(Field));
foundError
=
checkIfMallocNull(tempField);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
tempField->tag
string start = 11
NUMBER OF arrows IN WORD tempField->tag : 1
=
malloc(sizeof(char)*(strlen(tag)
+1));
foundError
=
checkIfMallocNull(tempField->tag);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->tag); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->tag,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->tag, : 1
tag);
//If
no
value,
return
error
if(value
==
NULL){
foundError.type
=
INV_HEADER;
foundError.line
=
*currentLine;
free(line);
free(tempField->tag);
string start = 16
NUMBER OF arrows IN WORD free(tempField->tag); : 1
free(tempField);
return
foundError;
}
else
{
tempField->value
string start = 11
NUMBER OF arrows IN WORD tempField->value : 1
=
malloc(sizeof(char)*(strlen(value)
+1));
foundError
=
checkIfMallocNull(tempField->value);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->value); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->value,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->value, : 1
value);
}
//Insert
into
linked
list
insertBack(&(*obj)->header->otherFields,
string start = 20
string start = 28
NUMBER OF arrows IN WORD insertBack(&(*obj)->header->otherFields, : 2
(void*)tempField);
}
}
free(line);
}
return
foundError;
}
//-------------------------------------------------------PARSE
EVENTS-------------------------------------------------------
GEDCOMerror
parseEvent(FILE*
fp,
Individual
**tempIndi,
Family
**
tempFam,
int
*
currentLine){
GEDCOMerror
foundError;
foundError.type
=
OK;
foundError.line
=
-1;
int
prevNum
=
0;
int
currentNum
=
0;
char
*line;
bool
isFirstLine
=
true,
foundDate
=
false,
foundPlace
=
false;
//Make
space
for
a
node
and
initialize
all
values
Event
*tempEvent
=
malloc(sizeof(Event));
foundError
=
checkIfMallocNull(tempEvent);
if(foundError.type
!=
OK){
return
foundError;
}
tempEvent->type[0]
string start = 11
NUMBER OF arrows IN WORD tempEvent->type[0] : 1
=
'\0';
tempEvent->date
string start = 11
NUMBER OF arrows IN WORD tempEvent->date : 1
=
NULL;
tempEvent->place
string start = 11
NUMBER OF arrows IN WORD tempEvent->place : 1
=
NULL;
tempEvent->otherFields
string start = 11
NUMBER OF arrows IN WORD tempEvent->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
//Insert
into
tempIndi
event
list
if(tempIndi
!=
NULL){
insertBack(&(*tempIndi)->events,
string start = 25
NUMBER OF arrows IN WORD insertBack(&(*tempIndi)->events, : 1
(void*)tempEvent);
}
if(tempFam
!=
NULL){
insertBack(&(*tempFam)->events,
string start = 24
NUMBER OF arrows IN WORD insertBack(&(*tempFam)->events, : 1
(void*)tempEvent);
}
while((line
=
getNextLine(fp))
!=
NULL){
//Verify
line
is
not
too
long
if(strcmp(line,
"invalid")
==
0){
(*currentLine)++;
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
//printf("%s\n",
line);
int
lineSize
=
strlen(line);
if(lineSize
>
0){
(*currentLine)++;
char
*lineNum
=
strtok(line,
"
\t");
//Checks
validity
of
line
numbers
if(!isStringDigit(lineNum)){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
currentNum
=
atoi(lineNum);
if(currentNum
!=
prevNum
&&
currentNum
!=
prevNum-1
&&
currentNum
!=
prevNum+1){
if(currentNum
>
prevNum
&&
currentNum
!=
prevNum+1){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
prevNum
=
currentNum;
//Tokenize
line
char
*tag
=
strtok(NULL,
"
\t");
if(tag
==
NULL
||
strlen(tag)
>
31){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
char
*value
=
strtok(NULL,
"\0");
if((strcmp(lineNum,
"1")
==
0
&&
isFirstLine
==
false)
||
(strcmp(lineNum,
"0")
==
0
&&
isFirstLine
==
false)){
//Moves
back
fp
by
one
line
fseek(fp,
-lineSize-1,
SEEK_CUR);
(*currentLine)--;
free(line);
//Checks
to
make
sure
all
mandatory
parts
of
an
event
were
found
if(foundDate
==
false){
tempEvent->date
string start = 11
NUMBER OF arrows IN WORD tempEvent->date : 1
=
malloc(sizeof(char)+1);
foundError
=
checkIfMallocNull(tempEvent->date);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempEvent->date); : 1
if(foundError.type
!=
OK){
return
foundError;
}
strcpy(tempEvent->date,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempEvent->date, : 1
"");
}
if(foundPlace
==
false){
tempEvent->place
string start = 11
NUMBER OF arrows IN WORD tempEvent->place : 1
=
malloc(sizeof(char)+1);
foundError
=
checkIfMallocNull(tempEvent->place);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempEvent->place); : 1
if(foundError.type
!=
OK){
return
foundError;
}
strcpy(tempEvent->place,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempEvent->place, : 1
"");
}
return
foundError;
}
if(isFirstLine
==
true){
strcpy(tempEvent->type,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempEvent->type, : 1
tag);
isFirstLine
=
false;
}
else
if(strcmp(tag,
"DATE")
==
0){
if(value
!=
NULL
&&
strlen(value)
<
35){
tempEvent->date
string start = 11
NUMBER OF arrows IN WORD tempEvent->date : 1
=
malloc(sizeof(char)*(strlen(value)
+1));
foundError
=
checkIfMallocNull(tempEvent->date);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempEvent->date); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempEvent->date,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempEvent->date, : 1
value);
foundDate
=
true;
}
else
{
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
else
if(strcmp(tag,
"PLAC")
==
0){
if(value
!=
NULL
&&
strlen(value)
<
120){
tempEvent->place
string start = 11
NUMBER OF arrows IN WORD tempEvent->place : 1
=
malloc(sizeof(char)*(strlen(value)
+1));
foundError
=
checkIfMallocNull(tempEvent->place);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempEvent->place); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempEvent->place,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempEvent->place, : 1
value);
foundPlace
=
true;
}
else
{
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
else
{
//Make
space
for
a
new
otherfields
node
Field
*tempField
=
malloc(sizeof(Field));
foundError
=
checkIfMallocNull(tempField);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
tempField->tag
string start = 11
NUMBER OF arrows IN WORD tempField->tag : 1
=
malloc(sizeof(char)*(strlen(tag)
+1));
foundError
=
checkIfMallocNull(tempField->tag);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->tag); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->tag,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->tag, : 1
tag);
//If
no
value,
return
error
if(value
==
NULL){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
free(tempField->tag);
string start = 16
NUMBER OF arrows IN WORD free(tempField->tag); : 1
free(tempField);
return
foundError;
}
else
{
tempField->value
string start = 11
NUMBER OF arrows IN WORD tempField->value : 1
=
malloc(sizeof(char)*(strlen(value)
+1));
foundError
=
checkIfMallocNull(tempField->value);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->value); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->value,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->value, : 1
value);
}
//Insert
into
linked
list
insertBack(&tempEvent->otherFields,
string start = 23
NUMBER OF arrows IN WORD insertBack(&tempEvent->otherFields, : 1
(void*)tempField);
}
}
free(line);
}
return
foundError;
}
//-------------------------------------------------------PARSE
INDIVIDUALS-------------------------------------------------------
bool
checkIfIndiEvent(char*
tag){
if(strcmp(tag,
"ADOP")
==
0){
return
true;
}
else
if(strcmp(tag,
"BIRT")
==
0){
return
true;
}
else
if(strcmp(tag,
"BAPM")
==
0){
return
true;
}
else
if(strcmp(tag,
"BARM")
==
0){
return
true;
}
else
if(strcmp(tag,
"BASM")
==
0){
return
true;
}
else
if(strcmp(tag,
"BLES")
==
0){
return
true;
}
else
if(strcmp(tag,
"BURI")
==
0){
return
true;
}
else
if(strcmp(tag,
"CENS")
==
0){
return
true;
}
else
if(strcmp(tag,
"CHR")
==
0){
return
true;
}
else
if(strcmp(tag,
"CHRA")
==
0){
return
true;
}
else
if(strcmp(tag,
"CONF")
==
0){
return
true;
}
else
if(strcmp(tag,
"CREM")
==
0){
return
true;
}
else
if(strcmp(tag,
"DEAT")
==
0){
return
true;
}
else
if(strcmp(tag,
"EMIG")
==
0){
return
true;
}
else
if(strcmp(tag,
"FCOM")
==
0){
return
true;
}
else
if(strcmp(tag,
"GRAD")
==
0){
return
true;
}
else
if(strcmp(tag,
"IMMI")
==
0){
return
true;
}
else
if(strcmp(tag,
"NATU")
==
0){
return
true;
}
else
if(strcmp(tag,
"ORDN")
==
0){
return
true;
}
else
if(strcmp(tag,
"RETI")
==
0){
return
true;
}
else
if(strcmp(tag,
"PROB")
==
0){
return
true;
}
else
if(strcmp(tag,
"WILL")
==
0){
return
true;
}
else
if(strcmp(tag,
"EVEN")
==
0){
return
true;
}
return
false;
}
GEDCOMerror
parseIndividual(FILE*
fp,
GEDCOMobject**
obj,
int*
currentLine,
List*
indiListPtr){
GEDCOMerror
foundError;
foundError.type
=
OK;
foundError.line
=
-1;
char*
line;
int
prevNum
=
0;
int
currentNum
=
0;
bool
isFirstLine
=
true,
foundName
=
false;;
//Make
space
for
a
node
and
initialize
all
values
Individual
*tempIndi
=
malloc(sizeof(Individual));
foundError
=
checkIfMallocNull(tempIndi);
if(foundError.type
!=
OK){
return
foundError;
}
tempIndi->givenName
string start = 10
NUMBER OF arrows IN WORD tempIndi->givenName : 1
=
NULL;
tempIndi->surname
string start = 10
NUMBER OF arrows IN WORD tempIndi->surname : 1
=
NULL;
tempIndi->events
string start = 10
NUMBER OF arrows IN WORD tempIndi->events : 1
=
initializeList(&printEvent,
&deleteEvent,
&compareEvents);
tempIndi->families
string start = 10
NUMBER OF arrows IN WORD tempIndi->families : 1
=
initializeList(&printFamily,
&deleteFamily,
&compareFamilies);
tempIndi->otherFields
string start = 10
NUMBER OF arrows IN WORD tempIndi->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
//Make
record
code
list
to
store
all
individual
pointers
and
xrefs
RecordCode
*tempRC
=
malloc(sizeof(RecordCode));
foundError
=
checkIfMallocNull(tempRC);
if(foundError.type
!=
OK){
return
foundError;
}
tempRC->pointerAddress
string start = 8
NUMBER OF arrows IN WORD tempRC->pointerAddress : 1
=
NULL;
tempRC->IDcode
string start = 8
NUMBER OF arrows IN WORD tempRC->IDcode : 1
=
NULL;
insertBack(&(*obj)->individuals,
string start = 20
NUMBER OF arrows IN WORD insertBack(&(*obj)->individuals, : 1
(void*)tempIndi);
insertBack(indiListPtr,
(void*)tempRC);
while((line
=
getNextLine(fp))
!=
NULL){
//Verify
line
is
not
too
long
if(strcmp(line,
"invalid")
==
0){
(*currentLine)++;
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
int
lineSize
=
strlen(line);
if(lineSize
>
1){
(*currentLine)++;
char
*lineNum
=
strtok(line,
"
\t");
//Checks
validity
of
line
numbers
if(!isStringDigit(lineNum)){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
currentNum
=
atoi(lineNum);
if(currentNum
!=
prevNum
&&
currentNum
!=
prevNum-1
&&
currentNum
!=
prevNum+1){
if(currentNum
>
prevNum
&&
currentNum
!=
prevNum+1){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
prevNum
=
currentNum;
//Tokenize
line
char
*tag
=
strtok(NULL,
"
\t");
if(tag
==
NULL
||
strlen(tag)
>
31){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
char
*value
=
strtok(NULL,
"\0");
//Checks
to
see
when
to
stop
reading
the
individual
record
if(strcmp(lineNum,
"0")
==
0
&&
isFirstLine
==
true){
tempRC->IDcode
string start = 8
NUMBER OF arrows IN WORD tempRC->IDcode : 1
=
malloc(sizeof(char)*
strlen(tag)
+
1);
foundError
=
checkIfMallocNull(tempRC->IDcode);
string start = 26
NUMBER OF arrows IN WORD checkIfMallocNull(tempRC->IDcode); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempRC->IDcode,
string start = 15
NUMBER OF arrows IN WORD strcpy(tempRC->IDcode, : 1
tag);
isFirstLine
=
false;
}
else
if(strcmp(lineNum,
"0")
==
0
&&
isFirstLine
==
false){
//If
no
name
found,
set
first
and
last
name
to
empty
strings
if(foundName
==
false){
tempIndi->givenName
string start = 10
NUMBER OF arrows IN WORD tempIndi->givenName : 1
=
malloc(sizeof(char)+1);
foundError
=
checkIfMallocNull(tempIndi->givenName);
string start = 28
NUMBER OF arrows IN WORD checkIfMallocNull(tempIndi->givenName); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempIndi->givenName,
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->givenName, : 1
"\0");
tempIndi->surname
string start = 10
NUMBER OF arrows IN WORD tempIndi->surname : 1
=
malloc(sizeof(char)+1);
foundError
=
checkIfMallocNull(tempIndi->surname);
string start = 28
NUMBER OF arrows IN WORD checkIfMallocNull(tempIndi->surname); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempIndi->surname,
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->surname, : 1
"\0");
}
//Moves
back
fp
by
one
line
fseek(fp,
-lineSize-1,
SEEK_CUR);
(*currentLine)--;
free(line);
//Insert
into
linked
list
//insertBack(&(*obj)->individuals,
string start = 22
NUMBER OF arrows IN WORD //insertBack(&(*obj)->individuals, : 1
(void*)tempIndi);
//Sets
pointer
to
this
specific
individual
tempRC->pointerAddress
string start = 8
NUMBER OF arrows IN WORD tempRC->pointerAddress : 1
=
tempIndi;
//insertBack(indiListPtr,
(void*)tempRC);
return
foundError;
//Parses
individual
}
else
if(strcmp(tag,
"NAME")
==
0){
if(value
==
NULL
||
strlen(value)
>
120){
free(line);
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
return
foundError;
}
foundName
=
true;
//Checks
if
only
last
name
present
if(value[0]
==
'/'
&&
value[strlen(value)-1]
==
'/'){
char
*LN
=
strtok(value,
"/");
tempIndi->givenName
string start = 10
NUMBER OF arrows IN WORD tempIndi->givenName : 1
=
malloc(sizeof(char)+1);
foundError
=
checkIfMallocNull(tempIndi->givenName);
string start = 28
NUMBER OF arrows IN WORD checkIfMallocNull(tempIndi->givenName); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempIndi->givenName,
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->givenName, : 1
"\0");
if(LN
==
NULL){
tempIndi->surname
string start = 10
NUMBER OF arrows IN WORD tempIndi->surname : 1
=
malloc(sizeof(char)+1);
foundError
=
checkIfMallocNull(tempIndi->surname);
string start = 28
NUMBER OF arrows IN WORD checkIfMallocNull(tempIndi->surname); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempIndi->surname,
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->surname, : 1
"\0");
}
else
{
tempIndi->surname
string start = 10
NUMBER OF arrows IN WORD tempIndi->surname : 1
=
malloc(sizeof(char)*(strlen(LN)
+1));
foundError
=
checkIfMallocNull(tempIndi->surname);
string start = 28
NUMBER OF arrows IN WORD checkIfMallocNull(tempIndi->surname); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempIndi->surname,
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->surname, : 1
LN);
}
}
else
{
char
*FN
=
strtok(value,
"/");
char
*LN
=
strtok(NULL,
"/\0");
if(FN
==
NULL){
tempIndi->givenName
string start = 10
NUMBER OF arrows IN WORD tempIndi->givenName : 1
=
malloc(sizeof(char)
+1);
foundError
=
checkIfMallocNull(tempIndi->givenName);
string start = 28
NUMBER OF arrows IN WORD checkIfMallocNull(tempIndi->givenName); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempIndi->givenName,
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->givenName, : 1
"\0");
}
else
{
tempIndi->givenName
string start = 10
NUMBER OF arrows IN WORD tempIndi->givenName : 1
=
malloc(sizeof(char)*(strlen(FN)
+1));
foundError
=
checkIfMallocNull(tempIndi->givenName);
string start = 28
NUMBER OF arrows IN WORD checkIfMallocNull(tempIndi->givenName); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempIndi->givenName,
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->givenName, : 1
FN);
//Removes
space
at
the
end
of
the
given
name
if(tempIndi->givenName[strlen(tempIndi->givenName)-1]
string start = 13
string start = 40
NUMBER OF arrows IN WORD if(tempIndi->givenName[strlen(tempIndi->givenName)-1] : 2
==
'
'){
tempIndi->givenName[strlen(tempIndi->givenName)-1]
string start = 10
string start = 37
NUMBER OF arrows IN WORD tempIndi->givenName[strlen(tempIndi->givenName)-1] : 2
=
'\0';
}
}
if(LN
==
NULL){
tempIndi->surname
string start = 10
NUMBER OF arrows IN WORD tempIndi->surname : 1
=
malloc(sizeof(char)+1);
foundError
=
checkIfMallocNull(tempIndi->surname);
string start = 28
NUMBER OF arrows IN WORD checkIfMallocNull(tempIndi->surname); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempIndi->surname,
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->surname, : 1
"\0");
}
else
{
tempIndi->surname
string start = 10
NUMBER OF arrows IN WORD tempIndi->surname : 1
=
malloc(sizeof(char)*(strlen(LN)
+1));
foundError
=
checkIfMallocNull(tempIndi->surname);
string start = 28
NUMBER OF arrows IN WORD checkIfMallocNull(tempIndi->surname); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempIndi->surname,
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->surname, : 1
LN);
}
}
}
else
if(checkIfIndiEvent(tag)
==
true){
//Moves
back
by
one
line
fseek(fp,
-lineSize-1,
SEEK_CUR);
(*currentLine)--;
foundError
=
parseEvent(fp,
&tempIndi,
NULL,
currentLine);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
}
else
if(strcmp(tag,
"FAMC")
==
0){
//Ignore,
families
are
inserted
into
individuals
on
second
pass
through
file
}
else
if(strcmp(tag,
"FAMS")
==
0){
//Ignore,
families
are
inserted
into
individuals
on
second
pass
through
file
}
else
{
//Make
space
for
a
new
otherfields
node
Field
*tempField
=
malloc(sizeof(Field));
foundError
=
checkIfMallocNull(tempField);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
tempField->tag
string start = 11
NUMBER OF arrows IN WORD tempField->tag : 1
=
malloc(sizeof(char)*(strlen(tag)
+1));
foundError
=
checkIfMallocNull(tempField->tag);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->tag); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->tag,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->tag, : 1
tag);
//If
no
value,
return
error
if(value
==
NULL){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
free(tempField->tag);
string start = 16
NUMBER OF arrows IN WORD free(tempField->tag); : 1
free(tempField);
return
foundError;
}
else
{
tempField->value
string start = 11
NUMBER OF arrows IN WORD tempField->value : 1
=
malloc(sizeof(char)*(strlen(value)
+1));
foundError
=
checkIfMallocNull(tempField->value);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->value); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->value,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->value, : 1
value);
}
//Insert
into
linked
list
insertBack(&tempIndi->otherFields,
string start = 22
NUMBER OF arrows IN WORD insertBack(&tempIndi->otherFields, : 1
(void*)tempField);
}
}
free(line);
}
return
foundError;
}
//-------------------------------------------------------PARSE
SUBMITTER-------------------------------------------------------
GEDCOMerror
parseSubmitter(FILE*
fp,
GEDCOMobject**
obj,
int*
currentLine){
GEDCOMerror
foundError;
foundError.type
=
OK;
foundError.line
=
-1;
int
currentNum
=
0;
int
prevNum
=
0;
char*
line;
//char*
newLine;
bool
foundName
=
false,
foundAddress
=
false;
//Make
header
submitter
pointer
point
to
the
same
record
free((*obj)->header->submitter);
string start = 13
string start = 21
NUMBER OF arrows IN WORD free((*obj)->header->submitter); : 2
(*obj)->header->submitter
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->submitter : 2
=
(*obj)->submitter;
string start = 8
NUMBER OF arrows IN WORD (*obj)->submitter; : 1
while((line
=
getNextLine(fp))
!=
NULL){
//Verify
line
is
not
too
long
if(strcmp(line,
"invalid")
==
0){
(*currentLine)++;
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
int
lineSize
=
strlen(line);
//printf("%s\n",
line);
if(lineSize
>
1){
(*currentLine)++;
char
*lineNum
=
strtok(line,
"
\t");
//Checks
validity
of
line
numbers
if(!isStringDigit(lineNum)){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
currentNum
=
atoi(lineNum);
if(currentNum
!=
prevNum
&&
currentNum
!=
prevNum-1
&&
currentNum
!=
prevNum+1){
if(currentNum
>
prevNum
&&
currentNum
!=
prevNum+1){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
prevNum
=
currentNum;
//Tokenize
line
char
*tag
=
strtok(NULL,
"
\t");
if(tag
==
NULL
||
strlen(tag)
>
31){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
char
*value
=
strtok(NULL,
"\0");
if(strcmp(lineNum,
"0")
==
0){
//Moves
back
fp
by
one
line
fseek(fp,
-lineSize-1,
SEEK_CUR);
(*currentLine)--;
free(line);
//Checks
to
make
sure
all
mandatory
parts
of
header
were
found
if(foundName
==
false){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
return
foundError;
}
if(foundAddress
==
false){
strcpy((*obj)->submitter->address,
string start = 15
string start = 26
NUMBER OF arrows IN WORD strcpy((*obj)->submitter->address, : 2
"\0");
}
return
foundError;
}
else
if(strcmp(tag,
"NAME")
==
0){
if(value
!=
NULL
&&
strlen(value)
<
60){
foundName
=
true;
strcpy((*obj)->submitter->submitterName,
string start = 15
string start = 26
NUMBER OF arrows IN WORD strcpy((*obj)->submitter->submitterName, : 2
value);
}
else
{
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
else
if
(strcmp(tag,
"ADDR")
==
0){
if(value
!=
NULL
&&
strlen(value)
<
60){
foundAddress
=
true;
//Memory
already
allocated
for
flexible
array
when
initializing
submitter
strcpy((*obj)->submitter->address,
string start = 15
string start = 26
NUMBER OF arrows IN WORD strcpy((*obj)->submitter->address, : 2
value);
}
else
{
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
else
{
//Make
space
for
a
new
otherfields
node
Field
*tempField
=
malloc(sizeof(Field));
foundError
=
checkIfMallocNull(tempField);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
tempField->tag
string start = 11
NUMBER OF arrows IN WORD tempField->tag : 1
=
malloc(sizeof(char)*(strlen(tag)
+1));
foundError
=
checkIfMallocNull(tempField->tag);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->tag); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->tag,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->tag, : 1
tag);
//If
no
value,
store
as
empty
string
if(value
==
NULL){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
free(tempField->tag);
string start = 16
NUMBER OF arrows IN WORD free(tempField->tag); : 1
free(tempField);
return
foundError;
}
else
{
tempField->value
string start = 11
NUMBER OF arrows IN WORD tempField->value : 1
=
malloc(sizeof(char)*(strlen(value)
+1));
foundError
=
checkIfMallocNull(tempField->value);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->value); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->value,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->value, : 1
value);
}
//Insert
into
linked
list
insertBack(&(*obj)->submitter->otherFields,
string start = 20
string start = 31
NUMBER OF arrows IN WORD insertBack(&(*obj)->submitter->otherFields, : 2
(void*)tempField);
}
}
free(line);
}
return
foundError;
}
//-------------------------------------------------------PARSE
FAMILIES-------------------------------------------------------
bool
checkIfFamEvent(char*
tag){
if(strcmp(tag,
"ANUL")
==
0){
return
true;
}
else
if(strcmp(tag,
"CENS")
==
0){
return
true;
}
else
if(strcmp(tag,
"DIV")
==
0){
return
true;
}
else
if(strcmp(tag,
"DIVF")
==
0){
return
true;
}
else
if(strcmp(tag,
"ENGA")
==
0){
return
true;
}
else
if(strcmp(tag,
"MARR")
==
0){
return
true;
}
else
if(strcmp(tag,
"MARB")
==
0){
return
true;
}
else
if(strcmp(tag,
"MARC")
==
0){
return
true;
}
else
if(strcmp(tag,
"MARL")
==
0){
return
true;
}
else
if(strcmp(tag,
"MARS")
==
0){
return
true;
}
else
if(strcmp(tag,
"EVEN")
==
0){
return
true;
}
return
false;
}
GEDCOMerror
parseFamily(FILE*
fp,
GEDCOMobject**
obj,
int*
currentLine,
List*
indiListPtr){
GEDCOMerror
foundError;
foundError.type
=
OK;
foundError.line
=
-1;
char*
line;
int
prevNum
=
0;
int
currentNum
=
0;
Family*
tempFam
=
malloc(sizeof(Family));
foundError
=
checkIfMallocNull(tempFam);
if(foundError.type
!=
OK){
return
foundError;
}
tempFam->wife
string start = 9
NUMBER OF arrows IN WORD tempFam->wife : 1
=
NULL;
tempFam->husband
string start = 9
NUMBER OF arrows IN WORD tempFam->husband : 1
=
NULL;
tempFam->children
string start = 9
NUMBER OF arrows IN WORD tempFam->children : 1
=
initializeList(&printChild,
&deleteIndividual,
&compareIndividuals);
tempFam->events
string start = 9
NUMBER OF arrows IN WORD tempFam->events : 1
=
initializeList(&printEvent,
&deleteEvent,
&compareEvents);
tempFam->otherFields
string start = 9
NUMBER OF arrows IN WORD tempFam->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
//Insert
into
linked
list
of
families
insertBack(&(*obj)->families,
string start = 20
NUMBER OF arrows IN WORD insertBack(&(*obj)->families, : 1
(void*)tempFam);
while((line
=
getNextLine(fp))
!=
NULL){
//Verify
line
is
not
too
long
if(strcmp(line,
"invalid")
==
0){
(*currentLine)++;
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
int
lineSize
=
strlen(line);
//printf("%s\n",
line);
if(lineSize
>
1){
(*currentLine)++;
char
*lineNum
=
strtok(line,
"
\t");
//Checks
validity
of
line
numbers
if(!isStringDigit(lineNum)){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
currentNum
=
atoi(lineNum);
if(currentNum
!=
prevNum
&&
currentNum
!=
prevNum-1
&&
currentNum
!=
prevNum+1){
if(currentNum
>
prevNum
&&
currentNum
!=
prevNum+1){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
}
prevNum
=
currentNum;
//Tokenize
line
char
*tag
=
strtok(NULL,
"
\t");
if(tag
==
NULL
||
strlen(tag)
>
31){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
return
foundError;
}
char
*value
=
strtok(NULL,
"\0");
if(strcmp(lineNum,
"0")
==
0){
//Moves
back
fp
by
one
line
fseek(fp,
-lineSize-1,
SEEK_CUR);
(*currentLine)--;
free(line);
return
foundError;
}
else
if
(strcmp(tag,
"WIFE")
==
0){
//Find
and
set
individual
pointer,
if
not
found
throws
an
error
if(findElement(*indiListPtr,
&compareIDCodes,
value)
!=
NULL){
RecordCode*
tempRC
=
(RecordCode*)findElement(*indiListPtr,
&compareIDCodes,
value);
tempFam->wife
string start = 9
NUMBER OF arrows IN WORD tempFam->wife : 1
=
tempRC->pointerAddress;
string start = 8
NUMBER OF arrows IN WORD tempRC->pointerAddress; : 1
//After
populating
one
individual
into
a
family,
insert
into
their
families
list
Individual
*
tempIndi
=
(Individual*)tempRC->pointerAddress;
string start = 21
NUMBER OF arrows IN WORD (Individual*)tempRC->pointerAddress; : 1
insertBack(&tempIndi->families,
string start = 22
NUMBER OF arrows IN WORD insertBack(&tempIndi->families, : 1
(void*)tempFam);
}
else
{
foundError.type
=
INV_GEDCOM;
foundError.line
=
-1;
free(line);
return
foundError;
}
}
else
if(strcmp(tag,
"HUSB")
==
0){
//Find
and
set
individual
pointer,
if
not
found
throws
an
error
if(findElement(*indiListPtr,
&compareIDCodes,
value)
!=
NULL){
RecordCode*
tempRC
=
(RecordCode*)findElement(*indiListPtr,
&compareIDCodes,
value);
tempFam->husband
string start = 9
NUMBER OF arrows IN WORD tempFam->husband : 1
=
tempRC->pointerAddress;
string start = 8
NUMBER OF arrows IN WORD tempRC->pointerAddress; : 1
//After
populating
one
individual
into
a
family,
insert
into
their
families
list
Individual
*
tempIndi
=
(Individual*)tempRC->pointerAddress;
string start = 21
NUMBER OF arrows IN WORD (Individual*)tempRC->pointerAddress; : 1
insertBack(&tempIndi->families,
string start = 22
NUMBER OF arrows IN WORD insertBack(&tempIndi->families, : 1
(void*)tempFam);
}
else
{
foundError.type
=
INV_GEDCOM;
foundError.line
=
-1;
free(line);
return
foundError;
}
}
else
if(strcmp(tag,
"CHIL")
==
0){
//Find
and
set
children,
if
not
found
throws
an
error
if(findElement(*indiListPtr,
&compareIDCodes,
value)
!=
NULL){
RecordCode*
tempRC
=
(RecordCode*)findElement(*indiListPtr,
&compareIDCodes,
value);
Individual
*
tempIndi
=
(Individual*)tempRC->pointerAddress;
string start = 21
NUMBER OF arrows IN WORD (Individual*)tempRC->pointerAddress; : 1
//Insert
into
linked
list
insertBack(&tempFam->children,
string start = 21
NUMBER OF arrows IN WORD insertBack(&tempFam->children, : 1
(void*)tempIndi);
//After
populating
one
individual
into
a
family,
insert
into
their
families
list
insertBack(&tempIndi->families,
string start = 22
NUMBER OF arrows IN WORD insertBack(&tempIndi->families, : 1
(void*)tempFam);
}
else
{
foundError.type
=
INV_GEDCOM;
foundError.line
=
-1;
free(line);
return
foundError;
}
}
else
if(checkIfFamEvent(tag)
==
true){
//Moves
back
by
one
line
fseek(fp,
-lineSize-1,
SEEK_CUR);
(*currentLine)--;
foundError
=
parseEvent(fp,
NULL,
&tempFam,
currentLine);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
}
else
{
//Make
space
for
a
new
otherfields
node
Field
*tempField
=
malloc(sizeof(Field));
foundError
=
checkIfMallocNull(tempField);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
tempField->tag
string start = 11
NUMBER OF arrows IN WORD tempField->tag : 1
=
malloc(sizeof(char)*(strlen(tag)
+1));
foundError
=
checkIfMallocNull(tempField->tag);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->tag); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->tag,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->tag, : 1
tag);
//If
no
value,
return
error
if(value
==
NULL){
foundError.type
=
INV_RECORD;
foundError.line
=
*currentLine;
free(line);
free(tempField->tag);
string start = 16
NUMBER OF arrows IN WORD free(tempField->tag); : 1
free(tempField);
return
foundError;
}
else
{
tempField->value
string start = 11
NUMBER OF arrows IN WORD tempField->value : 1
=
malloc(sizeof(char)*(strlen(value)
+1));
foundError
=
checkIfMallocNull(tempField->value);
string start = 29
NUMBER OF arrows IN WORD checkIfMallocNull(tempField->value); : 1
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
strcpy(tempField->value,
string start = 18
NUMBER OF arrows IN WORD strcpy(tempField->value, : 1
value);
}
//Insert
into
linked
list
insertBack(&tempFam->otherFields,
string start = 21
NUMBER OF arrows IN WORD insertBack(&tempFam->otherFields, : 1
(void*)tempField);
}
}
free(line);
}
return
foundError;
}
//-------------------------------------------------------PARSE
FILE-------------------------------------------------------
GEDCOMerror
parseFile(FILE*
fp,
GEDCOMobject**
obj,
List
*
indiListPtr){
GEDCOMerror
foundError;
foundError.type
=
OK;
foundError.line
=
-1;
int
currentLine
=
0,
currentNum
=
0,
prevNum
=
0;
char*
line;
bool
foundSUBM
=
false,
foundTRLR
=
false;
//Parse
Header
foundError
=
parseHeader(fp,
obj,
&currentLine);
if(foundError.type
!=
OK){
return
foundError;
}
//Check
if
next
line
is
individual
or
family
or
submitter
while((line
=
getNextLine(fp))
!=
NULL){
//Verify
line
is
not
too
long
if(strcmp(line,
"invalid")
==
0){
foundError.type
=
INV_RECORD;
foundError.line
=
currentLine;
free(line);
return
foundError;
}
//Tokenize
line
int
lineSize
=
strlen(line);
//printf("line:
%s\n",
line);
if(lineSize
>
1){
char
*lineNum
=
strtok(line,
"
\t");
//Checks
validity
of
line
numbers
if(!isStringDigit(lineNum)){
foundError.type
=
INV_RECORD;
foundError.line
=
currentLine;
free(line);
return
foundError;
}
currentNum
=
atoi(lineNum);
if(currentNum
!=
prevNum
&&
currentNum
!=
prevNum-1
&&
currentNum
!=
prevNum+1){
if(currentNum
>
prevNum
&&
currentNum
!=
prevNum+1){
foundError.type
=
INV_RECORD;
foundError.line
=
currentLine;
free(line);
return
foundError;
}
}
prevNum
=
currentNum;
char
*tag
=
strtok(NULL,
"
\t");
if(tag
==
NULL
||
strlen(tag)
>
31){
foundError.type
=
INV_RECORD;
foundError.line
=
currentLine;
free(line);
return
foundError;
}
//char
*value
=
strtok(NULL,
"\0");
//Checks
for
individual
records
if(strncmp(tag,
"@I",
2)
==
0){
if(strlen(tag)
>
22){
foundError.type
=
INV_RECORD;
foundError.line
=
currentLine;
free(line);
return
foundError;
}
fseek(fp,
-lineSize-1,
SEEK_CUR);
foundError
=
parseIndividual(fp,
obj,
&currentLine,
indiListPtr);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
//Checks
for
family
records
}
else
if(strncmp(tag,
"@F",
2)
==
0){
if(strlen(tag)
>
22){
foundError.type
=
INV_RECORD;
foundError.line
=
currentLine;
free(line);
return
foundError;
}
//Parses
family
on
second
loop
through
file
currentLine++;
//Checks
for
submitter
records
}
else
if(strcmp(tag,
(*obj)->header->submitter->submitterName)
string start = 8
string start = 16
string start = 27
NUMBER OF arrows IN WORD (*obj)->header->submitter->submitterName) : 3
==
0
&&
foundSUBM
==
false){
currentLine++;
foundError
=
parseSubmitter(fp,
obj,
&currentLine);
if(foundError.type
!=
OK
||
strlen(tag)
>
22){
free(line);
return
foundError;
}
foundSUBM
=
true;
//Checks
for
end
of
file
}
else
if(strcmp(tag,
"TRLR")
==
0){
currentLine++;
foundTRLR
=
true;
free(line);
//If
no
submitter
record
was
found
by
the
end
of
the
file
if(foundSUBM
==
false){
foundError.type
=
INV_GEDCOM;
foundError.line
=
-1;
return
foundError;
}
//clearList(indiListPtr);
break;
//return
foundError;
//If
not
one
of
the
above,
then
skip
line
}
else
{
currentLine++;
}
}
free(line);
}
if(foundTRLR
==
false){
foundError.type
=
INV_GEDCOM;
foundError.line
=
-1;
return
foundError;
}
currentLine
=
1;
//Seek
back
to
top
of
file
and
link
all
families
with
individuals
//No
error
checking
because
already
conducted
on
first
read
through
fseek(fp,
0,
SEEK_SET);
while((line
=
getNextLine(fp))
!=
NULL){
int
lineSize
=
strlen(line);
//printf("line:
%s\n",
line);
if(lineSize
>
1){
strtok(line,
"
\t");
char
*tag
=
strtok(NULL,
"
\t");
if(strncmp(tag,
"@F",
2)
==
0){
foundError
=
parseFamily(fp,
obj,
&currentLine,
indiListPtr);
if(foundError.type
!=
OK){
free(line);
return
foundError;
}
}
else
if(strcmp(tag,
"TRLR")
==
0){
free(line);
//clearList(indiListPtr);
return
foundError;
//If
not
one
of
the
above,
then
skip
line
}
else
{
currentLine++;
}
}
free(line);
}
return
foundError;
}
/**
*
@file
GEDCOMparser.c
*
@author
Jovana
Kusic
*
@studentID
0955683
*
@date
January
2018
*
@source
file
that
has
all
the
necessary
extra
functions
to
create,
print
&
delete
a
GEDCOM
object
**/
#include
"GEDCOMparser.h"
#include
"GEDCOMutilities.h"
#include
<stdbool.h>
#define
DEBUG
0
GEDCOMerror
createGEDCOM(char*
fileName,
GEDCOMobject**
obj){
GEDCOMerror
errorFound;
errorFound.type
=
OK;
errorFound.line
=
-1;
//---------------------------------------------FILE
CHECKING----------------------------------------------------
bool
correctFile
=
checkFile(fileName);
//Checks
is
all
conditions
for
proper
filename
are
met
if(correctFile
==
false){
errorFound.type
=
INV_FILE;
errorFound.line
=
-1;
return
errorFound;
}
//Checks
to
see
if
file
can
be
opened
FILE
*
fp
=
NULL;
if
(!(fp
=
fopen
(fileName,
"r")))
{
errorFound.type
=
INV_FILE;
errorFound.line
=
-1;
return
errorFound;
}
//Checks
for
empty
file
long
offset
=
ftell(fp);
fseek(fp,
0,
SEEK_END);
if
(ftell(fp)
==
0){
errorFound.type
=
INV_FILE;
errorFound.line
=
-1;
fclose(fp);
return
errorFound;
}
fseek(fp,
offset,
SEEK_SET);
//-----------------------------------------FILE
PARSING---------------------------------------------------
//Mallocs
space
for
all
elements
of
object
*obj
=
malloc(sizeof(GEDCOMobject));
if(*obj
==
NULL){
if(DEBUG){
fprintf(stderr,
"mallocing
obj
failed");
}
errorFound.type
=
OTHER_ERROR;
errorFound.line
=
-1;
fclose(fp);
return
errorFound;
}
//Initialize
all
values
of
the
GEDCOM
object
(*obj)->header
string start = 8
NUMBER OF arrows IN WORD (*obj)->header : 1
=
malloc(sizeof(Header));
(*obj)->header->source[0]
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->source[0] : 2
=
'\0';
(*obj)->header->gedcVersion
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->gedcVersion : 2
=
0;
(*obj)->header->encoding
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->encoding : 2
=
0;
(*obj)->header->submitter
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->submitter : 2
=
NULL;
(*obj)->submitter
string start = 8
NUMBER OF arrows IN WORD (*obj)->submitter : 1
=
malloc(sizeof(Submitter)
+
sizeof(char)*256);
(*obj)->individuals
string start = 8
NUMBER OF arrows IN WORD (*obj)->individuals : 1
=
initializeList(&printIndividual,
&deleteIndividual,
&compareIndividuals);
(*obj)->families
string start = 8
NUMBER OF arrows IN WORD (*obj)->families : 1
=
initializeList(&printFamily,
&deleteFamily,
&compareFamilies);
//Extra
initializations
(*obj)->header->otherFields
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->otherFields : 2
=
initializeList(&printField,
&deleteField,
&compareFields);
(*obj)->submitter->otherFields
string start = 8
string start = 19
NUMBER OF arrows IN WORD (*obj)->submitter->otherFields : 2
=
initializeList(&printField,
&deleteField,
&compareFields);
//Make
list
to
store
all
individual
pointers
&
their
addresses
in
memory
List
listOfIndividuals
=
initializeList(&printRecordCode,
&deleteRecordCode,
&compareRecordCodes);
List
*
indiListPtr
=
&listOfIndividuals;
//Parse
file
errorFound
=
parseFile(fp,
obj,
indiListPtr);
//If
parsing
file
returned
error,
free
all
memory
if(errorFound.type
!=
OK){
deleteGEDCOM(*obj);
}
clearList(indiListPtr);
fclose(fp);
return
errorFound;
}
//---------------------------------------------EXTRA
FUNCTIONS-----------------------------------------------
Individual*
findPerson(const
GEDCOMobject*
familyRecord,
bool
(*compare)(const
void*
first,
const
void*
second),
const
void*
person){
if(familyRecord
==
NULL
||
person
==
NULL){
return
NULL;
}
void*
result
=
findElement(familyRecord->individuals,
string start = 26
NUMBER OF arrows IN WORD findElement(familyRecord->individuals, : 1
compare,
person);
if(result
==
NULL){
return
NULL;
}
Individual*
foundPerson
=
(Individual*)result;
return
foundPerson;
}
List
getDescendants(const
GEDCOMobject*
familyRecord,
const
Individual*
person){
List
descendants
=
initializeList(&printIndividual,
&deleteIndividualCopy,
&compareIndividuals);
if(familyRecord
==
NULL
||
person
==
NULL){
return
descendants;
}
addChildToList(&descendants,
person->families,
string start = 8
NUMBER OF arrows IN WORD person->families, : 1
person);
return
descendants;
}
void
deleteGEDCOM(GEDCOMobject*
obj){
if(obj
!=
NULL){
if(obj->header
string start = 8
NUMBER OF arrows IN WORD if(obj->header : 1
!=
NULL){
if(&obj->header->otherFields
string start = 9
string start = 17
NUMBER OF arrows IN WORD if(&obj->header->otherFields : 2
!=
NULL){
clearList(&obj->header->otherFields);
string start = 16
string start = 24
NUMBER OF arrows IN WORD clearList(&obj->header->otherFields); : 2
}
}
//Not
header->submitter
string start = 8
NUMBER OF arrows IN WORD header->submitter : 1
because
both
point
to
same
thing
if(obj->submitter
string start = 8
NUMBER OF arrows IN WORD if(obj->submitter : 1
!=
NULL){
if(&obj->submitter->otherFields
string start = 9
string start = 20
NUMBER OF arrows IN WORD if(&obj->submitter->otherFields : 2
!=
NULL){
clearList(&obj->submitter->otherFields);
string start = 16
string start = 27
NUMBER OF arrows IN WORD clearList(&obj->submitter->otherFields); : 2
}
free(obj->submitter);
string start = 10
NUMBER OF arrows IN WORD free(obj->submitter); : 1
}
if(obj->header
string start = 8
NUMBER OF arrows IN WORD if(obj->header : 1
!=
NULL){
free(obj->header);
string start = 10
NUMBER OF arrows IN WORD free(obj->header); : 1
}
if(&obj->individuals
string start = 9
NUMBER OF arrows IN WORD if(&obj->individuals : 1
!=
NULL){
clearList(&obj->individuals);
string start = 16
NUMBER OF arrows IN WORD clearList(&obj->individuals); : 1
}
if(&obj->families
string start = 9
NUMBER OF arrows IN WORD if(&obj->families : 1
!=
NULL){
clearList(&obj->families);
string start = 16
NUMBER OF arrows IN WORD clearList(&obj->families); : 1
}
free(obj);
}
}
char*
printGEDCOM(const
GEDCOMobject*
obj){
if(obj
==
NULL){
return
NULL;
}
char*
individualPrint
=
toString(obj->individuals);
string start = 14
NUMBER OF arrows IN WORD toString(obj->individuals); : 1
int
lengthOfString
=
strlen(individualPrint)
+
strlen(individualPrint)
+
strlen(obj->header->source)
string start = 12
string start = 20
NUMBER OF arrows IN WORD strlen(obj->header->source) : 2
+
2
+
strlen(obj->submitter->submitterName)
string start = 12
string start = 23
NUMBER OF arrows IN WORD strlen(obj->submitter->submitterName) : 2
+
2
+
strlen(obj->submitter->address)
string start = 12
string start = 23
NUMBER OF arrows IN WORD strlen(obj->submitter->address) : 2
+
2;
char*
objectPrint
=
malloc(sizeof(char*)
*(lengthOfString)
+
300);
strcpy(objectPrint,
"\n#####################GEDCOM
OBJECT#####################\n");
strcat(objectPrint,
"HEADER\n");
strcat(objectPrint,
"Source:
");
strcat(objectPrint,
obj->header->source);
string start = 5
string start = 13
NUMBER OF arrows IN WORD obj->header->source); : 2
strcat(objectPrint,
"\nVersion:
");
char
*
version
=
malloc(sizeof(char)
*
10);
sprintf(version,
"%lf",
obj->header->gedcVersion);
string start = 5
string start = 13
NUMBER OF arrows IN WORD obj->header->gedcVersion); : 2
strcat(objectPrint,
version);
free(version);
strcat(objectPrint,
"\nEncoding:
");
char
*
encoding
=
malloc(sizeof(char)
*
10);
sprintf(encoding,
"%d",
obj->header->encoding);
string start = 5
string start = 13
NUMBER OF arrows IN WORD obj->header->encoding); : 2
strcat(objectPrint,
encoding);
free(encoding);
strcat(objectPrint,
"\nSubmitter:
");
strcat(objectPrint,
obj->header->submitter->submitterName);
string start = 5
string start = 13
string start = 24
NUMBER OF arrows IN WORD obj->header->submitter->submitterName); : 3
strcat(objectPrint,
"\n\nSUBMITTER\nName:
");
strcat(objectPrint,
obj->submitter->submitterName);
string start = 5
string start = 16
NUMBER OF arrows IN WORD obj->submitter->submitterName); : 2
strcat(objectPrint,
"\nAddress:
");
strcat(objectPrint,
obj->submitter->address);
string start = 5
string start = 16
NUMBER OF arrows IN WORD obj->submitter->address); : 2
strcat(objectPrint,
"\n");
strcat(objectPrint,
individualPrint);
free(individualPrint);
return
objectPrint;
}
char*
printError(GEDCOMerror
err){
char*
errorToPrint
=
malloc(sizeof(char)*
(11
+
100));
strcpy(errorToPrint,
"____________ERROR
RETURNED____________\n");
strcat(errorToPrint,
"Error
Type:
");
if(err.type
==
OK){
strcat(errorToPrint,
"OK");
}
else
if
(err.type
==
INV_FILE){
strcat(errorToPrint,
"INV_FILE");
}
else
if
(err.type
==
INV_GEDCOM){
strcat(errorToPrint,
"INV_GEDCOM");
}
else
if
(err.type
==
INV_HEADER){
strcat(errorToPrint,
"INV_HEADER");
}
else
if
(err.type
==
INV_RECORD){
strcat(errorToPrint,
"INV_RECORD");
}
else
if
(err.type
==
OTHER_ERROR){
strcat(errorToPrint,
"OTHER_ERROR");
}
strcat(errorToPrint,
"\n");
strcat(errorToPrint,
"On
Line:
");
char
*
conversion
=
malloc(sizeof(char)
*
10);
sprintf(conversion,
"%d",
err.line);
strcat(errorToPrint,
conversion);
strcat(errorToPrint,
"\n");
free(conversion);
return
errorToPrint;
}
//--------------------------------------------HELPER
FUNCTIONS------------------------------------------------
void
deleteField(void*
toBeDeleted){
if(toBeDeleted
==
NULL){
return;
}
Field*
tempField
=
(Field*)toBeDeleted;
if(tempField
==
NULL){
return;
}
free(tempField->tag);
string start = 16
NUMBER OF arrows IN WORD free(tempField->tag); : 1
tempField->tag
string start = 11
NUMBER OF arrows IN WORD tempField->tag : 1
=
NULL;
free(tempField->value);
string start = 16
NUMBER OF arrows IN WORD free(tempField->value); : 1
tempField->value
string start = 11
NUMBER OF arrows IN WORD tempField->value : 1
=
NULL;
free(tempField);
tempField
=
NULL;
}
int
compareFields(const
void*
first,const
void*
second){
if(first
==
NULL
||
second
==
NULL){
return
-2;
}
Field*
tempFirst
=
(Field*)first;
Field*
tempSecond
=
(Field*)second;
if(tempFirst
==
NULL
||
tempSecond
==
NULL){
return
-2;
}
char*
fullFieldFirst
=
malloc(sizeof(char)
*((strlen(tempFirst->tag)+1)
string start = 21
NUMBER OF arrows IN WORD *((strlen(tempFirst->tag)+1) : 1
+
(strlen(tempFirst->value)+1))
string start = 19
NUMBER OF arrows IN WORD (strlen(tempFirst->value)+1)) : 1
+10);
char*
fullFieldSecond
=
malloc(sizeof(char)
*((strlen(tempSecond->tag)+1)
string start = 22
NUMBER OF arrows IN WORD *((strlen(tempSecond->tag)+1) : 1
+
(strlen(tempSecond->value)+1))
string start = 20
NUMBER OF arrows IN WORD (strlen(tempSecond->value)+1)) : 1
+10);
strcpy(fullFieldFirst,tempFirst->tag);
string start = 33
NUMBER OF arrows IN WORD strcpy(fullFieldFirst,tempFirst->tag); : 1
strcat(fullFieldFirst,"
");
strcat(fullFieldFirst,tempFirst->value);
string start = 33
NUMBER OF arrows IN WORD strcat(fullFieldFirst,tempFirst->value); : 1
strcpy(fullFieldSecond,tempSecond->tag);
string start = 35
NUMBER OF arrows IN WORD strcpy(fullFieldSecond,tempSecond->tag); : 1
strcat(fullFieldSecond,"
");
strcat(fullFieldSecond,tempSecond->value);
string start = 35
NUMBER OF arrows IN WORD strcat(fullFieldSecond,tempSecond->value); : 1
if(strcmp(fullFieldFirst,
fullFieldSecond)
==
0){
free(fullFieldFirst);
free(fullFieldSecond);
return
0;
}
else
if(strcmp(fullFieldFirst,
fullFieldSecond)
>
0){
free(fullFieldFirst);
free(fullFieldSecond);
return
1;
}
else
{
free(fullFieldFirst);
free(fullFieldSecond);
return
-1;
}
}
char*
printField(void*
toBePrinted){
if(toBePrinted
==
NULL){
return
"";
}
Field*
fieldPrint
=
(Field*)toBePrinted;
int
lengthOfString
=
strlen(fieldPrint->tag)
string start = 19
NUMBER OF arrows IN WORD strlen(fieldPrint->tag) : 1
+
2
+
strlen(fieldPrint->value)
string start = 19
NUMBER OF arrows IN WORD strlen(fieldPrint->value) : 1
+
2;
char*
str;
str
=
(char*)malloc(sizeof(char)*
(lengthOfString
+
100));
strcpy(str,
"Field\nTag:
");
strcat(str,
fieldPrint->tag);
string start = 12
NUMBER OF arrows IN WORD fieldPrint->tag); : 1
strcat(str,
"\nValue:
");
strcat(str,
fieldPrint->value);
string start = 12
NUMBER OF arrows IN WORD fieldPrint->value); : 1
strcat(str,
"\n");
return
str;
}
void
deleteEvent(void*
toBeDeleted){
if(toBeDeleted
==
NULL){
return;
}
Event*
tempEvent
=
(Event*)toBeDeleted;
if(tempEvent
==
NULL){
return;
}
free(tempEvent->date);
string start = 16
NUMBER OF arrows IN WORD free(tempEvent->date); : 1
tempEvent->date
string start = 11
NUMBER OF arrows IN WORD tempEvent->date : 1
=
NULL;
free(tempEvent->place);
string start = 16
NUMBER OF arrows IN WORD free(tempEvent->place); : 1
tempEvent->place
string start = 11
NUMBER OF arrows IN WORD tempEvent->place : 1
=
NULL;
clearList(&tempEvent->otherFields);
string start = 22
NUMBER OF arrows IN WORD clearList(&tempEvent->otherFields); : 1
free(tempEvent);
tempEvent
=
NULL;
}
int
compareEvents(const
void*
first,const
void*
second){
if(first
==
NULL
||
second
==
NULL){
return
-2;
}
Event*
tempFirst
=
(Event*)first;
Event*
tempSecond
=
(Event*)second;
if(tempFirst
==
NULL
||
tempSecond
==
NULL){
return
-2;
}
if(strcmp(tempFirst->type,
string start = 21
NUMBER OF arrows IN WORD if(strcmp(tempFirst->type, : 1
tempSecond->type)
string start = 12
NUMBER OF arrows IN WORD tempSecond->type) : 1
==
0){
return
0;
}
else
if(strcmp(tempFirst->type,
string start = 21
NUMBER OF arrows IN WORD if(strcmp(tempFirst->type, : 1
tempSecond->type)
string start = 12
NUMBER OF arrows IN WORD tempSecond->type) : 1
>
0){
return
1;
}
else
{
return
-1;
}
}
char*
printEvent(void*
toBePrinted){
if(toBePrinted
==
NULL){
return
"";
}
Event*
eventPrint
=
(Event*)toBePrinted;
int
lengthOfString
=
strlen(eventPrint->type)
string start = 19
NUMBER OF arrows IN WORD strlen(eventPrint->type) : 1
+
2
+
strlen(eventPrint->date)
string start = 19
NUMBER OF arrows IN WORD strlen(eventPrint->date) : 1
+
2
+
strlen(eventPrint->place)
string start = 19
NUMBER OF arrows IN WORD strlen(eventPrint->place) : 1
+
2;
char*
otherFields
=
toString(eventPrint->otherFields);
string start = 21
NUMBER OF arrows IN WORD toString(eventPrint->otherFields); : 1
int
lengthOfOtherFields
=
strlen(otherFields)
+
2;
char*
str;
str
=
(char*)malloc(sizeof(char)*
(lengthOfString
+
lengthOfOtherFields
+
100));
strcpy(str,
"Event\nType:
");
strcat(str,
eventPrint->type);
string start = 12
NUMBER OF arrows IN WORD eventPrint->type); : 1
strcat(str,
"\nDate:
");
strcat(str,
eventPrint->date);
string start = 12
NUMBER OF arrows IN WORD eventPrint->date); : 1
strcat(str,
"\nPlace:
");
strcat(str,
eventPrint->place);
string start = 12
NUMBER OF arrows IN WORD eventPrint->place); : 1
strcat(str,
"\n");
strcat(str,
otherFields);
free(otherFields);
return
str;
}
void
deleteIndividual(void*
toBeDeleted){
if(toBeDeleted
==
NULL){
return;
}
Individual*
tempIndi
=
(Individual*)toBeDeleted;
if(tempIndi
==
NULL){
return;
}
free(tempIndi->givenName);
string start = 15
NUMBER OF arrows IN WORD free(tempIndi->givenName); : 1
tempIndi->givenName
string start = 10
NUMBER OF arrows IN WORD tempIndi->givenName : 1
=
NULL;
free(tempIndi->surname);
string start = 15
NUMBER OF arrows IN WORD free(tempIndi->surname); : 1
tempIndi->surname
string start = 10
NUMBER OF arrows IN WORD tempIndi->surname : 1
=
NULL;
clearList(&tempIndi->events);
string start = 21
NUMBER OF arrows IN WORD clearList(&tempIndi->events); : 1
clearListNodes(&tempIndi->families);
string start = 26
NUMBER OF arrows IN WORD clearListNodes(&tempIndi->families); : 1
clearList(&tempIndi->otherFields);
string start = 21
NUMBER OF arrows IN WORD clearList(&tempIndi->otherFields); : 1
free(tempIndi);
tempIndi
=
NULL;
}
int
compareIndividuals(const
void*
first,const
void*
second){
if(first
==
NULL
||
second
==
NULL){
return
-2;
}
Individual*
tempFirst
=
(Individual*)first;
Individual*
tempSecond
=
(Individual*)second;
if(tempFirst
==
NULL
||
tempSecond
==
NULL){
return
-2;
}
char*
fullNameFirst
=
malloc(sizeof(char)
*((strlen(tempFirst->givenName)+1)
string start = 21
NUMBER OF arrows IN WORD *((strlen(tempFirst->givenName)+1) : 1
+
(strlen(tempFirst->surname)+1))
string start = 19
NUMBER OF arrows IN WORD (strlen(tempFirst->surname)+1)) : 1
+10);
char*
fullNameSecond
=
malloc(sizeof(char)
*((strlen(tempSecond->givenName)+1)
string start = 22
NUMBER OF arrows IN WORD *((strlen(tempSecond->givenName)+1) : 1
+
(strlen(tempSecond->surname)+1))
string start = 20
NUMBER OF arrows IN WORD (strlen(tempSecond->surname)+1)) : 1
+10);
strcpy(fullNameFirst,tempFirst->surname);
string start = 32
NUMBER OF arrows IN WORD strcpy(fullNameFirst,tempFirst->surname); : 1
strcat(fullNameFirst,",");
strcat(fullNameFirst,tempFirst->givenName);
string start = 32
NUMBER OF arrows IN WORD strcat(fullNameFirst,tempFirst->givenName); : 1
strcpy(fullNameSecond,tempSecond->surname);
string start = 34
NUMBER OF arrows IN WORD strcpy(fullNameSecond,tempSecond->surname); : 1
strcat(fullNameSecond,",");
strcat(fullNameSecond,tempSecond->givenName);
string start = 34
NUMBER OF arrows IN WORD strcat(fullNameSecond,tempSecond->givenName); : 1
if(strcmp(fullNameFirst,
fullNameSecond)
==
0){
free(fullNameFirst);
free(fullNameSecond);
return
0;
}
else
if(strcmp(fullNameFirst,
fullNameSecond)
>
0){
free(fullNameFirst);
free(fullNameSecond);
return
1;
}
else
{
free(fullNameFirst);
free(fullNameSecond);
return
-1;
}
}
char*
printIndividual(void*
toBePrinted){
if(toBePrinted
==
NULL){
return
"";
}
Individual*
indiPrint
=
(Individual*)toBePrinted;
int
lengthOfString
=
strlen(indiPrint->givenName)
string start = 18
NUMBER OF arrows IN WORD strlen(indiPrint->givenName) : 1
+
2
+
strlen(indiPrint->surname)
string start = 18
NUMBER OF arrows IN WORD strlen(indiPrint->surname) : 1
+
2;
char*
otherFields
=
toString(indiPrint->otherFields);
string start = 20
NUMBER OF arrows IN WORD toString(indiPrint->otherFields); : 1
char*
events
=
toString(indiPrint->events);
string start = 20
NUMBER OF arrows IN WORD toString(indiPrint->events); : 1
char*
families
=
"";
if(getLength(indiPrint->families)
string start = 24
NUMBER OF arrows IN WORD if(getLength(indiPrint->families) : 1
>
0){
families
=
toString(indiPrint->families);
string start = 20
NUMBER OF arrows IN WORD toString(indiPrint->families); : 1
}
int
lengthOfLists
=
strlen(otherFields)
+
2
+
strlen(events)
+
2
+
strlen(families)
+
2;
char*
str;
str
=
(char*)malloc(sizeof(char)*
(lengthOfString
+
lengthOfLists
+
500));
strcpy(str,
"------------INDIVIDUAL------------\nGiven
Name:
");
strcat(str,
indiPrint->givenName);
string start = 11
NUMBER OF arrows IN WORD indiPrint->givenName); : 1
strcat(str,
"\nSurname:
");
strcat(str,
indiPrint->surname);
string start = 11
NUMBER OF arrows IN WORD indiPrint->surname); : 1
strcat(str,
"\n");
if(strlen(events)
!=
0){
strcat(str,
"\nINDIVIDUAL
EVENTS");
strcat(str,
events);
}
if(strlen(families)
!=
0){
strcat(str,
families);
strcat(str,
"\n");
}
if(strlen(otherFields)
!=
0){
strcat(str,
"\nINDIVIDUAL
FIELDS");
strcat(str,
otherFields);
}
free(otherFields);
free(events);
if(getLength(indiPrint->families)
string start = 24
NUMBER OF arrows IN WORD if(getLength(indiPrint->families) : 1
>
0){
free(families);
}
return
str;
}
void
deleteFamily(void*
toBeDeleted){
if(toBeDeleted
==
NULL){
return;
}
Family*
tempFamily
=
(Family*)toBeDeleted;
if(tempFamily
==
NULL){
return;
}
clearListNodes(&tempFamily->children);
string start = 28
NUMBER OF arrows IN WORD clearListNodes(&tempFamily->children); : 1
clearList(&tempFamily->events);
string start = 23
NUMBER OF arrows IN WORD clearList(&tempFamily->events); : 1
clearList(&tempFamily->otherFields);
string start = 23
NUMBER OF arrows IN WORD clearList(&tempFamily->otherFields); : 1
free(tempFamily);
tempFamily
=
NULL;
}
int
compareFamilies(const
void*
first,const
void*
second){
int
numFirstMembers
=
0,
numSecondMembers
=
0;
if(first
==
NULL
||
second
==
NULL){
return
-2;
}
Family*
tempFirst
=
(Family*)first;
Family*
tempSecond
=
(Family*)second;
if(tempFirst
==
NULL
||
tempSecond
==
NULL){
return
-2;
}
//-1
if
first
family
has
fewer
members
than
second
one
//0
if
first
&
second
family
have
same
#
of
members
//1
if
first
family
has
more
members
than
second
one
if(tempFirst->wife
string start = 14
NUMBER OF arrows IN WORD if(tempFirst->wife : 1
!=
NULL){
numFirstMembers++;
}
if(tempSecond->wife
string start = 15
NUMBER OF arrows IN WORD if(tempSecond->wife : 1
!=
NULL){
numSecondMembers++;
}
if(tempFirst->husband
string start = 14
NUMBER OF arrows IN WORD if(tempFirst->husband : 1
!=
NULL){
numFirstMembers++;
}
if(tempSecond->husband
string start = 15
NUMBER OF arrows IN WORD if(tempSecond->husband : 1
!=
NULL){
numSecondMembers++;
}
numFirstMembers
=
numFirstMembers
+
getLength(tempFirst->children);
string start = 21
NUMBER OF arrows IN WORD getLength(tempFirst->children); : 1
numSecondMembers
=
numSecondMembers
+
getLength(tempSecond->children);
string start = 22
NUMBER OF arrows IN WORD getLength(tempSecond->children); : 1
if(numFirstMembers
>
numSecondMembers){
return
1;
}
else
if(numFirstMembers
<
numSecondMembers){
return
-1;
}
return
0;
}
char*
printFamily(void*
toBePrinted){
if(toBePrinted
==
NULL){
return
"";
}
Family*
famPrint
=
(Family*)toBePrinted;
int
lengthOfString
=
0;
if(famPrint->wife
string start = 13
NUMBER OF arrows IN WORD if(famPrint->wife : 1
!=
NULL){
lengthOfString
=
lengthOfString
+
strlen(famPrint->wife->givenName)
string start = 17
string start = 23
NUMBER OF arrows IN WORD strlen(famPrint->wife->givenName) : 2
+
2
+
strlen(famPrint->wife->surname)
string start = 17
string start = 23
NUMBER OF arrows IN WORD strlen(famPrint->wife->surname) : 2
+
2;
}
if(famPrint->husband
string start = 13
NUMBER OF arrows IN WORD if(famPrint->husband : 1
!=
NULL){
lengthOfString
=
lengthOfString
+
strlen(famPrint->husband->givenName)
string start = 17
string start = 26
NUMBER OF arrows IN WORD strlen(famPrint->husband->givenName) : 2
+
2
+
strlen(famPrint->husband->surname)
string start = 17
string start = 26
NUMBER OF arrows IN WORD strlen(famPrint->husband->surname) : 2
+
2;
}
char*
otherFields
=
"";
char*
events
=
"";
char*
children
=
"";
if(getLength(famPrint->children)
string start = 23
NUMBER OF arrows IN WORD if(getLength(famPrint->children) : 1
>
0){
children
=
toString(famPrint->children);
string start = 19
NUMBER OF arrows IN WORD toString(famPrint->children); : 1
}
if(getLength(famPrint->events)
string start = 23
NUMBER OF arrows IN WORD if(getLength(famPrint->events) : 1
>
0){
events
=
toString(famPrint->events);
string start = 19
NUMBER OF arrows IN WORD toString(famPrint->events); : 1
}
if(getLength(famPrint->otherFields)
string start = 23
NUMBER OF arrows IN WORD if(getLength(famPrint->otherFields) : 1
>
0){
otherFields
=
toString(famPrint->otherFields);
string start = 19
NUMBER OF arrows IN WORD toString(famPrint->otherFields); : 1
}
int
lengthOfLists
=
strlen(otherFields)
+
2
+
strlen(events)
+
2
+
strlen(children)
+
2;
char*
str;
str
=
(char*)malloc(sizeof(char)*
(lengthOfString
+
lengthOfLists
+
100));
strcpy(str,
"\nFAMILY\nWife:
");
if(famPrint->wife
string start = 13
NUMBER OF arrows IN WORD if(famPrint->wife : 1
!=
NULL){
strcat(str,
famPrint->wife->givenName);
string start = 10
string start = 16
NUMBER OF arrows IN WORD famPrint->wife->givenName); : 2
strcat(str,
"
");
strcat(str,
famPrint->wife->surname);
string start = 10
string start = 16
NUMBER OF arrows IN WORD famPrint->wife->surname); : 2
}
strcat(str,
"\nHusband:
");
if(famPrint->husband
string start = 13
NUMBER OF arrows IN WORD if(famPrint->husband : 1
!=
NULL){
strcat(str,
famPrint->husband->givenName);
string start = 10
string start = 19
NUMBER OF arrows IN WORD famPrint->husband->givenName); : 2
strcat(str,
"
");
strcat(str,
famPrint->husband->surname);
string start = 10
string start = 19
NUMBER OF arrows IN WORD famPrint->husband->surname); : 2
}
strcat(str,
children);
strcat(str,
"\n");
if(strlen(events)
!=
0){
strcat(str,
"\nFAMILY
EVENTS");
strcat(str,
events);
}
if(strlen(otherFields)
!=
0){
strcat(str,
"\nFAMILY
FIELDS");
strcat(str,
otherFields);
}
if(getLength(famPrint->children)
string start = 23
NUMBER OF arrows IN WORD if(getLength(famPrint->children) : 1
>
0){
free(children);
}
if(getLength(famPrint->events)
string start = 23
NUMBER OF arrows IN WORD if(getLength(famPrint->events) : 1
>
0){
free(events);
}
if(getLength(famPrint->otherFields)
string start = 23
NUMBER OF arrows IN WORD if(getLength(famPrint->otherFields) : 1
>
0){
free(otherFields);
}
return
str;
}
#ifndef
GEDCOMPARSER_H
#define
GEDCOMPARSER_H
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
"LinkedListAPI.h"
//For
simplicity,
the
examples
we
will
use
will
only
use
the
ASCII
subset
of
these
encodings
typedef
enum
cSet
{ANSEL,
UTF8,
UNICODE,
ASCII}
CharSet;
//error
code
enum
typedef
enum
eCode
{OK,
INV_FILE,
INV_GEDCOM,
INV_HEADER,
INV_RECORD,
OTHER_ERROR}
ErrorCode;
//Represents
a
generic
event,
e.g.
individual
event,
family
event,
etc.
typedef
struct
{
//The
max
length
of
this
field
is
known
from
the
GEDCOM
spec,
so
we
can
use
a
statically
allocated
array
char
type[5];
//Empty
string
if
not
provided
char*
date;
//Empty
string
if
not
provided
char*
place;
//All
other
event
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Event;
//Represents
a
generic
field.
typedef
struct
{
//Field
tag.
Must
not
be
NULL/empty.
char*
tag;
//Field
value.
Must
not
be
NULL/empty.
char*
value;
}
Field;
//Represents
a
submitter
record.
This
is
a
separate
type/struct,
in
case
we
decide
to
expand
it
in
later
assignments
typedef
struct
{
//Submitter
name
has
a
max
length
and
only
appears
once,
so
we
can
hardcode
it
char
submitterName[61];
//All
other
submitter
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
//Submitted
address.
We
use
a
C99
flexible
array
member,
which
we
will
discuss
in
class.
char
address[];
}
Submitter;
/*
Represents
the
GEDCOM
header
Only
includes
required
fields
("line
values"
in
GEDCOM
terminology)
Note
that
while
GEDCOM_FORM
is
required,
but
for
us
it
will
always
be
Lineage-Linked
*/
typedef
struct
{
//Header
source
-
i.e.
software
that
produced
the
GEDCOM
file
char
source[249];
//GEDCOM
version
float
gedcVersion;
//Encoding.
We
use
an
enum,
since
there
are
only
4
possible
values.
CharSet
encoding;
//Reference
to
the
submitter
record
Submitter*
submitter;
//All
other
header
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Header;
//Represends
GEDCOM
individual
record
typedef
struct
{
//Set
to
empty
string
if
not
present
in
file
char*
givenName;
//Set
to
empty
string
if
not
present
in
file
char*
surname;
//Collection
of
individual
events.
All
objects
in
the
list
will
be
of
type
Event.
It
may
be
empty.
List
events;
//Collection
of
family
references.
All
objects
in
the
list
will
be
of
type
Family.
It
may
be
empty.
List
families;
//All
other
individual
record
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Individual;
//Represends
GEDCOM
family
record
typedef
struct
{
//Wife
reference
(can
be
null)
Individual*
wife;
//Husband
reference
(can
be
null)
Individual*
husband;
//List
of
child
references.
All
objects
in
the
list
will
be
of
type
Individual.
It
may
be
empty.
List
children;
//Collection
of
family
events.
All
objects
in
the
list
will
be
of
type
Event.
It
may
be
empty.
List
events;
//List
of
other
fields
in
the
family
record.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Family;
//Represents
a
GEDCOM
object
typedef
struct
{
//Header.
Must
not
be
NULL.
Header*
header;
//Family
records.
All
objects
in
the
list
will
be
of
type
Family.
It
may
be
empty.
List
families;
//Must
contain
type
//Individual
records.
All
objects
in
the
list
will
be
of
type
Individual.
It
may
be
empty.
List
individuals;
//Must
contain
type
Family
//Submitter.
Must
not
be
NULL.
Submitter*
submitter;
//All
other
records
should
be
ignored
for
now
}
GEDCOMobject;
//Error
type
typedef
struct
{
ErrorCode
type;
int
line;
}
GEDCOMerror;
//*****************************************
GEDCOOM
object
functions
*****************************************
/**
Function
to
create
a
GEDCOM
object
based
on
the
contents
of
an
GEDCOM
file.
*@pre
File
name
cannot
be
an
empty
string
or
NULL.
File
name
must
have
the
.ged
extension.
File
represented
by
this
name
must
exist
and
must
be
readable.
*@post
Either:
A
valid
GEDCOM
has
been
created,
its
address
was
stored
in
the
variable
obj,
and
OK
was
returned
or
An
error
occurred,
the
GEDCOM
was
not
created,
all
temporary
memory
was
freed,
obj
was
set
to
NULL,
and
the
appropriate
error
code
was
returned
*@return
the
error
code
indicating
success
or
the
error
encountered
when
parsing
the
GEDCOM
*@param
fileName
-
a
string
containing
the
name
of
the
GEDCOM
file
*@param
a
double
pointer
to
a
GEDCOMobject
struct
that
needs
to
be
allocated
**/
GEDCOMerror
createGEDCOM(char*
fileName,
GEDCOMobject**
obj);
/**
Function
to
create
a
string
representation
of
a
GEDCOMobject.
*@pre
GEDCOMobject
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOMobject
has
not
been
modified
in
any
way,
and
a
string
representing
the
GEDCOM
contents
has
been
created
*@return
a
string
contaning
a
humanly
readable
representation
of
a
GEDCOMobject
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
char*
printGEDCOM(const
GEDCOMobject*
obj);
/**
Function
to
delete
all
GEDCOM
object
content
and
free
all
the
memory.
*@pre
GEDCOM
object
exists,
is
not
null,
and
has
not
been
freed
*@post
GEDCOM
object
had
been
freed
*@return
none
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
void
deleteGEDCOM(GEDCOMobject*
obj);
/**
Function
to
"convert"
the
GEDCOMerror
into
a
humanly
redabale
string.
*@return
a
string
contaning
a
humanly
readable
representation
of
the
error
code
*@param
err
-
an
error
struct
**/
char*
printError(GEDCOMerror
err);
/**
Function
that
searches
for
an
individual
in
the
list
using
a
comparator
function.
*
If
an
individual
is
found,
a
pointer
to
the
Individual
record
*
Returns
NULL
if
the
individual
is
not
found.
*@pre
GEDCOM
object
exists,is
not
NULL,
and
is
valid.
Comparator
function
has
been
provided.
*@post
GEDCOM
object
remains
unchanged.
*@return
The
Individual
record
associated
with
the
person
that
matches
the
search
criteria.
If
the
Individual
record
is
not
found,
return
NULL.
*If
multiple
records
match
the
search
criteria,
return
the
first
one.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
compare
-
a
pointer
to
comparator
fuction
for
customizing
the
search
*@param
person
-
a
pointer
to
search
data,
which
contains
seach
criteria
*Note:
while
the
arguments
of
compare()
and
person
are
all
void,
it
is
assumed
that
records
they
point
to
are
*
all
of
the
same
type
-
just
like
arguments
to
the
compare()
function
in
the
List
struct
**/
Individual*
findPerson(const
GEDCOMobject*
familyRecord,
bool
(*compare)(const
void*
first,
const
void*
second),
const
void*
person);
/**
Function
to
return
a
list
of
all
descendants
of
an
individual
in
a
GEDCOM
*@pre
GEDCOM
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOM
object
has
not
been
modified
in
any
way,
and
a
list
of
descendants
has
been
created
*@return
a
list
of
descendants.
The
list
may
be
empty.
All
list
members
must
be
of
type
Individual,
and
can
appear
in
any
order.
*All
list
members
must
be
COPIES
of
the
Individual
records
in
the
GEDCOM
file.
If
the
returned
list
is
freed,
the
original
GEDCOM
*must
remain
unaffected.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
person
-
the
Individual
record
whose
descendants
we
want
**/
List
getDescendants(const
GEDCOMobject*
familyRecord,
const
Individual*
person);
//************************************************************************************************************
//******************************************
List
helper
functions
*******************************************
void
deleteEvent(void*
toBeDeleted);
int
compareEvents(const
void*
first,const
void*
second);
char*
printEvent(void*
toBePrinted);
void
deleteIndividual(void*
toBeDeleted);
int
compareIndividuals(const
void*
first,const
void*
second);
char*
printIndividual(void*
toBePrinted);
void
deleteFamily(void*
toBeDeleted);
int
compareFamilies(const
void*
first,const
void*
second);
char*
printFamily(void*
toBePrinted);
void
deleteField(void*
toBeDeleted);
int
compareFields(const
void*
first,const
void*
second);
char*
printField(void*
toBePrinted);
//************************************************************************************************************
#endif
/**
*
@file
LinkedListAPI.h
*
@author
Student3
*
@brief
File
containing
the
function
definitions
of
a
doubly
linked
list
*/
#ifndef
_LIST_API_
#define
_LIST_API_
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
/**
*
Node
of
a
linked
list.
This
list
is
doubly
linked,
meaning
that
it
has
points
to
both
the
node
immediately
in
front
*
of
it,
as
well
as
the
node
immediately
behind
it.
**/
typedef
struct
listNode{
void*
data;
struct
listNode*
previous;
struct
listNode*
next;
}
Node;
/**
*
Metadata
head
of
the
list.
*
Contains
no
actual
data
but
contains
*
information
about
the
list
(head
and
tail)
as
well
as
the
function
pointers
*
for
working
with
the
abstracted
list
data.
**/
typedef
struct
listHead{
Node*
head;
Node*
tail;
int
length;
void
(*deleteData)(void*
toBeDeleted);
int
(*compare)(const
void*
first,const
void*
second);
char*
(*printData)(void*
toBePrinted);
}
List;
/**
*
List
iterator
structure.
*
It
represents
an
abstract
object
for
iterating
through
the
list.
*
The
list
implemntation
is
hidden
from
the
user
**/
typedef
struct
iter{
Node*
current;
}
ListIterator;
/**
Function
to
initialize
the
list
metadata
head
with
the
appropriate
function
pointers.
*@return
the
list
struct
*@param
printFunction
function
pointer
to
print
a
single
node
of
the
list
*@param
deleteFunction
function
pointer
to
delete
a
single
piece
of
data
from
the
list
*@param
compareFunction
function
pointer
to
compare
two
nodes
of
the
list
in
order
to
test
for
equality
or
order
**/
List
initializeList(char*
(*printFunction)(void*
toBePrinted),void
(*deleteFunction)(void*
toBeDeleted),int
(*compareFunction)(const
void*
first,const
void*
second));
/**Function
for
creating
a
node
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
data
should
be
of
same
size
of
void
pointer
on
the
users
machine
to
avoid
size
conflicts.
data
must
be
valid.
*data
must
be
cast
to
void
pointer
before
being
added.
*@post
data
is
valid
to
be
added
to
a
linked
list
*@return
On
success
returns
a
node
that
can
be
added
to
a
linked
list.
On
failure,
returns
NULL.
*@param
data
-
is
a
void
*
pointer
to
any
data
type.
Data
must
be
allocated
on
the
heap.
**/
Node*
initializeNode(void*
data);
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertFront(List*
list,
void*
toBeAdded);
/**Inserts
a
Node
at
the
back
of
a
linked
list.
*List
metadata
is
updated
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertBack(List*
list,
void*
toBeAdded);
/**
Clears
the
contents
linked
list,
freeing
all
memory
asspociated
with
these
contents.
*
uses
the
supplied
function
pointer
to
release
allocated
memory
for
the
data
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
List-type
dummy
node
**/
void
clearList(List*
list);
/**
Uses
the
comparison
function
pointer
to
place
the
element
in
the
*
appropriate
position
in
the
list.
*
should
be
used
as
the
only
insert
function
if
a
sorted
list
is
required.
*@pre
List
exists
and
has
memory
allocated
to
it.
Node
to
be
added
is
valid.
*@post
The
node
to
be
added
will
be
placed
immediately
before
or
after
the
first
occurrence
of
a
related
node
*@param
list
a
pointer
to
the
dummy
head
of
the
list
containing
function
pointers
for
delete
and
compare,
as
well
as
a
pointer
to
the
first
and
last
element
of
the
list.
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertSorted(List*
list,
void*
toBeAdded);
/**
Removes
data
from
from
the
list,
deletes
the
node
and
frees
the
memory,
*
changes
pointer
values
of
surrounding
nodes
to
maintain
list
structure.
*
returns
the
data
*
You
can
assume
that
the
list
contains
no
duplicates
*@pre
List
must
exist
and
have
memory
allocated
to
it
*@post
If
toBeDeleted
was
found,
the
node
associated
with
it
is
removed
from
the
list
and
freed.
*The
list
is
re-linked.
Otherwise
the
List
is
unchanged.
*@param
list
pointer
to
the
dummy
head
of
the
list
containing
deleteFunction
function
pointer
*@param
toBeDeleted
pointer
to
data
that
is
to
be
removed
from
the
list
*@return
on
success:
void
*
pointer
to
data
on
failure:
NULL
**/
void*
deleteDataFromList(List*
list,
void*
toBeDeleted);
/**Returns
a
pointer
to
the
data
at
the
front
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
head
of
the
list
**/
void*
getFromFront(List
list);
/**Returns
a
pointer
to
the
data
at
the
back
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
tail
of
the
list
**/
void*
getFromBack(List
list);
/**Returns
a
string
that
contains
a
string
representation
of
the
list
traversed
from
head
to
tail.
Utilize
the
list's
printData
function
pointer
to
create
the
string.
returned
string
must
be
freed
by
the
calling
function.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
Pointer
to
linked
list
dummy
head.
*@return
on
success:
char
*
to
string
representation
of
list
(must
be
freed
after
use).
on
failure:
NULL
**/
char*
toString(List
list);
/**
Function
for
creating
an
iterator
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
List
exists
and
is
valid
*@post
List
remains
unchanged.
The
iterator
has
been
allocated
and
points
to
the
head
of
the
list.
*@return
The
newly
created
iterator
object.
*@param
list
-
a
pointer
to
the
list
to
iterate
over.
**/
ListIterator
createIterator(List
list);
/**
Function
that
returns
the
next
element
of
the
list
through
the
iterator.
*
This
function
returns
the
data
at
head
of
the
list
the
first
time
it
is
called
after.
*
the
iterator
was
created.
Every
subsequent
call
returns
the
data
associated
with
the
next
element.
*
Returns
NULL
once
the
end
of
the
iterator
is
reached.
*@pre
List
exists
and
is
valid.
Iterator
exists
and
is
valid.
*@post
List
remains
unchanged.
The
iterator
points
to
the
next
element
on
the
list.
*@return
The
data
associated
with
the
list
element
that
the
iterator
pointed
to
when
the
function
was
called.
*@param
iter
-
an
iterator
to
a
list.
**/
void*
nextElement(ListIterator*
iter);
/**Returns
the
number
of
elements
in
the
list.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
-
the
list
struct.
*@return
on
success:
number
of
eleemnts
in
the
list
(0
or
more).
on
failure:
-1
(e.g.
list
not
initlized
correctly)
**/
int
getLength(List
list);
/**
Function
that
searches
for
an
element
in
the
list
using
a
comparator
function.
*
If
an
element
is
found,
a
pointer
to
the
data
of
that
element
is
returned
*
Returns
NULL
if
the
element
is
not
found.
*@pre
List
exists
and
is
valid.
Comparator
function
has
been
provided.
*@post
List
remains
unchanged.
*@return
The
data
associated
with
the
list
element
that
matches
the
search
criteria.
If
element
is
not
found,
return
NULL.
*@param
list
-
a
list
sruct
*@param
customCompare
-
a
pointer
to
comparator
fuction
for
customizing
the
search
*@param
searchRecord
-
a
pointer
to
search
data,
which
contains
seach
criteria
*Note:
while
the
arguments
of
compare()
and
searchRecord
are
all
void,
it
is
assumed
that
records
they
point
to
are
*
all
of
the
same
type
-
just
like
arguments
to
the
compare()
function
in
the
List
struct
**/
void*
findElement(List
list,
bool
(*customCompare)(const
void*
first,const
void*
second),
const
void*
searchRecord);
#endif
#ifndef
GEDCOMUTIL_H
#define
GEDCOMUTIL_H
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
"LinkedListAPI.h"
#include
"GEDCOMparser.h"
typedef
struct{
Individual
*
solo;
char
*
xref;
char
*
fams;
char
*
famc;
}FamilyLinker;
Field
*
otherFields(char
*
line);
char
*
genericMember(char
*
line);
void
printLinker(void
*
toBePrinted);
char
*
tagONLY(char
*
line);
Individual
*
linker(char
*
line,Family
*
fam,
List
list);
#endif
#include
"LinkedListAPI.h"
//#include
"GEDCOMparser.h"
#include
"assert.h"
/**
Function
to
initialize
the
list
metadata
head
to
the
appropriate
function
pointers.
Allocates
memory
to
the
struct.
*@return
pointer
to
the
list
head
*@param
printFunction
function
pointer
to
print
a
single
node
of
the
list
*@param
deleteFunction
function
pointer
to
delete
a
single
piece
of
data
from
the
list
*@param
compareFunction
function
pointer
to
compare
two
nodes
of
the
list
in
order
to
test
for
equality
or
order
**/
List
initializeList(char*
(*printFunction)(void*
toBePrinted),void
(*deleteFunction)(void*
toBeDeleted),int
(*compareFunction)(const
void*
first,const
void*
second)){
List
tmpList;
//Asserts
create
a
partial
function...
assert(printFunction
!=
NULL);
assert(deleteFunction
!=
NULL);
assert(compareFunction
!=
NULL);
tmpList.head
=
NULL;
tmpList.tail
=
NULL;
tmpList.deleteData
=
deleteFunction;
tmpList.compare
=
compareFunction;
tmpList.printData
=
printFunction;
return
tmpList;
}
/**
Deletes
the
entire
linked
list,
freeing
all
memory.
*
uses
the
supplied
function
pointer
to
release
allocated
memory
for
the
data
*
returns
NULL
on
success
or
the
head
of
the
list
on
failure.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
List-type
dummy
node
*@return
on
success:
NULL,
on
failure:
head
of
list
**/
void
clearList(List*
list){
if
(list
==
NULL){
return;
}
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
return;
}
Node*
tmp;
while
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
!=
NULL){
list->deleteData(list->head->data);
string start = 6
string start = 23
string start = 29
NUMBER OF arrows IN WORD list->deleteData(list->head->data); : 3
tmp
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
list->head->next;
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->next; : 2
free(tmp);
}
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
NULL;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
NULL;
}
/**Function
for
creating
a
node
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
data
should
be
of
same
size
of
void
pointer
on
the
users
machine
to
avoid
size
conflicts.
data
must
be
valid.
*data
must
be
cast
to
void
pointer
before
being
added.
*@post
data
is
valid
to
be
added
to
a
linked
list
*@return
On
success
returns
a
node
that
can
be
added
to
a
linked
list.
On
failure,
returns
NULL.
*@param
data
-
is
a
void
*
pointer
to
any
data
type.
Data
must
be
allocated
on
the
heap.
**/
Node*
initializeNode(void*
data){
Node*
tmpNode;
tmpNode
=
(Node*)malloc(sizeof(Node));
if
(tmpNode
==
NULL){
return
NULL;
}
tmpNode->data
string start = 9
NUMBER OF arrows IN WORD tmpNode->data : 1
=
data;
tmpNode->previous
string start = 9
NUMBER OF arrows IN WORD tmpNode->previous : 1
=
NULL;
tmpNode->next
string start = 9
NUMBER OF arrows IN WORD tmpNode->next : 1
=
NULL;
return
tmpNode;
}
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertBack(List*
list,
void*
toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
Node*
newNode
=
initializeNode(toBeAdded);
//char
*
check
=
printField(toBeAdded);
//printf("Inserting
Print:%s\n",
check);
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
}else{
newNode->previous
string start = 9
NUMBER OF arrows IN WORD newNode->previous : 1
=
list->tail;
string start = 6
NUMBER OF arrows IN WORD list->tail; : 1
list->tail->next
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->tail->next : 2
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
newNode;
}
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
=
getLength(*list);
}
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertFront(List*
list,
void*
toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
Node*
newNode
=
initializeNode(toBeAdded);
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
}else{
newNode->next
string start = 9
NUMBER OF arrows IN WORD newNode->next : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
list->head->previous
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->previous : 2
=
newNode;
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
}
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
=
getLength(*list);
}
/**Returns
a
pointer
to
the
data
at
the
front
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
head
of
the
list
**/
void*
getFromFront(List
list){
if
(list.head
==
NULL){
return
NULL;
}
return
list.head->data;
string start = 11
NUMBER OF arrows IN WORD list.head->data; : 1
}
/**Returns
a
pointer
to
the
data
at
the
back
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
tail
of
the
list
**/
void*
getFromBack(List
list){
if
(list.tail
==
NULL){
return
NULL;
}
return
list.tail->data;
string start = 11
NUMBER OF arrows IN WORD list.tail->data; : 1
}
void*
deleteDataFromList(List*
list,
void*
toBeDeleted){
if
(list
==
NULL
||
toBeDeleted
==
NULL){
return
NULL;
}
Node*
tmp
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
while(tmp
!=
NULL){
if
(list->compare(toBeDeleted,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeDeleted, : 1
tmp->data)
string start = 5
NUMBER OF arrows IN WORD tmp->data) : 1
==
0){
//Unlink
the
node
Node*
delNode
=
tmp;
if
(tmp->previous
string start = 6
NUMBER OF arrows IN WORD (tmp->previous : 1
!=
NULL){
tmp->previous->next
string start = 5
string start = 15
NUMBER OF arrows IN WORD tmp->previous->next : 2
=
delNode->next;
string start = 9
NUMBER OF arrows IN WORD delNode->next; : 1
}else{
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
delNode->next;
string start = 9
NUMBER OF arrows IN WORD delNode->next; : 1
}
if
(tmp->next
string start = 6
NUMBER OF arrows IN WORD (tmp->next : 1
!=
NULL){
tmp->next->previous
string start = 5
string start = 11
NUMBER OF arrows IN WORD tmp->next->previous : 2
=
delNode->previous;
string start = 9
NUMBER OF arrows IN WORD delNode->previous; : 1
}else{
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
delNode->previous;
string start = 9
NUMBER OF arrows IN WORD delNode->previous; : 1
}
void*
data
=
delNode->data;
string start = 9
NUMBER OF arrows IN WORD delNode->data; : 1
free(delNode);
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
=
getLength(*list);
return
data;
}else{
tmp
=
tmp->next;
string start = 5
NUMBER OF arrows IN WORD tmp->next; : 1
}
}
return
NULL;
}
/**
Uses
the
comparison
function
pointer
to
place
the
element
in
the
*
appropriate
position
in
the
list.
*
should
be
used
as
the
only
insert
function
if
a
sorted
list
is
required.
*@pre
List
exists
and
has
memory
allocated
to
it.
Node
to
be
added
is
valid.
*@post
The
node
to
be
added
will
be
placed
immediately
before
or
after
the
first
occurrence
of
a
related
node
*@param
list
a
pointer
to
the
dummy
head
of
the
list
containing
function
pointers
for
delete
and
compare,
as
well
as
a
pointer
to
the
first
and
last
element
of
the
list.
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertSorted(List
*list,
void
*toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL){
insertBack(list,
toBeAdded);
return;
}
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
list->head->data)
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->data) : 2
<=
0){
insertFront(list,
toBeAdded);
return;
}
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
list->tail->data)
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->tail->data) : 2
>
0){
insertBack(list,
toBeAdded);
return;
}
Node*
currNode
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
while
(currNode
!=
NULL){
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
currNode->data)
string start = 10
NUMBER OF arrows IN WORD currNode->data) : 1
<=
0){
char*
currDescr
=
list->printData(currNode->data);
string start = 6
string start = 26
NUMBER OF arrows IN WORD list->printData(currNode->data); : 2
char*
newDescr
=
list->printData(toBeAdded);
string start = 6
NUMBER OF arrows IN WORD list->printData(toBeAdded); : 1
printf("Inserting
%s
before
%s\n",
newDescr,
currDescr);
free(currDescr);
free(newDescr);
Node*
newNode
=
initializeNode(toBeAdded);
newNode->next
string start = 9
NUMBER OF arrows IN WORD newNode->next : 1
=
currNode;
newNode->previous
string start = 9
NUMBER OF arrows IN WORD newNode->previous : 1
=
currNode->previous;
string start = 10
NUMBER OF arrows IN WORD currNode->previous; : 1
currNode->previous->next
string start = 10
string start = 20
NUMBER OF arrows IN WORD currNode->previous->next : 2
=
newNode;
currNode->previous
string start = 10
NUMBER OF arrows IN WORD currNode->previous : 1
=
newNode;
return;
}
currNode
=
currNode->next;
string start = 10
NUMBER OF arrows IN WORD currNode->next; : 1
}
return;
}
/**Returns
a
string
that
contains
a
string
representation
of
the
list
traversed
from
head
to
tail.
Utilize
an
iterator
and
the
list's
printData
function
pointer
to
create
the
string.
returned
string
must
be
freed
by
the
calling
function.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
Pointer
to
linked
list
dummy
head.
*@return
on
success:
char
*
to
string
representation
of
list
(must
be
freed
after
use).
on
failure:
NULL
**/
char*
toString(List
list){
ListIterator
iter
=
createIterator(list);
char*
str;
str
=
(char*)malloc(sizeof(char));
strcpy(str,
"");
void*
elem;
while(
(elem
=
nextElement(&iter))
!=
NULL){
char*
currDescr
=
list.printData(elem);
int
newLen
=
strlen(str)+50+strlen(currDescr);
str
=
(char*)realloc(str,
newLen);
strcat(str,
"\n");
strcat(str,
currDescr);
free(currDescr);
}
return
str;
}
ListIterator
createIterator(List
list){
ListIterator
iter;
iter.current
=
list.head;
return
iter;
}
void*
nextElement(ListIterator*
iter){
Node*
tmp
=
iter->current;
string start = 6
NUMBER OF arrows IN WORD iter->current; : 1
if
(tmp
!=
NULL){
iter->current
string start = 6
NUMBER OF arrows IN WORD iter->current : 1
=
iter->current->next;
string start = 6
string start = 15
NUMBER OF arrows IN WORD iter->current->next; : 2
return
tmp->data;
string start = 5
NUMBER OF arrows IN WORD tmp->data; : 1
}else{
return
NULL;
}
}
int
getLength(List
list){
Node*
tempNode
=
list.head;
int
elementCounter
=
0;
if(list.head
==
NULL){
return
-1;
}
while(tempNode
!=
NULL){
elementCounter++;
tempNode
=
tempNode->next;
string start = 10
NUMBER OF arrows IN WORD tempNode->next; : 1
}
return
elementCounter;
}
void*
findElement(List
list,
bool
(*customCompare)(const
void*
first,const
void*
second),
const
void*
searchRecord){
Node*
tempNode
=
list.head;
if(list.head
==
NULL){
return
NULL;
}
while(tempNode
!=
NULL){
if(customCompare(tempNode->data,searchRecord)
string start = 27
NUMBER OF arrows IN WORD if(customCompare(tempNode->data,searchRecord) : 1
==
1){
return
tempNode->data;
string start = 10
NUMBER OF arrows IN WORD tempNode->data; : 1
}
tempNode
=
tempNode->next;
string start = 10
NUMBER OF arrows IN WORD tempNode->next; : 1
}
return
NULL;
}
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
<ctype.h>
#include
<string.h>
#include
"LinkedListAPI.h"
#include
"GEDCOMparser.h"
#include
"GEDCOMutilities.h"
Field
*
otherFields(char
*
line){
Field
*
testField
=
malloc(sizeof(Field));
const
char
delims[3]
=
"
\n";
char
*
tokens;
char
*
tag;
char
*
value
=
malloc(sizeof(char)
*
256);
strcpy(value,"");
int
counter
=
0;
tokens
=
strtok(line,delims);
while
(tokens
!=
NULL){
if(counter
==
1){
tag
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(tag,
tokens);
}
else{
strcat(value,
"
");
strcat(value,tokens);
//value
=
realloc(value,
sizeof(char)
*
((strlen(tokens)
+
strlen(value)
+
20)));
}
tokens
=
strtok(NULL,
delims);
counter++;
}
testField->tag
string start = 11
NUMBER OF arrows IN WORD testField->tag : 1
=
tag;
testField->value
string start = 11
NUMBER OF arrows IN WORD testField->value : 1
=
value;
return
testField;
}
char
*
genericMember(char
*
line){
const
char
delims[3]
=
"
\n";
char
*
tokens;
char
*
name
=
malloc(sizeof(char)
*
256);
strcpy(name,"");
int
counter
=
0;
tokens
=
strtok(line,delims);
//printf("CHECK\n");
while
(tokens
!=
NULL){
if(counter
>=
2){
strcat(name,tokens);
}
tokens
=
strtok(NULL,
delims);
counter++;
}
return
name;
}
char
*
tagONLY(char
*
line){
const
char
delims[3]
=
"
\n";
char
*
tokens;
char
*
name
=
malloc(sizeof(char)
*
256);
strcpy(name,"");
int
counter
=
0;
tokens
=
strtok(line,delims);
//printf("CHECK\n");
while
(tokens
!=
NULL){
if(counter
==
1){
strcat(name,tokens);
}
tokens
=
strtok(NULL,
delims);
counter++;
}
return
name;
}
void
printLinker(void
*
toBePrinted){
FamilyLinker
*
tempFL
=
((FamilyLinker
*)toBePrinted);
printf("LINKAGE!\n%s\n",
tempFL->xref);
string start = 8
NUMBER OF arrows IN WORD tempFL->xref); : 1
//printf("LINKAGE!\n%s
%s
%s\n",
tempFL->fams,
string start = 8
NUMBER OF arrows IN WORD tempFL->fams, : 1
tempFL->famc,
string start = 8
NUMBER OF arrows IN WORD tempFL->famc, : 1
tempFL->xref);
string start = 8
NUMBER OF arrows IN WORD tempFL->xref); : 1
//printf("LINKAGE
%s
%s
%s
%s\n",
tempFL->fams,
string start = 8
NUMBER OF arrows IN WORD tempFL->fams, : 1
tempFL->famc,
string start = 8
NUMBER OF arrows IN WORD tempFL->famc, : 1
tempFL->xref,printIndividual(tempFL->solo));
string start = 8
string start = 37
NUMBER OF arrows IN WORD tempFL->xref,printIndividual(tempFL->solo)); : 2
}
Individual
*
linker(char
*
line,
Family
*
fam,
List
list){
ListIterator
iter
=
createIterator(list);
/*char*
str;
str
=
(char*)malloc(sizeof(char));
strcpy(str,
"");
*/
void*
elem;
//Individual
*
tempIndi
=
((Individual
*)toBePrinted);
while(
(elem
=
nextElement(&iter))
!=
NULL){
if(strcmp(line,((FamilyLinker*)elem)->xref)
string start = 38
NUMBER OF arrows IN WORD if(strcmp(line,((FamilyLinker*)elem)->xref) : 1
==
0){
//printf("HELLO%s\n"
,((FamilyLinker*)elem)->xref);
string start = 24
NUMBER OF arrows IN WORD ,((FamilyLinker*)elem)->xref); : 1
insertBack(
&((FamilyLinker*)elem)->solo->families,
string start = 24
string start = 30
NUMBER OF arrows IN WORD &((FamilyLinker*)elem)->solo->families, : 2
fam);
//printIndividual(((FamilyLinker*)elem)->solo);
string start = 41
NUMBER OF arrows IN WORD //printIndividual(((FamilyLinker*)elem)->solo); : 1
return
((FamilyLinker*)elem)->solo;
string start = 23
NUMBER OF arrows IN WORD ((FamilyLinker*)elem)->solo; : 1
}
/*char*
currDescr
=
list.printData(elem);
int
newLen
=
strlen(str)+50+strlen(currDescr);
str
=
(char*)realloc(str,
newLen);
strcat(str,
"\n");
strcat(str,
currDescr);
free(currDescr);*/
}
return
NULL;
}
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
<ctype.h>
#include
<string.h>
#include
"LinkedListAPI.h"
#include
"GEDCOMparser.h"
#include
"GEDCOMutilities.h"
GEDCOMerror
createGEDCOM(char*
fileName,
GEDCOMobject**
obj){
FILE
*ptrFile;
char
*
extension;
if((extension
=
strrchr(fileName,
'.'))
!=
NULL){
//printf("%s\n",extension);
if(strcmp(extension,
".ged")
!=
0){
//printf("Not
a
.ged\n");
GEDCOMerror
testError;
testError.type
=
INV_FILE;
return
testError;
}
}
ptrFile
=
fopen(fileName,
"r");
if(ptrFile
==
NULL){
perror("ERROR");
exit(1);
}
char
readLine[50];
char
*line;
typedef
enum
recFlag
{HEADER,
SUBM,
FAM,
INDIV}
recordFlag;
recordFlag
rFlag;
Header
*
gedHeader
=
malloc(sizeof(Header));
gedHeader->otherFields
string start = 11
NUMBER OF arrows IN WORD gedHeader->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
Submitter
*
gedSub
=
malloc(sizeof(Submitter));
gedSub->otherFields
string start = 8
NUMBER OF arrows IN WORD gedSub->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
char
submTag[15];
while(fgets(readLine,
50,
ptrFile)){
readLine[strlen(readLine)
-
1]
=
'\0';
line
=
malloc(sizeof(char)
*
sizeof(readLine));
//line
=
malloc(sizeof(readLine));
strcpy(line,readLine);
/*
*
This
block
of
code
checks
for
level
0
*
*
*/
if(strstr(line,"HEAD")
!=
NULL
&&
strstr(line,"0")
!=
NULL){
printf("ITS
HERE\n");
rFlag
=
HEADER;
}
else
if(strstr(line,"SUBM")
!=
NULL
&&
strstr(line,"0")
!=
NULL){
printf("ITS
HERE\n");
rFlag
=
SUBM;
}
else
if(strstr(line,"FAM")
!=
NULL
&&
strstr(line,"0")
!=
NULL){
printf("ITS
HERE\n");
rFlag
=
FAM;
}
else
if(strstr(line,"INDI")
!=
NULL
&&
strstr(line,"0")
!=
NULL){
printf("ITS
HERE\n");
rFlag
=
INDIV;
}
printf("%s\n",
line);
/*
*
This
code
checks
which
type
of
record
we
are
filling
*/
//char
*
token;
//token
=
strtok(line,
"
");
/*********************************************************************************************************************************/
if(rFlag
==
HEADER){
int
versionFlag;
if(strstr(line,"SOUR")
!=
NULL){
const
char
delims[3]
=
"
\n";
char
*
tokens;
int
flag
=
0;
char
*
source;
tokens
=
strtok(line,delims);
while
(tokens
!=
NULL){
if(flag
==
1){
//printf("WANT\n");
source
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(source,tokens);
}
if(strcmp(tokens,"SOUR")
==
0){
flag
=
1;
//printf("MATCH\n");
}
//printf(
"%s\n",
tokens);
tokens
=
strtok(NULL,
delims);
}
//printf("%s\n",
source);
strcpy(gedHeader->source,source);
string start = 18
NUMBER OF arrows IN WORD strcpy(gedHeader->source,source); : 1
printf("src\n");
}
else
if(strstr(line,"HEAD")
!=
NULL){
}
else
if(strstr(line,"GEDC")
!=
NULL){
versionFlag
=
1;
}
else
if(strstr(line,"VERS")
!=
NULL
&&
versionFlag
==
1){
printf("GED\n");
versionFlag
=
0;
const
char
delims[3]
=
"
\n";
char
*
tokens;
int
flag
=
0;
char
*
source;
tokens
=
strtok(line,delims);
while
(tokens
!=
NULL){
if(flag
==
1){
//printf("WANT\n");
source
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(source,tokens);
}
if(strcmp(tokens,"VERS")
==
0){
flag
=
1;
}
//printf(
"%s\n",
tokens);
tokens
=
strtok(NULL,
delims);
}
//printf("%s\n",
source);
gedHeader->gedcVersion
string start = 11
NUMBER OF arrows IN WORD gedHeader->gedcVersion : 1
=
atof(source);
printf("%f\n",
atof(source));
}
else
if(strstr(line,"CHAR")
!=
NULL){
if(strstr(line,"ANSEL")){
printf("FOUND\n");
gedHeader->encoding
string start = 11
NUMBER OF arrows IN WORD gedHeader->encoding : 1
=
ANSEL;
}
else
if(strstr(line,"UTF8")){
gedHeader->encoding=
string start = 11
NUMBER OF arrows IN WORD gedHeader->encoding= : 1
UTF8;
}
else
if(strstr(line,"UNICODE")){
gedHeader->encoding
string start = 11
NUMBER OF arrows IN WORD gedHeader->encoding : 1
=
UNICODE;
}
else
if(strstr(line,"ASCII")){
gedHeader->encoding
string start = 11
NUMBER OF arrows IN WORD gedHeader->encoding : 1
=
ASCII;
}
else{
printf("error\n");
}
printf("ch\n");
}
else
if(strstr(line,"SUBM")
!=
NULL){
const
char
delims[3]
=
"
\n";
char
*
tokens;
int
counter
=
0;
tokens
=
strtok(line,delims);
while
(tokens
!=
NULL){
if(counter
==
2){
strcpy(submTag,
tokens);
}
tokens
=
strtok(NULL,
delims);
counter++;
}
printf("%s\n",
submTag);
}
else{
Field
*
testField
=
otherFields(line);
/*printf("other\n");
Field
*
testField
=
malloc(sizeof(Field));
const
char
delims[3]
=
"
\n";
char
*
tokens;
char
*
tag;
char
*
value
=
malloc(sizeof(char)
*
1);
int
counter
=
0;
tokens
=
strtok(line,delims);
while
(tokens
!=
NULL){
if(counter
==
0){
}
else
if(counter
==
1){
tag
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(tag,
tokens);
}
else{
strcat(value,tokens);
value
=
realloc(value,
sizeof(char)
*
((strlen(tokens)
+
strlen(value)
+
1)));
}
tokens
=
strtok(NULL,
delims);
counter++;
}
printf("Values:
%s
%s\n",
tag,
value);
testField->tag
string start = 11
NUMBER OF arrows IN WORD testField->tag : 1
=
tag;
testField->value
string start = 11
NUMBER OF arrows IN WORD testField->value : 1
=
value;*/
printf("TESTING
PRINT
FIELD:
");
char
*
test
=
printField(testField);
printf("%s\n",
test);
insertBack(&gedHeader->otherFields,testField);
string start = 23
NUMBER OF arrows IN WORD insertBack(&gedHeader->otherFields,testField); : 1
printf("TESTING
PRINT
HEAD:
");
printf("%s\n",
printField(gedHeader->otherFields.head->data));
string start = 22
string start = 40
NUMBER OF arrows IN WORD printField(gedHeader->otherFields.head->data)); : 2
//gedHeader->gedcVersion
string start = 13
NUMBER OF arrows IN WORD //gedHeader->gedcVersion : 1
=
atof(source);
//printf("%f\n",
atof(source));
}
}
/*********************************************************************************************************************************/
/*********************************************************************************************************************************/
else
if(rFlag
==
SUBM){
int
correctSUBM;
if(strstr(line,submTag)
!=
NULL){
correctSUBM
=
1;
}
if(correctSUBM
==
1
&&
line[0]
==
'1'){
if(strstr(line,"NAME")
!=
NULL){
const
char
delims[3]
=
"
\n";
char
*
tokens;
char
*
name
=
malloc(sizeof(char)
*
1);
int
counter
=
0;
tokens
=
strtok(line,delims);
//printf("CHECK\n");
while
(tokens
!=
NULL){
if(counter
>=
2){
strcat(name,tokens);
name
=
realloc(name,
sizeof(char)
*
((strlen(tokens)
+
strlen(name)
+
1)));
}
tokens
=
strtok(NULL,
delims);
counter++;
}
strcpy(gedSub->submitterName,
string start = 15
NUMBER OF arrows IN WORD strcpy(gedSub->submitterName, : 1
name);
}
else{
Field
*
testField
=
otherFields(line);
insertBack(&gedSub->otherFields,testField);
string start = 20
NUMBER OF arrows IN WORD insertBack(&gedSub->otherFields,testField); : 1
}
}
}
/******************************************************************************************************************************
*
*
*****************************************************************************************************************************/
else
if(rFlag
==
FAM){
//printf("F\n");
}
/*****************************************************************************************************************************
*
*
*****************************************************************************************************************************/
//BIRT
CHR
DEAT
CREM
ADOP
BAPM
BARM
BASM
BLES
CHRA
CONF
FCOM
ORDN
NATU
EMIG
IMMI
CENS
PROB
WILL
GRAD
RETI
EVEN
else
if(rFlag
==
INDIV){
//printf("Indiv\n");
char
individualEvents[22][5]
=
{
"BIRT"
,"CHR"
,"DEAT"
,"CREM"
,"ADOP"
,"BAPM"
,"BARM"
,"BASM"
,"BLES"
,"CHRA"
,"CONF"
,"FCOM"
,"ORDN"
,"NATU"
,"EMIG"
,"IMMI"
,"CENS"
,"PROB"
,"WILL"
,"GRAD"
,"RETI"
,"EVEN"};
char
linecopy[256];
strcpy(linecopy,
line);
const
char
delimcopy[3]
=
"
\n";
char
*
tokencopy;
int
tokenCounter
=
0;
int
eFlag;
char
*
type
=
malloc(sizeof(char)
*
5);
char
*
date;
char
*
place;
int
createEventChecker;
if(eFlag
==
1
&&
(line[0]
==
'1'
||
line[0]
==
'0')){
eFlag
=
0;
printf("CHANGE\n");
}
tokencopy
=
strtok(linecopy,delimcopy);
while
(tokencopy
!=
NULL){
//printf("%s\n",
tokencopy);
if(tokenCounter
==
1){
for(int
i
=
0;
i
<
22;
i++){
if(strcmp(individualEvents[i],tokencopy)
==
0){
eFlag
=
1;
printf("EVENT
FOUND\n");
strcpy(type,
tokencopy);
}
}
}
tokenCounter++;
tokencopy
=
strtok(NULL,
delimcopy);
}
printf("%d\n",
eFlag);
if(eFlag
==
1){
Event
*
testEvent
=
malloc(sizeof(Event));
strcpy(testEvent->type,type);
string start = 18
NUMBER OF arrows IN WORD strcpy(testEvent->type,type); : 1
char
readLN[150];
char
*
line2;
while(){
fgets(readLN,
50,
ptrFile)
readLN[strlen(readLN)
-
1]
=
'\0';
line2
=
malloc(sizeof(char)
*
sizeof(readLN));
//line
=
malloc(sizeof(readLine));
strcpy(line2,readLN);
/*if(line[0]
==
'1'){
Event
*
testEvent
=
malloc(sizeof(Event));
}*/
if(strstr(line2,
"DATE")
!=
NULL){
printf("DATE\n");
date
=
genericMember(line2);
printf("DATE
PARSED
%s\n",
date);
}
else
if(strstr(line,
"PLAC")
!=
NULL){
printf("PLAC\n");
place
=
genericMember(line2);
printf("PLACE
PARSED
%s\n",
place);
}
else{
Field
*
testField
=
otherFields(line2);
}
}
}
if(strstr(line,"NAME")
!=
NULL
&&
strstr(line,"1")
!=
NULL){
printf("NAME\n");
//printf("other\n");
//Field
*
testField
=
malloc(sizeof(Field));
const
char
delims[4]
=
"
/\n";
char
*
tokens;
char
*
first;
char
*
last;
int
counter
=
0;
tokens
=
strtok(line,delims);
printf("test\n");
while
(tokens
!=
NULL){
if(counter
==
0){
}
else
if(counter
==
2){
first
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(first,
tokens);
}
else
if(counter
==
3){
last
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(last,tokens);
}
tokens
=
strtok(NULL,
delims);
counter++;
}
printf("%s
%s\n",
first,
last);
}
/*
else
if(eFlag
==
0){
Field
*
testField
=
malloc(sizeof(Field));
const
char
delims[3]
=
"
\n";
char
*
tokens;
char
*
tag;
char
*
value
=
malloc(sizeof(char)
*
1);
int
counter
=
0;
tokens
=
strtok(line,delims);
while
(tokens
!=
NULL){
if(counter
==
0){
}
else
if(counter
==
1){
tag
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(tag,
tokens);
}
else{
strcat(value,tokens);
value
=
realloc(value,
sizeof(char)
*
((strlen(tokens)
+
strlen(value)
+
1)));
}
tokens
=
strtok(NULL,
delims);
counter++;
}
printf("Values:
%s
%s\n",
tag,
value);
testField->tag
string start = 11
NUMBER OF arrows IN WORD testField->tag : 1
=
tag;
testField->value
string start = 11
NUMBER OF arrows IN WORD testField->value : 1
=
value;
}*/
/*
const
char
delims[4]
=
"
/\n";
char
*
tokens;
char
*
evenTag;
char
*
value;
int
counter
=
0;
int
eventFlag;
tokens
=
strtok(line,delims);
while
(tokens
!=
NULL){
if(counter
==
1){
evenTag
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(evenTag,
tokens);
for(int
i
=
0;
i
<
22;
i++){
if(strcmp(individualEvents[i],tokens)
==
0){
eventFlag
=
1;
printf("EVENT
FOUND\n");
}
}
}
tokens
=
strtok(NULL,
delims);
counter++;
}*/
}
}
fclose(ptrFile);
GEDCOMerror
testCom;
testCom.type
=
OK;
/*char
*
test
=
toString(gedHeader->otherFields);
string start = 20
NUMBER OF arrows IN WORD toString(gedHeader->otherFields); : 1
printf("%s\n",
test);
char
*
test2
=
toString(gedSub->otherFields);
string start = 17
NUMBER OF arrows IN WORD toString(gedSub->otherFields); : 1
printf("%s\n",
test2);*/
return
testCom;
}
char*
printError(GEDCOMerror
err){
char
*
errorMessage;
if(err.type
==
INV_FILE){
errorMessage
=
malloc(sizeof(char)
*
13);
strcpy(errorMessage,
"Invalid
File");
return
errorMessage;
}
if(err.type
==
OK){
errorMessage
=
malloc(sizeof(char)
*
3);
strcpy(errorMessage,
"OK");
return
errorMessage;
}
return
NULL;
}
void
deleteField(void*
toBeDeleted){
}
int
compareFields(const
void*
first,const
void*
second){
return
0;
}
char*
printField(void*
toBePrinted){
Field
*
tempField
=
((Field
*)toBePrinted);
char
*
returnString
=
malloc(sizeof(char)
*
(strlen(tempField->tag)
string start = 19
NUMBER OF arrows IN WORD (strlen(tempField->tag) : 1
+
strlen(tempField->value)
string start = 18
NUMBER OF arrows IN WORD strlen(tempField->value) : 1
+
30));
strcpy(returnString,
"");
strcat(returnString,
"Tag:
");
strcat(returnString,
tempField->tag);
string start = 11
NUMBER OF arrows IN WORD tempField->tag); : 1
strcat(returnString,
"
+
Value:
");
strcat(returnString,
tempField->value);
string start = 11
NUMBER OF arrows IN WORD tempField->value); : 1
return
returnString;
}
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
"LinkedListAPI.h"
#include
"GEDCOMparser.h"
int
main(int
argc,
char**
argv){
printf("Hello
Angel\n");
char
*
fileName
=
argv[1];
printf("%s\n",fileName);
GEDCOMobject
**testObject
=
malloc(sizeof(GEDCOMobject));
GEDCOMerror
testError;
testError
=
createGEDCOM(fileName,
testObject);
testError.type
=
OK;
testError.line
=
22;
printf("%s\n",printError(testError));
testError.type
=
INV_FILE;
testError.line
=
22;
printf("%s\n",printError(testError));
testError.type
=
INV_GEDCOM;
testError.line
=
22;
printf("%s\n",printError(testError));
testError.type
=
INV_HEADER;
testError.line
=
22;
printf("%s\n",printError(testError));
testError.type
=
INV_RECORD;
testError.line
=
22;
printf("%s\n",printError(testError));
testError.type
=
OTHER_ERROR;
testError.line
=
22;
printf("%s\n",printError(testError));
//printf("%s\n",printError(testError));
//printf("%s\n",
printGEDCOM(*testObject));
free(testObject);
return
0;
}
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
<ctype.h>
#include
<string.h>
#include
"LinkedListAPI.h"
#include
"GEDCOMparser.h"
#include
"GEDCOMutilities.h"
GEDCOMerror
createGEDCOM(char*
fileName,
GEDCOMobject**
obj){
FILE
*ptrFile;
int
trailerFlag
=
0;
char
*
extension;
*obj
=
malloc(sizeof(GEDCOMobject));
(*obj)->families
string start = 8
NUMBER OF arrows IN WORD (*obj)->families : 1
=
initializeList(&printIndividual,
&deleteIndividual,
&compareIndividuals);
(*obj)->individuals
string start = 8
NUMBER OF arrows IN WORD (*obj)->individuals : 1
=
initializeList(&printIndividual,
&deleteIndividual,
&compareIndividuals);
if((extension
=
strrchr(fileName,
'.'))
!=
NULL){
if(strcmp(extension,
".ged")
!=
0){
GEDCOMerror
testError;
testError.type
=
INV_FILE;
return
testError;
}
}
ptrFile
=
fopen(fileName,
"r");
if(ptrFile
==
NULL){
perror("ERROR");
exit(1);
}
char
readLine[50];
char
*line;
int
lineCounter
=
0;
typedef
enum
recFlag
{HEADER,
SUBM,
FAM,
INDIV}
recordFlag;
recordFlag
rFlag;
Header
*
gedHeader
=
malloc(sizeof(Header));
gedHeader->otherFields
string start = 11
NUMBER OF arrows IN WORD gedHeader->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
Submitter
*
gedSub
=
malloc(sizeof(Submitter));
gedSub->otherFields
string start = 8
NUMBER OF arrows IN WORD gedSub->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
char
submTag[15];
List
famLinkList
=
initializeList(&printIndividual,
&deleteIndividual,
&compareIndividuals);
while(fgets(readLine,
50,
ptrFile)){
if(readLine[strlen(readLine)-1]
==
'\n'){
readLine[strlen(readLine)
-
1]
=
'\0';
}
line
=
malloc(sizeof(char)
*
sizeof(readLine));
//line
=
malloc(sizeof(readLine));
strcpy(line,readLine);
printf("%s\n",line);
if(lineCounter
==
0
&&
strcmp(line,
"0
HEAD\r")
==
0){
GEDCOMerror
testError;
printf("HELLO\n");
testError.type
=
INV_GEDCOM;
testError.line
=
-1;
return
testError;
}
/*
*
This
block
of
code
checks
for
level
0
*
*
*/
if(strstr(line,"HEAD")
!=
NULL
&&
strstr(line,"0")
!=
NULL){
printf("ITS
HERE\n");
rFlag
=
HEADER;
}
else
if(strstr(line,"SUBM")
!=
NULL
&&
strstr(line,"0")
!=
NULL){
printf("ITS
HERE\n");
rFlag
=
SUBM;
}
else
if(strstr(line,"FAM")
!=
NULL
&&
strstr(line,"0")
!=
NULL){
printf("ITS
HERE\n");
rFlag
=
FAM;
}
else
if(strstr(line,"INDI")
!=
NULL
&&
strstr(line,"0")
!=
NULL){
printf("ITS
HERE\n");
rFlag
=
INDIV;
}
printf("%s\n",
line);
/*
*
This
code
checks
which
type
of
record
we
are
filling
*/
//char
*
token;
//token
=
strtok(line,
"
");
/*********************************************************************************************************************************/
/*********************************************************************************************************************************/
if(rFlag
==
HEADER){
int
versionFlag;
if(strstr(line,"SOUR")
!=
NULL){
const
char
delims[3]
=
"
\n";
char
*
tokens;
int
flag
=
0;
char
*
source;
tokens
=
strtok(line,delims);
while
(tokens
!=
NULL){
if(flag
==
1){
//printf("WANT\n");
source
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(source,tokens);
}
if(strcmp(tokens,"SOUR")
==
0){
flag
=
1;
//printf("MATCH\n");
}
//printf(
"%s\n",
tokens);
tokens
=
strtok(NULL,
delims);
}
//printf("%s\n",
source);
strcpy(gedHeader->source,source);
string start = 18
NUMBER OF arrows IN WORD strcpy(gedHeader->source,source); : 1
printf("src\n");
}
else
if(strstr(line,"HEAD")
!=
NULL){
}
else
if(strstr(line,"GEDC")
!=
NULL){
versionFlag
=
1;
}
else
if(strstr(line,"VERS")
!=
NULL
&&
versionFlag
==
1){
printf("GED\n");
versionFlag
=
0;
const
char
delims[3]
=
"
\n";
char
*
tokens;
int
flag
=
0;
char
*
source;
tokens
=
strtok(line,delims);
while
(tokens
!=
NULL){
if(flag
==
1){
source
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(source,tokens);
}
if(strcmp(tokens,"VERS")
==
0){
flag
=
1;
}
tokens
=
strtok(NULL,
delims);
}
gedHeader->gedcVersion
string start = 11
NUMBER OF arrows IN WORD gedHeader->gedcVersion : 1
=
atof(source);
printf("%f\n",
atof(source));
}
else
if(strstr(line,"CHAR")
!=
NULL){
if(strstr(line,"ANSEL")){
printf("FOUND\n");
gedHeader->encoding
string start = 11
NUMBER OF arrows IN WORD gedHeader->encoding : 1
=
ANSEL;
}
else
if(strstr(line,"UTF8")){
gedHeader->encoding
string start = 11
NUMBER OF arrows IN WORD gedHeader->encoding : 1
=
UTF8;
}
else
if(strstr(line,"UNICODE")){
gedHeader->encoding
string start = 11
NUMBER OF arrows IN WORD gedHeader->encoding : 1
=
UNICODE;
}
else
if(strstr(line,"ASCII")){
gedHeader->encoding
string start = 11
NUMBER OF arrows IN WORD gedHeader->encoding : 1
=
ASCII;
}
else{
printf("error\n");
}
printf("ch\n");
}
else
if(strstr(line,"SUBM")
!=
NULL){
const
char
delims[3]
=
"
\n";
char
*
tokens;
int
counter
=
0;
tokens
=
strtok(line,delims);
while
(tokens
!=
NULL){
if(counter
==
2){
strcpy(submTag,
tokens);
}
tokens
=
strtok(NULL,
delims);
counter++;
}
printf("%s\n",
submTag);
}
else{
Field
*
testField
=
otherFields(line);
printf("TESTING
PRINT
FIELD:
");
char
*
test
=
printField(testField);
printf("%s\n",
test);
insertBack(&gedHeader->otherFields,testField);
string start = 23
NUMBER OF arrows IN WORD insertBack(&gedHeader->otherFields,testField); : 1
//printf("TESTING
PRINT
HEAD:
");
printf("%s\n",
printField(gedHeader->otherFields.head->data));
string start = 22
string start = 40
NUMBER OF arrows IN WORD printField(gedHeader->otherFields.head->data)); : 2
//gedHeader->gedcVersion
string start = 13
NUMBER OF arrows IN WORD //gedHeader->gedcVersion : 1
=
atof(source);
//printf("%f\n",
atof(source));
}
}
/*********************************************************************************************************************************/
/*********************************************************************************************************************************/
else
if(rFlag
==
SUBM){
int
correctSUBM;
if(strstr(line,submTag)
!=
NULL){
correctSUBM
=
1;
}
if(correctSUBM
==
1
&&
line[0]
==
'1'){
if(strstr(line,"NAME")
!=
NULL){
const
char
delims[3]
=
"
\n";
char
*
tokens;
char
*
name
=
malloc(sizeof(char)
*
256);
int
counter
=
0;
tokens
=
strtok(line,delims);
//printf("CHECK\n");
while
(tokens
!=
NULL){
if(counter
>=
2){
strcat(name,tokens);
}
tokens
=
strtok(NULL,
delims);
counter++;
}
strcpy(gedSub->submitterName,
string start = 15
NUMBER OF arrows IN WORD strcpy(gedSub->submitterName, : 1
name);
}
else{
Field
*
testField
=
otherFields(line);
insertBack(&gedSub->otherFields,testField);
string start = 20
NUMBER OF arrows IN WORD insertBack(&gedSub->otherFields,testField); : 1
}
}
}
/******************************************************************************************************************************
*
*
*****************************************************************************************************************************/
else
if(rFlag
==
FAM){
//printf("F\n");
}
/*****************************************************************************************************************************
*
*
*****************************************************************************************************************************/
//BIRT
CHR
DEAT
CREM
ADOP
BAPM
BARM
BASM
BLES
CHRA
CONF
FCOM
ORDN
NATU
EMIG
IMMI
CENS
PROB
WILL
GRAD
RETI
EVEN
else
if(rFlag
==
INDIV){
//printf("Indiv\n");
Individual
*
testIndi
=
malloc(sizeof(Individual));
testIndi->events
string start = 10
NUMBER OF arrows IN WORD testIndi->events : 1
=
initializeList(&printEvent,
&deleteEvent,
&compareEvents);
testIndi->otherFields
string start = 10
NUMBER OF arrows IN WORD testIndi->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
char
readIND[150];
char
*
fs;
char
*
fc;
char
*
xref
=
tagONLY(line);
//printf("XREF%s\n",
xref);
//char
*
lineIND;
do{
fgets(readIND,
50,
ptrFile);
readIND[strlen(readIND)
-
1]
=
'\0';
line
=
malloc(sizeof(char)
*
sizeof(readIND));
strcpy(line,readIND);
char
individualEvents[22][5]
=
{
"BIRT"
,"CHR"
,"DEAT"
,"CREM"
,"ADOP"
,"BAPM"
,"BARM"
,"BASM"
,"BLES"
,"CHRA"
,"CONF"
,"FCOM"
,"ORDN"
,"NATU"
,"EMIG"
,"IMMI"
,"CENS"
,"PROB"
,"WILL"
,"GRAD"
,"RETI"
,"EVEN"};
char
linecopy[256];
strcpy(linecopy,
line);
const
char
delimcopy[3]
=
"
\n";
char
*
tokencopy;
int
tokenCounter
=
0;
int
eFlag;
//CHECK
char
*
type;
char
*
date;
char
*
place;
tokencopy
=
strtok(linecopy,delimcopy);
while
(tokencopy
!=
NULL){
if(tokenCounter
==
1){
for(int
i
=
0;
i
<
22;
i++){
if(strcmp(individualEvents[i],tokencopy)
==
0){
eFlag
=
1;
printf("EVENT
FOUND\n");
type
=
malloc(sizeof(tokencopy)
+
1);
strcpy(type,
tokencopy);
}
}
}
tokenCounter++;
tokencopy
=
strtok(NULL,
delimcopy);
}
//printf("F%d\n",
eFlag);
if(eFlag
==
1){
Event
*
testEvent
=
malloc(sizeof(Event));
testEvent->otherFields
string start = 11
NUMBER OF arrows IN WORD testEvent->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
strcpy(testEvent->type,type);
string start = 18
NUMBER OF arrows IN WORD strcpy(testEvent->type,type); : 1
char
readLN[150];
char
*
line2;
do{
fgets(readLN,
50,
ptrFile);
readLN[strlen(readLN)
-
1]
=
'\0';
line2
=
malloc(sizeof(char)
*
sizeof(readLN));
strcpy(line2,readLN);
if(strstr(line2,
"DATE")
!=
NULL){
printf("DATE\n");
date
=
genericMember(line2);
testEvent->date
string start = 11
NUMBER OF arrows IN WORD testEvent->date : 1
=
date;
printf("DATE
PARSED
%s\n",
date);
}
else
if(strstr(line2,
"PLAC")
!=
NULL){
printf("PLAC\n");
place
=
genericMember(line2);
testEvent->place
string start = 11
NUMBER OF arrows IN WORD testEvent->place : 1
=
place;
printf("PLACE
PARSED
%s\n",
place);
}
else
if(line2[0]
==
'1'
||
line2[0]
==
'0'){
int
length
=
strlen(line2)
+
1;
printf("%d\n",
length);
fseek(ptrFile,
-length
,SEEK_CUR);
printf("HELLO\n");
}
else{
printf("OTHER
FIELDS");
Field
*
testField
=
otherFields(line2);
insertBack(&testEvent->otherFields,testField);
string start = 23
NUMBER OF arrows IN WORD insertBack(&testEvent->otherFields,testField); : 1
}
printf("LINE
2
%s\n",
readLN);
}while(readLN[0]
==
'2');
printf("Finish
Event:
");
insertBack(&testIndi->events,testEvent);
string start = 22
NUMBER OF arrows IN WORD insertBack(&testIndi->events,testEvent); : 1
//char
*
eTest
=
printEvent(testEvent);
//printf("%s\n",
printEvent(testEvent));
eFlag
=
0;
}
else
if(strstr(line,"NAME")
!=
NULL
&&
readIND[0]
==
'1'){
printf("NAME\n");
const
char
delims[4]
=
"
/\n";
char
*
tokens;
char
*
first;
char
*
last;
int
counter
=
0;
tokens
=
strtok(line,delims);
printf("test\n");
while
(tokens
!=
NULL){
if(counter
==
0){
}
else
if(counter
==
2){
first
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(first,
tokens);
}
else
if(counter
==
3){
last
=
malloc(sizeof(char)
*
(strlen(tokens)
+
1));
strcpy(last,tokens);
}
tokens
=
strtok(NULL,
delims);
counter++;
}
testIndi->givenName
string start = 10
NUMBER OF arrows IN WORD testIndi->givenName : 1
=
first;
testIndi->surname
string start = 10
NUMBER OF arrows IN WORD testIndi->surname : 1
=
last;
printf("%s
%s\n",
first,
last);
}
else
if(readIND[0]
==
'0'){
int
length
=
strlen(line)
+
1;
printf("%d\n",
length);
fseek(ptrFile,
-length
,SEEK_CUR);
printf("HELLO\n"
);
}
else
if(strstr(line,"FAMS")
!=
NULL){
fs
=
genericMember(line);
printf("FS
%s\n",
fs);
}
else
if(strstr(line,"FAMC")
!=
NULL){
fc
=
genericMember(line);
printf("FC
%s\n",
fc);
}
else
if(eFlag
==
0){
printf("OTHERFIELDS\n");
printf("%s\n",
line);
Field
*
tf
=
malloc(sizeof(Field));
tf->value
string start = 4
NUMBER OF arrows IN WORD tf->value : 1
=
line;
tf->tag
string start = 4
NUMBER OF arrows IN WORD tf->tag : 1
=
line;
insertBack(&testIndi->otherFields,tf);
string start = 22
NUMBER OF arrows IN WORD insertBack(&testIndi->otherFields,tf); : 1
}
//printf("READIND
%s\n",
readIND);
}while(readIND[0]
!=
'0');
printf("EXIT
INDI:\n");
insertBack(&(*obj)->individuals,
string start = 20
NUMBER OF arrows IN WORD insertBack(&(*obj)->individuals, : 1
testIndi);
FamilyLinker
*
famLink
=
malloc(sizeof(FamilyLinker));
famLink->solo
string start = 9
NUMBER OF arrows IN WORD famLink->solo : 1
=
testIndi;
if(fc
==
NULL){
fc
=
malloc(sizeof(char)
*
1);
strcpy(fc,"\0");
}
if(fs
==
NULL){
fc
=
malloc(sizeof(char)
*
1);
strcpy(fc,"\0");
}
famLink->solo
string start = 9
NUMBER OF arrows IN WORD famLink->solo : 1
=
testIndi;
famLink->fams
string start = 9
NUMBER OF arrows IN WORD famLink->fams : 1
=
fs;
famLink->famc
string start = 9
NUMBER OF arrows IN WORD famLink->famc : 1
=
fc;
famLink->xref
string start = 9
NUMBER OF arrows IN WORD famLink->xref : 1
=
xref;
insertBack(&famLinkList,famLink);
printLinker(famLink);
fs
=
NULL;
fc
=
NULL;
//printf("%s\n",
printIndividual(testIndi));
}//
//printf("%s\n",
line);
if(strstr(line,
"TRLR")
!=
NULL){
trailerFlag
=
1;
}
/*****************************************************************************************************************************
*
*
*****************************************************************************************************************************/
}
gedHeader->submitter
string start = 11
NUMBER OF arrows IN WORD gedHeader->submitter : 1
=
gedSub;
fseek(ptrFile,
0,
SEEK_SET);
//int
famFlag
=
0;
while(fgets(readLine,
50,
ptrFile)){
if(readLine[strlen(readLine)-1]
==
'\n'){
readLine[strlen(readLine)
-
1]
=
'\0';
}
line
=
malloc(sizeof(char)
*
sizeof(readLine));
strcpy(line,readLine);
if(strstr(line,"FAM")
!=
NULL
&&
strstr(line,"0")
!=
NULL){
printf("ITS
HERE\n");
//famFlag
=
1;
Family
*
fam
=
malloc(sizeof(Family));
fam->children
string start = 5
NUMBER OF arrows IN WORD fam->children : 1
=
initializeList(&printIndividual,&deleteIndividual,&compareIndividuals);
fam->events
string start = 5
NUMBER OF arrows IN WORD fam->events : 1
=
initializeList(&printEvent,&deleteEvent,&compareEvents);
fam->children
string start = 5
NUMBER OF arrows IN WORD fam->children : 1
=
initializeList(&printField,&deleteField,&compareFields);
char
famEvents[10][5]
=
{
"ANUL"
,"CENS"
,"DIV"
,"DIVF","ENGA","MARB","MARC","MARR","MARL","MARS"
};
do{
printf("Fam
%s\n",
line);
char
linecopy[256];
strcpy(linecopy,
line);
const
char
delimcopy[3]
=
"
\n";
char
*
tokencopy;
int
tokenCounter
=
0;
int
eFlag;
char
*
type;
char
*
date;
char
*
place;
tokencopy
=
strtok(linecopy,delimcopy);
while
(tokencopy
!=
NULL){
if(tokenCounter
==
1){
for(int
i
=
0;
i
<
22;
i++){
if(strcmp(famEvents[i],tokencopy)
==
0){
eFlag
=
1;
printf("EVENT
FOUND\n");
type
=
malloc(sizeof(tokencopy)
+
1);
strcpy(type,
tokencopy);
}
}
}
tokenCounter++;
tokencopy
=
strtok(NULL,
delimcopy);
}
fgets(readLine,
50,
ptrFile);
if(readLine[strlen(readLine)-1]
==
'\n'){
readLine[strlen(readLine)
-
1]
=
'\0';
}
if(eFlag
==
1){
Event
*
testEvent
=
malloc(sizeof(Event));
testEvent->otherFields
string start = 11
NUMBER OF arrows IN WORD testEvent->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
strcpy(testEvent->type,type);
string start = 18
NUMBER OF arrows IN WORD strcpy(testEvent->type,type); : 1
char
readLN[150];
char
*
line2;
do{
fgets(readLN,
50,
ptrFile);
readLN[strlen(readLN)
-
1]
=
'\0';
line2
=
malloc(sizeof(char)
*
sizeof(readLN));
strcpy(line2,readLN);
if(strstr(line2,
"DATE")
!=
NULL){
printf("DATE\n");
date
=
genericMember(line2);
testEvent->date
string start = 11
NUMBER OF arrows IN WORD testEvent->date : 1
=
date;
printf("DATE
PARSED
%s\n",
date);
}
else
if(strstr(line2,
"PLAC")
!=
NULL){
printf("PLAC\n");
place
=
genericMember(line2);
testEvent->place
string start = 11
NUMBER OF arrows IN WORD testEvent->place : 1
=
place;
printf("PLACE
PARSED
%s\n",
place);
}
else
if(line2[0]
==
'1'
||
line2[0]
==
'0'){
int
length
=
strlen(line2)
+
1;
printf("%d\n",
length);
fseek(ptrFile,
-length
,SEEK_CUR);
printf("HELLO\n");
}
else{
printf("OTHER
FIELDS");
Field
*
testField
=
otherFields(line2);
insertBack(&testEvent->otherFields,testField);
string start = 23
NUMBER OF arrows IN WORD insertBack(&testEvent->otherFields,testField); : 1
}
printf("LINE
2
%s\n",
readLN);
}while(readLN[0]
==
'2');
printf("Finish
Event:
");
insertBack(&fam->events,testEvent);
string start = 17
NUMBER OF arrows IN WORD insertBack(&fam->events,testEvent); : 1
//char
*
eTest
=
printEvent(testEvent);
//printf("%s\n",
printEvent(testEvent));
eFlag
=
0;
}
line
=
malloc(sizeof(char)
*
sizeof(readLine));
strcpy(line,readLine);
if(strstr(line,"HUSB")
!=
NULL){
printf("HUSB\n");
char
*
test
=
genericMember(line);
fam->husband
string start = 5
NUMBER OF arrows IN WORD fam->husband : 1
=
linker(test,
fam,
famLinkList);
printf("%s",
printIndividual(fam->husband));
string start = 21
NUMBER OF arrows IN WORD printIndividual(fam->husband)); : 1
printf("%s\n",
test);
}
else
if(strstr(line,"WIFE")
!=
NULL){
printf("WIFE\n");
char
*
test
=
genericMember(line);
fam->wife
string start = 5
NUMBER OF arrows IN WORD fam->wife : 1
=
linker(test,
fam,
famLinkList);
printf("HELLO\n");
printf("%s",
printIndividual(fam->wife));
string start = 21
NUMBER OF arrows IN WORD printIndividual(fam->wife)); : 1
printf("\n%s\n",
test);
}
else
if(strstr(line,"CHIL")
!=
NULL){
printf("CHIL\n");
char
*
test
=
genericMember(line);
insertBack(&fam->children,
string start = 17
NUMBER OF arrows IN WORD insertBack(&fam->children, : 1
linker(test,
fam,
famLinkList));
/*Individual
*
tests
=
linker(test,
fam,
famLinkList);
printf("%s",
printIndividual(tests));*/
printf("%s\n",
test);
}
else
if(line[0]
==
'0'){
}
else{
printf("OTHER\n");
}
}while(readLine[0]
!=
'0');
insertBack(&(*obj)->families,
string start = 20
NUMBER OF arrows IN WORD insertBack(&(*obj)->families, : 1
fam);
}
printf("%s\n",
line);
}
(*obj)->header
string start = 8
NUMBER OF arrows IN WORD (*obj)->header : 1
=
gedHeader;
(*obj)->submitter
string start = 8
NUMBER OF arrows IN WORD (*obj)->submitter : 1
=
gedSub;
GEDCOMerror
testCom;
if(trailerFlag
==
0){
testCom.type
=
INV_GEDCOM;
return
testCom;
}
fclose(ptrFile);
testCom.type
=
OK;
/*char
*
test
=
toString(gedHeader->otherFields);
string start = 20
NUMBER OF arrows IN WORD toString(gedHeader->otherFields); : 1
printf("%s\n",
test);
char
*
test2
=
toString(gedSub->otherFields);
string start = 17
NUMBER OF arrows IN WORD toString(gedSub->otherFields); : 1
printf("%s\n",
test2);*/
return
testCom;
}
char*
printError(GEDCOMerror
err){
char
*
errorMessage;
if(err.type
==
INV_FILE){
errorMessage
=
malloc(sizeof(char)
*
35);
sprintf(errorMessage,
"Invalid
File
Line(%d)",
err.line);
}
else
if(err.type
==
INV_GEDCOM){
errorMessage
=
malloc(sizeof(char)
*
35);
sprintf(errorMessage,
"Invalid
Gedcom
Line(%d)",
err.line);
}
else
if(err.type
==
INV_HEADER){
errorMessage
=
malloc(sizeof(char)
*
35);
sprintf(errorMessage,
"Invalid
header
Line(%d)",
err.line);
}
else
if(err.type
==
INV_RECORD){
errorMessage
=
malloc(sizeof(char)
*
35);
sprintf(errorMessage,
"Invalid
Record
Line(%d)",err.line);
}
else
if(err.type
==
OTHER_ERROR){
errorMessage
=
malloc(sizeof(char)
*
35);
sprintf(errorMessage,
"Other
error
Line(%d)",err.line);
}
else{
errorMessage
=
malloc(sizeof(char)
*
5);
strcpy(errorMessage,
"OK");
}
return
errorMessage;
}
void
deleteIndividual(void*
toBeDeleted){
}
int
compareIndividuals(const
void*
first,const
void*
second){
return
0;
}
char*
printIndividual(void*
toBePrinted){
//strcpy(returnString,
"TEST
INDIVIDUAL");
Individual
*
tempIndi
=
((Individual
*)toBePrinted);
if(tempIndi->givenName
string start = 13
NUMBER OF arrows IN WORD if(tempIndi->givenName : 1
==
NULL){
tempIndi->givenName
string start = 10
NUMBER OF arrows IN WORD tempIndi->givenName : 1
=
malloc(sizeof(char)
*
1);
strcpy(tempIndi->givenName,"\0");
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->givenName,"\0"); : 1
}
if(tempIndi->surname
string start = 13
NUMBER OF arrows IN WORD if(tempIndi->surname : 1
==
NULL){
tempIndi->surname
string start = 10
NUMBER OF arrows IN WORD tempIndi->surname : 1
=
malloc(sizeof(char)
*
1);
strcpy(tempIndi->surname,"\0");
string start = 17
NUMBER OF arrows IN WORD strcpy(tempIndi->surname,"\0"); : 1
}
char
*
fields
=
toString(tempIndi->otherFields);
string start = 19
NUMBER OF arrows IN WORD toString(tempIndi->otherFields); : 1
char
*
events
=
toString(tempIndi->events);
string start = 19
NUMBER OF arrows IN WORD toString(tempIndi->events); : 1
char
*returnString
=
malloc(sizeof(char)
*
strlen(tempIndi->surname)
string start = 17
NUMBER OF arrows IN WORD strlen(tempIndi->surname) : 1
+
strlen(tempIndi->surname)
string start = 17
NUMBER OF arrows IN WORD strlen(tempIndi->surname) : 1
+
strlen(fields)
+
strlen(events)
+
80);
strcpy(returnString,
"");
strcat(returnString,
"Given
Name:");
strcat(returnString,
tempIndi->givenName);
string start = 10
NUMBER OF arrows IN WORD tempIndi->givenName); : 1
strcat(returnString,
"
Surname:");
strcat(returnString,
tempIndi->surname);
string start = 10
NUMBER OF arrows IN WORD tempIndi->surname); : 1
strcat(returnString,
"\nEvents:
");
strcat(returnString,
events);
strcat(returnString,
"\nOther
Fields(Individual):
");
strcat(returnString,
fields);
strcat(returnString,
"\n");
return
returnString;
}
void
deleteEvent(void*
toBeDeleted){
}
int
compareEvents(const
void*
first,const
void*
second){
return
0;
}
//check
date
place
char*
printEvent(void*
toBePrinted){
Event
*
tempEvent
=
((Event
*)toBePrinted);
if(tempEvent->date
string start = 14
NUMBER OF arrows IN WORD if(tempEvent->date : 1
==
NULL){
tempEvent->date
string start = 11
NUMBER OF arrows IN WORD tempEvent->date : 1
=
"";
}
if(tempEvent->place
string start = 14
NUMBER OF arrows IN WORD if(tempEvent->place : 1
==
NULL){
tempEvent->place
string start = 11
NUMBER OF arrows IN WORD tempEvent->place : 1
=
"";
}
char
*
fields
=
toString(tempEvent->otherFields);
string start = 20
NUMBER OF arrows IN WORD toString(tempEvent->otherFields); : 1
char
*returnString
=
malloc(sizeof(char)
*
(strlen(tempEvent->date)
string start = 19
NUMBER OF arrows IN WORD (strlen(tempEvent->date) : 1
+
strlen(tempEvent->place)
string start = 18
NUMBER OF arrows IN WORD strlen(tempEvent->place) : 1
+
strlen(tempEvent->type)
string start = 18
NUMBER OF arrows IN WORD strlen(tempEvent->type) : 1
+
strlen(fields)
+
40));
strcpy(returnString,
"");
strcat(returnString,
"Type:\n");
strcat(returnString,
tempEvent->type);
string start = 11
NUMBER OF arrows IN WORD tempEvent->type); : 1
strcat(returnString,
"\nDate:\n");
strcat(returnString,
tempEvent->date);
string start = 11
NUMBER OF arrows IN WORD tempEvent->date); : 1
strcat(returnString,
"\nPlace:\n");
strcat(returnString,
tempEvent->place);
string start = 11
NUMBER OF arrows IN WORD tempEvent->place); : 1
strcat(returnString,
"\nFields:
");
strcat(returnString,
fields);
return
returnString;
}
void
deleteField(void*
toBeDeleted){
}
int
compareFields(const
void*
first,const
void*
second){
return
0;
}
//proll
not
char*
printField(void*
toBePrinted){
Field
*
tempField
=
((Field
*)toBePrinted);
char
*
returnString
=
malloc(sizeof(char)
*
(strlen(tempField->tag)
string start = 19
NUMBER OF arrows IN WORD (strlen(tempField->tag) : 1
+
strlen(tempField->value)
string start = 18
NUMBER OF arrows IN WORD strlen(tempField->value) : 1
+
50));
strcpy(returnString,
"");
strcat(returnString,
"Tag:
");
strcat(returnString,
tempField->tag);
string start = 11
NUMBER OF arrows IN WORD tempField->tag); : 1
strcat(returnString,
"
+
Value:
");
strcat(returnString,
tempField->value);
string start = 11
NUMBER OF arrows IN WORD tempField->value); : 1
return
returnString;
}
void
deleteFamily(void*
toBeDeleted){
}
int
compareFamilies(const
void*
first,const
void*
second){
return
0;
}
char*
printFamily(void*
toBePrinted){
Family
*
tempFam
=
((Family
*)toBePrinted);
char
*
indiv
=
toString(tempFam->children);
string start = 18
NUMBER OF arrows IN WORD toString(tempFam->children); : 1
char
*
events
=
toString(tempFam->events);
string start = 18
NUMBER OF arrows IN WORD toString(tempFam->events); : 1
char
*
returnString
=
malloc(sizeof(char)
*
(strlen(indiv)
+
strlen(events)
+300));
strcpy(returnString,"");
strcat(returnString,
"Husband:");
strcat(returnString,
printIndividual(tempFam->husband));
string start = 25
NUMBER OF arrows IN WORD printIndividual(tempFam->husband)); : 1
strcat(returnString,
"Wife:");
strcat(returnString,
printIndividual(tempFam->wife));
string start = 25
NUMBER OF arrows IN WORD printIndividual(tempFam->wife)); : 1
strcat(returnString,
indiv);
strcat(returnString,
events);
return
returnString;
}
Individual*
findPerson(const
GEDCOMobject*
familyRecord,
bool
(*compare)(const
void*
first,
const
void*
second),
const
void*
person){
ListIterator
iter
=
createIterator(familyRecord->individuals);
string start = 29
NUMBER OF arrows IN WORD createIterator(familyRecord->individuals); : 1
void*
elem;
while(
(elem
=
nextElement(&iter))
!=
NULL){
if((compare(person,(Individual*)elem)
==
0)){
return
(Individual*)elem;
}
}
return
NULL;
}
/*List
getDescendants(const
GEDCOMobject*
familyRecord,
const
Individual*
person){
}
*/
char*
printGEDCOM(const
GEDCOMobject*
obj){
char
*
printedOut;
char
*
temp
=
malloc(sizeof(char)
*
256);
printedOut
=
malloc(sizeof(char)
*
1000);
strcpy(printedOut,
"*******************Header*****************\n");
strcat(printedOut,
"Source:
");
strcat(printedOut,
obj->header->source);
string start = 5
string start = 13
NUMBER OF arrows IN WORD obj->header->source); : 2
sprintf(temp,
"\nGedcom
Version:
%f\nCharacter
Set:
%u\nSubmitter
Name:
%s\n",obj->header->gedcVersion,
string start = 11
string start = 19
NUMBER OF arrows IN WORD %s\n",obj->header->gedcVersion, : 2
obj->header->encoding,
string start = 5
string start = 13
NUMBER OF arrows IN WORD obj->header->encoding, : 2
obj->header->submitter->submitterName);
string start = 5
string start = 13
string start = 24
NUMBER OF arrows IN WORD obj->header->submitter->submitterName); : 3
strcat(printedOut,
temp);
strcat(printedOut,
"****************End
of
Header**************\n\n");
strcat(printedOut,
"*******************Individual*****************\n");
ListIterator
iter
=
createIterator(obj->individuals);
string start = 20
NUMBER OF arrows IN WORD createIterator(obj->individuals); : 1
void*
elem;
while(
(elem
=
nextElement(&iter))
!=
NULL){
strcat(printedOut,printIndividual((Individual*)elem));
}
strcat(printedOut,
"\n***************End
of
Individual**************\n");
strcat(printedOut,
"\n*******************Families*****************\n");
ListIterator
iter2
=
createIterator(obj->families);
string start = 20
NUMBER OF arrows IN WORD createIterator(obj->families); : 1
void*
elem2;
while(
(elem2
=
nextElement(&iter2))
!=
NULL){
strcat(printedOut,printIndividual((Family*)elem2));
}
strcat(printedOut,
"\n***************End
of
Families**************\n");
strcat(printedOut,
"\n*******************Submitter*****************\n");
strcat(printedOut,
"Submitter:
");
strcat(printedOut,
obj->header->submitter->submitterName);
string start = 5
string start = 13
string start = 24
NUMBER OF arrows IN WORD obj->header->submitter->submitterName); : 3
strcat(printedOut,
"\nAddress:
");
strcat(printedOut,
obj->header->submitter->address);
string start = 5
string start = 13
string start = 24
NUMBER OF arrows IN WORD obj->header->submitter->address); : 3
strcat(printedOut,
"\nOtherFields:
");
strcat(printedOut,
toString(obj->header->submitter->otherFields));
string start = 14
string start = 22
string start = 33
NUMBER OF arrows IN WORD toString(obj->header->submitter->otherFields)); : 3
strcat(printedOut,
"\n*****************End
of
Submitter************\n");
return
printedOut;
}
#ifndef
GEDCOMPARSER_H
#define
GEDCOMPARSER_H
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
"LinkedListAPI.h"
//For
simplicity,
the
examples
we
will
use
will
only
use
the
ASCII
subset
of
these
encodings
typedef
enum
cSet
{ANSEL,
UTF8,
UNICODE,
ASCII}
CharSet;
//error
code
enum
typedef
enum
eCode
{OK,
INV_FILE,
INV_GEDCOM,
INV_HEADER,
INV_RECORD,
OTHER_ERROR}
ErrorCode;
#ifdef
OTHER_INSTEAD
#define
OTHER
6
#endif
//Represents
a
generic
event,
e.g.
individual
event,
family
event,
etc.
typedef
struct
{
//The
max
length
of
this
field
is
known
from
the
GEDCOM
spec,
so
we
can
use
a
statically
allocated
array
char
type[5];
//Empty
string
if
not
provided
char*
date;
//Empty
string
if
not
provided
char*
place;
//All
other
event
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Event;
//Represents
a
generic
field.
typedef
struct
{
//Field
tag.
Must
not
be
NULL/empty.
char*
tag;
//Field
value.
Must
not
be
NULL/empty.
char*
value;
}
Field;
//Represents
a
submitter
record.
This
is
a
separate
type/struct,
in
case
we
decide
to
expand
it
in
later
assignments
typedef
struct
{
//Submitter
name
has
a
max
length
and
only
appears
once,
so
we
can
hardcode
it
char
submitterName[61];
//All
other
submitter
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
//Submitted
address.
We
use
a
C99
flexible
array
member,
which
we
will
discuss
in
class.
char
address[];
}
Submitter;
/*
Represents
the
GEDCOM
header
Only
includes
required
fields
("line
values"
in
GEDCOM
terminology)
Note
that
while
GEDCOM_FORM
is
required,
but
for
us
it
will
always
be
Lineage-Linked
*/
typedef
struct
{
//Header
source
-
i.e.
software
that
produced
the
GEDCOM
file
char
source[249];
//GEDCOM
version
float
gedcVersion;
//Encoding.
We
use
an
enum,
since
there
are
only
4
possible
values.
CharSet
encoding;
//Reference
to
the
submitter
record
Submitter*
submitter;
//All
other
header
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Header;
//Represends
GEDCOM
individual
record
typedef
struct
{
//Set
to
empty
string
if
not
present
in
file
char*
givenName;
//Set
to
empty
string
if
not
present
in
file
char*
surname;
//Collection
of
individual
events.
All
objects
in
the
list
will
be
of
type
Event.
It
may
be
empty.
List
events;
//Collection
of
family
references.
All
objects
in
the
list
will
be
of
type
Family.
It
may
be
empty.
List
families;
//All
other
individual
record
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Individual;
//Represends
GEDCOM
family
record
typedef
struct
{
//Wife
reference
(can
be
null)
Individual*
wife;
//Husband
reference
(can
be
null)
Individual*
husband;
//List
of
child
references.
All
objects
in
the
list
will
be
of
type
Individual.
It
may
be
empty.
List
children;
//Collection
of
family
events.
All
objects
in
the
list
will
be
of
type
Event.
It
may
be
empty.
List
events;
//List
of
other
fields
in
the
family
record.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Family;
//Represents
a
GEDCOM
object
typedef
struct
{
//Header.
Must
not
be
NULL.
Header*
header;
//Family
records.
All
objects
in
the
list
will
be
of
type
Family.
It
may
be
empty.
List
families;
//Must
contain
type
//Individual
records.
All
objects
in
the
list
will
be
of
type
Individual.
It
may
be
empty.
List
individuals;
//Must
contain
type
Family
//Submitter.
Must
not
be
NULL.
Submitter*
submitter;
//All
other
records
should
be
ignored
for
now
}
GEDCOMobject;
//Error
type
typedef
struct
{
ErrorCode
type;
int
line;
}
GEDCOMerror;
//*****************************************
GEDCOOM
object
functions
*****************************************
/**
Function
to
create
a
GEDCOM
object
based
on
the
contents
of
an
GEDCOM
file.
*@pre
File
name
cannot
be
an
empty
string
or
NULL.
File
name
must
have
the
.ged
extension.
File
represented
by
this
name
must
exist
and
must
be
readable.
*@post
Either:
A
valid
GEDCOM
has
been
created,
its
address
was
stored
in
the
variable
obj,
and
OK
was
returned
or
An
error
occurred,
the
GEDCOM
was
not
created,
all
temporary
memory
was
freed,
obj
was
set
to
NULL,
and
the
appropriate
error
code
was
returned
*@return
the
error
code
indicating
success
or
the
error
encountered
when
parsing
the
GEDCOM
*@param
fileName
-
a
string
containing
the
name
of
the
GEDCOM
file
*@param
a
double
pointer
to
a
GEDCOMobject
struct
that
needs
to
be
allocated
**/
GEDCOMerror
createGEDCOM(char*
fileName,
GEDCOMobject**
obj);
/**
Function
to
create
a
string
representation
of
a
GEDCOMobject.
*@pre
GEDCOMobject
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOMobject
has
not
been
modified
in
any
way,
and
a
string
representing
the
GEDCOM
contents
has
been
created
*@return
a
string
contaning
a
humanly
readable
representation
of
a
GEDCOMobject
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
char*
printGEDCOM(const
GEDCOMobject*
obj);
/**
Function
to
delete
all
GEDCOM
object
content
and
free
all
the
memory.
*@pre
GEDCOM
object
exists,
is
not
null,
and
has
not
been
freed
*@post
GEDCOM
object
had
been
freed
*@return
none
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
void
deleteGEDCOM(GEDCOMobject*
obj);
/**
Function
to
"convert"
the
GEDCOMerror
into
a
humanly
redabale
string.
*@return
a
string
contaning
a
humanly
readable
representation
of
the
error
code
*@param
err
-
an
error
struct
**/
char*
printError(GEDCOMerror
err);
/**
Function
that
searches
for
an
individual
in
the
list
using
a
comparator
function.
*
If
an
individual
is
found,
a
pointer
to
the
Individual
record
*
Returns
NULL
if
the
individual
is
not
found.
*@pre
GEDCOM
object
exists,is
not
NULL,
and
is
valid.
Comparator
function
has
been
provided.
*@post
GEDCOM
object
remains
unchanged.
*@return
The
Individual
record
associated
with
the
person
that
matches
the
search
criteria.
If
the
Individual
record
is
not
found,
return
NULL.
*If
multiple
records
match
the
search
criteria,
return
the
first
one.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
compare
-
a
pointer
to
comparator
fuction
for
customizing
the
search
*@param
person
-
a
pointer
to
search
data,
which
contains
seach
criteria
*Note:
while
the
arguments
of
compare()
and
person
are
all
void,
it
is
assumed
that
records
they
point
to
are
*
all
of
the
same
type
-
just
like
arguments
to
the
compare()
function
in
the
List
struct
**/
Individual*
findPerson(const
GEDCOMobject*
familyRecord,
bool
(*compare)(const
void*
first,
const
void*
second),
const
void*
person);
/**
Function
to
return
a
list
of
all
descendants
of
an
individual
in
a
GEDCOM
*@pre
GEDCOM
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOM
object
has
not
been
modified
in
any
way,
and
a
list
of
descendants
has
been
created
*@return
a
list
of
descendants.
The
list
may
be
empty.
All
list
members
must
be
of
type
Individual,
and
can
appear
in
any
order.
*All
list
members
must
be
COPIES
of
the
Individual
records
in
the
GEDCOM
file.
If
the
returned
list
is
freed,
the
original
GEDCOM
*must
remain
unaffected.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
person
-
the
Individual
record
whose
descendants
we
want
**/
List
getDescendants(const
GEDCOMobject*
familyRecord,
const
Individual*
person);
//************************************************************************************************************
//******************************************
List
helper
functions
*******************************************
void
deleteEvent(void*
toBeDeleted);
int
compareEvents(const
void*
first,const
void*
second);
char*
printEvent(void*
toBePrinted);
void
deleteIndividual(void*
toBeDeleted);
int
compareIndividuals(const
void*
first,const
void*
second);
char*
printIndividual(void*
toBePrinted);
void
deleteFamily(void*
toBeDeleted);
int
compareFamilies(const
void*
first,const
void*
second);
char*
printFamily(void*
toBePrinted);
void
deleteField(void*
toBeDeleted);
int
compareFields(const
void*
first,const
void*
second);
char*
printField(void*
toBePrinted);
//************************************************************************************************************
#endif
/**
*
@file
LinkedListAPI.h
*
@author
CIS*2750
F17
(based
on
the
ListADT
from
CIS*2520,
S17)
*
@date
September
2017
*
@brief
File
containing
the
function
definitions
of
a
doubly
linked
list
*/
#ifndef
_LIST_API_
#define
_LIST_API_
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
<assert.h>
/**
*
Node
of
a
linked
list.
This
list
is
doubly
linked,
meaning
that
it
has
points
to
both
the
node
immediately
in
front
*
of
it,
as
well
as
the
node
immediately
behind
it.
**/
typedef
struct
listNode{
void*
data;
struct
listNode*
previous;
struct
listNode*
next;
}
Node;
/**
*
Metadata
head
of
the
list.
*
Contains
no
actual
data
but
contains
*
information
about
the
list
(head
and
tail)
as
well
as
the
function
pointers
*
for
working
with
the
abstracted
list
data.
**/
typedef
struct
listHead{
Node*
head;
Node*
tail;
int
length;
void
(*deleteData)(void*
toBeDeleted);
int
(*compare)(const
void*
first,const
void*
second);
char*
(*printData)(void*
toBePrinted);
}
List;
/**
*
List
iterator
structure.
*
It
represents
an
abstract
object
for
iterating
through
the
list.
*
The
list
implemntation
is
hidden
from
the
user
**/
typedef
struct
iter{
Node*
current;
}
ListIterator;
/**
Function
to
initialize
the
list
metadata
head
with
the
appropriate
function
pointers.
*@return
the
list
struct
*@param
printFunction
function
pointer
to
print
a
single
node
of
the
list
*@param
deleteFunction
function
pointer
to
delete
a
single
piece
of
data
from
the
list
*@param
compareFunction
function
pointer
to
compare
two
nodes
of
the
list
in
order
to
test
for
equality
or
order
**/
List
initializeList(char*
(*printFunction)(void*
toBePrinted),void
(*deleteFunction)(void*
toBeDeleted),int
(*compareFunction)(const
void*
first,const
void*
second));
/**Function
for
creating
a
node
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
data
should
be
of
same
size
of
void
pointer
on
the
users
machine
to
avoid
size
conflicts.
data
must
be
valid.
*data
must
be
cast
to
void
pointer
before
being
added.
*@post
data
is
valid
to
be
added
to
a
linked
list
*@return
On
success
returns
a
node
that
can
be
added
to
a
linked
list.
On
failure,
returns
NULL.
*@param
data
-
is
a
void
*
pointer
to
any
data
type.
Data
must
be
allocated
on
the
heap.
**/
Node*
initializeNode(void*
data);
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
_tDummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertFront(List*
list,
void*
toBeAdded);
/**Inserts
a
Node
at
the
back
of
a
linked
list.
*List
metadata
is
updated
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
_tDummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertBack(List*
list,
void*
toBeAdded);
/**
Clears
the
contents
linked
list,
freeing
all
memory
asspociated
with
these
contents.
*
uses
the
supplied
function
pointer
to
release
allocated
memory
for
the
data
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
List-type
_tDummy
node
**/
void
clearList(List*
list);
/**
Uses
the
comparison
function
pointer
to
place
the
element
in
the
*
appropriate
position
in
the
list.
*
should
be
used
as
the
only
insert
function
if
a
sorted
list
is
required.
*@pre
List
exists
and
has
memory
allocated
to
it.
Node
to
be
added
is
valid.
*@post
The
node
to
be
added
will
be
placed
immediately
before
or
after
the
first
occurrence
of
a
related
node
*@param
list
a
pointer
to
the
_tDummy
head
of
the
list
containing
function
pointers
for
delete
and
compare,
as
well
as
a
pointer
to
the
first
and
last
element
of
the
list.
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertSorted(List*
list,
void*
toBeAdded);
/**
Removes
data
from
from
the
list,
deletes
the
node
and
frees
the
memory,
*
changes
pointer
values
of
surrounding
nodes
to
maintain
list
structure.
*
returns
the
data
*
You
can
assume
that
the
list
contains
no
duplicates
*@pre
List
must
exist
and
have
memory
allocated
to
it
*@post
toBeDeleted
will
have
its
memory
freed
if
it
exists
in
the
list.
*@param
list
pointer
to
the
_tDummy
head
of
the
list
containing
deleteFunction
function
pointer
*@param
toBeDeleted
pointer
to
data
that
is
to
be
removed
from
the
list
*@return
on
success:
void
*
pointer
to
data
on
failure:
NULL
**/
void*
deleteDataFromList(List*
list,
void*
toBeDeleted);
/**Returns
a
pointer
to
the
data
at
the
front
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
head
of
the
list
**/
void*
getFromFront(List
list);
/**Returns
a
pointer
to
the
data
at
the
back
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
tail
of
the
list
**/
void*
getFromBack(List
list);
/**Returns
a
string
that
contains
a
string
representation
of
the
list
traversed
from
head
to
tail.
Utilize
the
list's
printData
function
pointer
to
create
the
string.
returned
string
must
be
freed
by
the
calling
function.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
Pointer
to
linked
list
_tDummy
head.
*@return
on
success:
char
*
to
string
representation
of
list
(must
be
freed
after
use).
on
failure:
NULL
**/
char*
toString(List
list);
/**
Function
for
creating
an
iterator
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
List
exists
and
is
valid
*@post
List
remains
unchanged.
The
iterator
has
been
allocated
and
points
to
the
head
of
the
list.
*@return
The
newly
created
iterator
object.
*@param
list
-
a
pointer
to
the
list
to
iterate
over.
**/
ListIterator
createIterator(List
list);
/**
Function
that
returns
the
next
element
of
the
list
through
the
iterator.
*
This
function
returns
the
data
at
head
of
the
list
the
first
time
it
is
called
after.
*
the
iterator
was
created.
Every
subsequent
call
returns
the
data
associated
with
the
next
element.
*
Returns
NULL
once
the
end
of
the
iterator
is
reached.
*@pre
List
exists
and
is
valid.
Iterator
exists
and
is
valid.
*@post
List
remains
unchanged.
The
iterator
points
to
the
next
element
on
the
list.
*@return
The
data
associated
with
the
list
element
that
the
iterator
pointed
to
when
the
function
was
called.
*@param
iter
-
an
iterator
to
a
list.
**/
void*
nextElement(ListIterator*
iter);
/**Returns
the
number
of
elements
in
the
list.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
-
the
list
struct.
*@return
on
success:
number
of
eleemnts
in
the
list
(0
or
more).
on
failure:
-1
(e.g.
list
not
initlized
correctly)
**/
int
getLength(List
list);
/**
Function
that
searches
for
an
element
in
the
list
using
a
comparator
function.
*
If
an
element
is
found,
a
pointer
to
the
data
of
that
element
is
returned
*
Returns
NULL
if
the
element
is
not
found.
*@pre
List
exists
and
is
valid.
Comparator
function
has
been
provided.
*@post
List
remains
unchanged.
*@return
The
data
associated
with
the
list
element
that
matches
the
search
criteria.
If
element
is
not
found,
return
NULL.
*@param
list
-
a
list
sruct
*@param
customCompare
-
a
pointer
to
comparator
fuction
for
customizing
the
search
*@param
searchRecord
-
a
pointer
to
search
data,
which
contains
seach
criteria
*Note:
while
the
arguments
of
compare()
and
searchRecord
are
all
void,
it
is
assumed
that
records
they
point
to
are
*
all
of
the
same
type
-
just
like
arguments
to
the
compare()
function
in
the
List
struct
**/
void*
findElement(List
list,
bool
(*customCompare)(const
void*
first,const
void*
second),
const
void*
searchRecord);
#endif
/*
*
strings.c
-
API
-
Advanced
string
manipulation
library,
has
functionality
you'd
find
in
PHPs
string
library
*
*
Copyright
2018
Jake
Besworth
*
*
Licensed
under
the
Apache
License,
Version
2.0
(the
"License");
*
you
may
not
use
this
file
except
in
compliance
with
the
License.
*
You
may
obtain
a
copy
of
the
License
at
*
*
http://www.apache.org/licenses/LICENSE-2.0
*
*
Unless
required
by
applicable
law
or
agreed
to
in
writing,
software
*
distributed
under
the
License
is
distributed
on
an
"AS
IS"
BASIS,
*
WITHOUT
WARRANTIES
OR
CONDITIONS
OF
ANY
KIND,
either
express
or
implied.
*
See
the
License
for
the
specific
language
governing
permissions
and
*
limitations
under
the
License.
*
*/
#ifndef
STRINGS_
#define
STRINGS_
#ifdef
__cplusplus
extern
"C"
{
#endif
#include
<stdint.h>
#include
<stdlib.h>
/*
*
Converts
an
integer
to
an
ascii
string,
returns
a
static
stack
allocated
string
only
because
this
is
solely
used
for
hashing
integers
*
*
@param
integer
integer
to
turn
into
a
string
*
*
@return
static
string
with
integer
*/
char
*
integerToASCII(const
int
integer);
/*
*
Like
atoi
but
checks
for
hexadecimal,
octal,
binary
strings
as
well
as
decimal
*
*
@param
string
String
to
convert
to
integer
*
*
@return
integer
value
of
string
*/
int
asciiToInteger(const
char
*
const
integer);
/*
*
Remove
all
whitespace
from
a
string
(spaces,
tabs,
newlines,
return
character)
*
*
@param
string
String
to
check
*
*
@return
pointer
to
the
string
*/
char
*
stripWhitespace(char
*
string);
/*
*
Checks
if
string
contains
digits
and
decimal
*
*
@param
string
String
to
check
*
@param
allDigits
Whether
to
stop
at
a
single
digit
(or
decimal)
or
require
all
characters
be
digits
*
@param
stringLength
Length
of
the
string
(usually
gotten
through
strlen)
*
*
@return
1
if
string
contains
digits,
0
if
not
*/
int
stringIsDigit(const
char
*
const
string,
const
uint8_t
allDigits,
const
size_t
stringLength);
/*
*
Remove
a
specific
character
from
a
string,
shrinks
string
without
specified
character
*
*
@param
string
Pointer
to
the
string,
for
which
we
remove
a
character
from
*
@param
remove
Character
to
remove
(removes
all,
might
add
limit
later...)
*
*
@return
char
*
pointer
to
the
original
string
*/
char
*
removeStringCharacter(char
*
string,
const
char
remove);
/*
*
Replaces
a
specific
character
from
a
string,
string
retains
exact
length
*
*
@param
string
Pointer
to
the
string,
for
which
we
replace
character
from
*
@param
replace
Character
to
replace
*
*
@return
char
*
pointer
to
the
original
string
*/
char
*
replaceStringCharacter(char
*
string,
const
char
replace,
const
char
replacement);
/*
*
Similar
to
strtok,
simply
tokenizes
a
string
into
a
char
**
pointer
on
the
heap
with
NULL
ending
elements.
Must
be
freed
with
tokenFree
*
*
@param
block
String
to
tokenize
*
@param
delimiter
Delimiter
to
tokenize
on
*
@param
allowEmpty
Non-zero
value
indicates
that
strings
such
as
,,,
will
produce
["","",""]
instead
of
[""]
truncating
*
@param
maxTokens
Max
number
of
tokens
to
create,
0
for
infinite
else
1
is
1
EXTRA
token
max
etc...
*
*
@return
char
**
with
tokenized
string
*
*/
char
**
tokenCreate(const
char
*
const
block,
const
char
delimiter,
const
uint8_t
allowEmpty,
const
uint32_t
maxTokens);
/*
*
Counts
the
number
of
elements
in
a
char
**
*
*
@param
token
char
**
to
iterate
through
*
*
@return
count
of
elements
*
*/
int
tokenCount(char
**
token);
/*
*
Frees
all
memory
associated
with
a
char
**
pointer
returned
from
tokenCreate
*
*
@param
token
char
**
to
free
all
elements
*
*
@return
void
*
*/
void
tokenFree(char
**
token);
/*
*
Counts
the
occurences
of
a
substring
in
a
string
*
*
@param
haystack
The
string
to
check
for
substrings
*
@param
needle
The
substring
*
*
@return
count
of
occurences
of
substring
in
string
*
*/
int
substringOccurences(const
char
*
haystack,
const
char
*
needle);
/*
*
Returns
the
N
occurence
position
of
a
given
needle
in
a
haystack
*
*
@param
haystack
The
string
to
check
for
substrings
*
@param
needle
The
substring
*
@param
numberOfPositions
0
for
check
last
occurence,
1
for
first
and
so
on...
*
*
@return
position
of
substring
in
string,
or
-1
if
no
position
*
*/
int
substringPosition(const
char
*
haystack,
const
char
*
needle,
int
numberOfPositions);
/*
*
Implementation
independent
strdup,
not
optimized
*
*
@param
str
String
to
duplicate
*
*
@return
Duplicated
string,
needs
to
be
free(),
or
NULL
on
error
*
*/
char
*
stringCopy(const
char
*
const
str);
/*
*
Strdup
+
strcpy
with
optional
delimiter
*
*
@param
destination
Destination
string
*
@param
source
Source
string
to
copy
into
destination
*
@param
delimiter
Optional
delimiter
to
add
between
strings,
null
terminator
for
no
delimiter
*
*
@return
Concatenated
destination
*
*/
char
*
stringConcatenation(char
*
destination,
const
char
*
const
source,
const
char
delimiter);
#ifdef
__cplusplus
}
#endif
#endif
/*
*
general.h
-
API
for
Simple
System-level
functions
like
fileGetContents
*
*
Copyright
2018
Jake
Besworth
*
*
Licensed
under
the
Apache
License,
Version
2.0
(the
"License");
*
you
may
not
use
this
file
except
in
compliance
with
the
License.
*
You
may
obtain
a
copy
of
the
License
at
*
*
http://www.apache.org/licenses/LICENSE-2.0
*
*
Unless
required
by
applicable
law
or
agreed
to
in
writing,
software
*
distributed
under
the
License
is
distributed
on
an
"AS
IS"
BASIS,
*
WITHOUT
WARRANTIES
OR
CONDITIONS
OF
ANY
KIND,
either
express
or
implied.
*
See
the
License
for
the
specific
language
governing
permissions
and
*
limitations
under
the
License.
*
*/
#ifndef
GENERAL_
#define
GENERAL_
#ifdef
__cplusplus
extern
"C"
{
#endif
#include
<stdint.h>
#include
<stdio.h>
#include
<stdlib.h>
#define
LOG_STREAM
stderr
#define
logError(...)
(
\
fprintf(LOG_STREAM,
"[%s][%s:
%d]
",
getDate(),
__FILE__,
__LINE__),
\
fprintf(LOG_STREAM,
__VA_ARGS__),
\
fprintf(LOG_STREAM,
"\n")
\
)
#ifndef
endianSwap16
#define
endianSwap16(x)
(((x
>>
8)
&
0x00f)
|
((x
&
0x00ff)
<<
8))
#endif
#ifndef
endianSwap32
#define
endianSwap32(x)
(((x
>>
24)
&
0xff)
|
((x
<<
8)
&
0xff0000)
|
((x
>>
8)
&
0xff00)
|
((x
<<
24)
&
0xff000000))
#endif
#ifndef
endianSwap64
#define
endianSwap64(x)
((((uint64_t)
endianSwap32((x
&
0xFFFFFFFF00000000))
>>
32))
|
((((uint64_t)
endianSwap32(x
&
0x00000000FFFFFFFF)))
<<
32))
#endif
#ifndef
MIN
#define
MIN(a,b)
(((a)<(b))?(a):(b))
#endif
#ifndef
MAX
#define
MAX(a,b)
(((a)>(b))?(a):(b))
#endif
#ifndef
MAX3
#define
MAX3(a,b,c)
MAX(MAX(a,b),c)
#endif
#ifndef
MIN3
#define
MIN3(a,b,c)
MIN(MIN(a,b),c)
#endif
/*
*
fread
with
a
forced
little
endian
conversion
of
data
larger
than
1
byte
(2,
4,
8)
*
*
@param
ptr
Pointer
to
put
the
data
*
@param
size
Size
of
each
chunk
(1
nothing
happens,
2,
4,
8
an
endian
conversion
is
made)
*
@param
nmemb
Number
of
members
of
size
size
*
@param
stream
File
stream
to
write
to
*
*
@return
number
of
members
written
*
*/
size_t
freadEndian(void
*ptr,
size_t
size,
size_t
nmemb,
FILE
*stream);
/*
*
fwrite
with
a
forced
little
endian
conversion
of
data
larger
than
1
byte
(2,
4,
8)
*
*
@param
ptr
Pointer
to
data
*
@param
size
Size
of
each
chunk
(1
nothing
happens,
2,
4,
8
an
endian
conversion
is
made)
*
@param
nmemb
Number
of
members
of
size
size
*
@param
stream
File
stream
to
write
to
*
*
@return
number
of
members
written
*
*/
size_t
fwriteEndian(const
void
*ptr,
size_t
size,
size_t
nmemb,
FILE
*stream);
/*
*
Get
contents
of
a
file,
put
into
a
string
and
return
allocated
memory
*
*
@param
filename
filename
to
read
*
*
@return
allocated
string
with
entire
file
contents
*
*/
char
*
fileGetContents(const
char
*
filename);
/*
*
Get
contents
of
a
file,
put
into
a
char
*
stream
with
an
offset
and
max
read
*
*
@param
filename
filename
to
read
r
@param
filecontents
Address
to
char
*
where
to
allocate
contents
of
file
*
@param
offset
Offset
from
beginning
of
file,
0
for
no
offset
*
@param
maxLength
Maximum
length
to
read
in,
0
to
read
in
entire
file
*
@param
size
Size
of
each
fread
read
(1
normally)
*
*
@return
length
of
char
*
in
bytes
*
*/
unsigned
long
fileGetContentsBinary(const
char
*
filename,
char
**
filecontents,
const
size_t
offset,
const
size_t
maxLength,
const
size_t
size);
/*
*
Get
contents
of
a
file,
put
into
a
char
*
stream
with
an
offset
and
max
read
with
an
endian
check
*
*
@param
filename
filename
to
read
r
@param
filecontents
Address
to
char
*
where
to
allocate
contents
of
file
*
@param
offset
Offset
from
beginning
of
file,
0
for
no
offset
*
@param
maxLength
Maximum
length
to
read
in,
0
to
read
in
entire
file
*
@param
size
Size
of
each
fread
read
(1
normally)
*
@param
endian
Non-zero
flag
to
indicate
an
endian
conversion
*
*
@return
length
of
char
*
in
bytes
*
*/
unsigned
long
fileGetContentsBinaryEndian(const
char
*
filename,
char
**
filecontents,
const
size_t
offset,
const
size_t
maxLength,
const
size_t
size,
const
uint8_t
endian);
/*
*
Put
string
contents
into
filename
*
*
@param
filename
filename
to
write
to
(does
not
need
to
exist)
*
@param
contents
String
data,
null
terminated
*
*
@return
void
*
*/
void
filePutContents(const
char
*
filename,
const
char
*
contents);
/*
*
Put
contents
into
filename
with
extra
binary
options
*
*
@param
filename
filename
to
write
to
(does
not
need
to
exist)
*
@param
contents
contents
to
write
to
file
(1
byte
long)
*
@param
contentsSize
Length
of
contents
*
@param
size
Sizeof
each
contentsSize
*
@param
append
non-zero
value
to
append
contents
rather
than
overrwite
*
*
@return
void
*
*/
void
filePutContentsBinary(const
char
*
filename,
const
void
*
contents,
const
size_t
contentsSize,
const
size_t
size,
const
uint8_t
append);
/*
*
Put
contents
into
filename
with
an
added
endian
check
*
*
@param
filename
filename
to
write
to
(does
not
need
to
exist)
*
@param
contents
contents
to
write
to
file
(1
byte
long)
*
@param
contentsSize
Length
of
contents
*
@param
size
Sizeof
each
contentsSize
*
@param
append
non-zero
value
to
append
contents
rather
than
overrwite
*
@param
endian
non-zero
value
to
do
an
endian
conversion
with
endianWrite
*
*
@return
void
*
*/
void
filePutContentsBinaryEndian(const
char
*
filename,
const
void
*
contents,
const
size_t
contentsSize,
const
size_t
size,
const
uint8_t
append,
const
uint8_t
endian);
/*
*
Append
contents
to
filename
*
*
@param
filename
filename
to
append
to
(does
not
need
to
exist)
*
@param
contents
String
data,
null
terminated
*
*
@return
void
*
*/
void
fileAppendContents(const
char
*
filename,
const
char
*
contents);
/*
*
Opens
a
stream
at
the
given
filename
with
the
given
mode
*
*
@param
filename
file
to
open
*
@param
mode
mode
for
which
to
open
the
stream
*
@param
fileMustExist
True
if
you
want
a
fileExists
check
to
take
place,
for
readas
mostly
*
*
@return
FILE
pointer
to
new
stream
*
*/
FILE
*
openFile(const
char
*
filename,
const
char
*
mode,
uint8_t
fileMustExist);
/*
*
Get
the
current
system
time
(Hour:Minute:Second)
*
*
@return
string
of
the
current
time
*
*/
char
*
getTime(void);
/*
*
Get
the
system
date
*
*
@return
string
of
the
current
date
*
*/
char
*
getDate(void);
#ifdef
__cplusplus
}
#endif
#endif
/*
*
hash.h
-
Modifications
by
Jake
Besworth
*
*
strmap
version
2.0.1
*
*
Copyright
(c)
2009,
2011,
2013
Per
Ola
Kristensson.
*
*
Software
Modified
and
still
under
license.
*
*
Changes
made
were
as
such:
*
*
Changed
code
to
meet
project
coding
standards
and
style
*
Added
error
logging
as
per
project
standards
*
*
GNU
Lesser
General
Public
License
for
more
details.
*
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
*
along
with
strmap.
If
not,
see
<http://www.gnu.org/licenses/>.
*/
/*
Example
Usage
{
Store
*
store;
Void
*
obj
=
createThing("thing1");
store
=
createStore();
addStoreValue(store,
"key1",
obj);
obj
=
NULL;
obj
=
getObject(Store,
"cat");
printf("%s,
%d\n",
obj->thing,
string start = 5
NUMBER OF arrows IN WORD obj->thing, : 1
getObjectCount(Store));
//
"thing1"
"1"
"\n"
freeStore(Store);
return
0;
}
*/
#ifndef
HASH_
#define
HASH_
#ifdef
__cplusplus
extern
"C"
{
#endif
/*
*
Types
to
distinguish
store
types
*
*/
typedef
enum
{
STORE_MALLOC,
STORE_STRING,
STORE_TYPE_SIZE
}
storeType;
/*
*
Hash
key
=>
value
pair
*
*/
typedef
struct
Pair
{
char
*
key;
void
*
value;
}
Pair;
/*
*
Hash
table
bucket
*
*/
typedef
struct
Bucket
{
unsigned
int
count;
Pair
*pairs;
}
Bucket;
/*
*
Actual
Hash
Table
*
*/
typedef
struct
Store
{
unsigned
int
count;
storeType
type;
void
*
(*
get)(const
char
*
key);
int
(*
add)(const
char
*key,
void
*value);
Bucket
*buckets;
}
Store;
/*
*
This
callback
function
is
called
once
per
key-value
when
iterating
over
all
keys
associated
to
values
*
*
@param
key
A
pointer
to
a
null-terminated
C
string.
The
string
must
not
be
modified
by
the
client
*
@param
value
A
pointer
to
a
null-terminated
C
string.
The
string
must
not
be
modified
by
the
client
*
@param
obj
A
pointer
to
a
client-specific
object.
This
parameter
may
be
null
*
*
@return
void
*/
typedef
void(*sm_enum_func)(const
char
*key,
void
*
value,
const
void
*obj);
/*
*
Creates
a
string
map
*
*
@param
type
The
Store
type,
e.g.
object,
texture
*
*
@return
A
pointer
to
a
string
map
value,
or
null
if
a
new
string
map
could
not
be
allocated
*/
Store
*
createStore(void);
/*
*
Associates
a
value
with
the
supplied
key.
If
the
key
is
already
associated
with
a
value,
the
previous
value
is
replaced
*
*
@param
map
A
pointer
to
a
string
map.
This
parameter
cannot
be
null
*
@param
key
A
pointer
to
a
null-terminated
C
string.
This
parameter
cannot
be
null.
The
string
must
have
a
string
length
>
0.
The
string
will
be
copied
*
@param
value
A
pointer
to
the
Value
*
*
@return
1
if
the
association
succeeded,
0
otherwise.
*/
int
addStoreValue(const
Store
*map,
const
char
*key,
void
*value);
/*
*
Releases
all
memory
held
by
a
string
map
value
*
*
@param
map
A
pointer
to
a
string
map.
This
parameter
cannot
be
null.
If
the
supplied
string
map
has
been
previously
released,
the
*
behaviour
of
this
function
is
undefined
*
*
@return
void
*/
void
freeStore(Store
*map);
/*
*
Returns
the
value
associated
with
the
supplied
key
*
*
@param
map
A
pointer
to
a
string
map.
This
parameter
cannot
be
null
*
@param
key
A
pointer
to
a
null-terminated
C
string.
This
parameter
cannot
be
null
*
*
@return
value
value
or
NULL
on
unsuccessful
*/
void
*
getStoreValue(const
Store
*map,
const
char
*key);
/*
*
Queries
the
existence
of
a
key.
Note
keys
should
not
map
to
NULL
*
*
@param
map
A
pointer
to
a
string
map.
This
parameter
cannot
be
null
*
@param
key
A
pointer
to
a
null-terminated
C
string.
This
parameter
cannot
be
null
*
*
@return
1
if
the
key
exists,
0
otherwise
*/
int
storeKeyExists(const
Store
*map,
const
char
*key);
/*
*
An
enumerator
over
all
associations
between
keys
and
values.
*
*
@param
map
A
pointer
to
a
string
map.
This
parameter
cannot
be
null
*
@param
enum_func
A
pointer
to
a
callback
function
that
will
be
called
by
this
procedure
once
for
every
key
associated
with
a
value.
This
parameter
cannot
be
null
*
@param
obj
A
pointer
to
a
client-specific
object.
This
parameter
will
be
passed
back
to
the
client's
callback
function.
This
parameter
can
be
null
*
*
@return
1
if
enumeration
completed,
0
otherwise
*/
int
storeEnum(const
Store
*map,
sm_enum_func
enum_func,
const
void
*obj);
/*
*
Returns
the
number
of
associations
between
keys
and
values
*
*
@param
map
A
pointer
to
a
string
map.
This
parameter
cannot
be
null
*
*
@return
The
number
of
associations
between
keys
and
values.
*/
int
getStoreValueCount(const
Store
*map);
#ifdef
__cplusplus
}
#endif
#endif
/*
GNU
LESSER
GENERAL
PUBLIC
LICENSE
Version
3,
29
June
2007
Copyright
(C)
2007
Free
Software
Foundation,
Inc.
<http://fsf.org/>
Everyone
is
permitted
to
copy
and
distribute
verbatim
copies
of
this
license
document,
but
changing
it
is
not
allowed.
This
version
of
the
GNU
Lesser
General
Public
License
incorporates
the
terms
and
conditions
of
version
3
of
the
GNU
General
Public
License,
supplemented
by
the
additional
permissions
listed
below.
0.
Additional
Definitions.
As
used
herein,
"this
License"
refers
to
version
3
of
the
GNU
Lesser
General
Public
License,
and
the
"GNU
GPL"
refers
to
version
3
of
the
GNU
General
Public
License.
"The
Library"
refers
to
a
covered
work
governed
by
this
License,
other
than
an
Application
or
a
Combined
Work
as
defined
below.
An
"Application"
is
any
work
that
makes
use
of
an
interface
provided
by
the
Library,
but
which
is
not
otherwise
based
on
the
Library.
Defining
a
subclass
of
a
class
defined
by
the
Library
is
deemed
a
mode
of
using
an
interface
provided
by
the
Library.
A
"Combined
Work"
is
a
work
produced
by
combining
or
linking
an
Application
with
the
Library.
The
particular
version
of
the
Library
with
which
the
Combined
Work
was
made
is
also
called
the
"Linked
Version".
The
"Minimal
Corresponding
Source"
for
a
Combined
Work
means
the
Corresponding
Source
for
the
Combined
Work,
excluding
any
source
code
for
portions
of
the
Combined
Work
that,
considered
in
isolation,
are
based
on
the
Application,
and
not
on
the
Linked
Version.
The
"Corresponding
Application
Code"
for
a
Combined
Work
means
the
object
code
and/or
source
code
for
the
Application,
including
any
data
and
utility
programs
needed
for
reproducing
the
Combined
Work
from
the
Application,
but
excluding
the
System
Libraries
of
the
Combined
Work.
1.
Exception
to
Section
3
of
the
GNU
GPL.
You
may
convey
a
covered
work
under
sections
3
and
4
of
this
License
without
being
bound
by
section
3
of
the
GNU
GPL.
2.
Conveying
Modified
Versions.
If
you
modify
a
copy
of
the
Library,
and,
in
your
modifications,
a
facility
refers
to
a
function
or
data
to
be
supplied
by
an
Application
that
uses
the
facility
(other
than
as
an
argument
passed
when
the
facility
is
invoked),
then
you
may
convey
a
copy
of
the
modified
version:
a)
under
this
License,
provided
that
you
make
a
good
faith
effort
to
ensure
that,
in
the
event
an
Application
does
not
supply
the
function
or
data,
the
facility
still
operates,
and
performs
whatever
part
of
its
purpose
remains
meaningful,
or
b)
under
the
GNU
GPL,
with
none
of
the
additional
permissions
of
this
License
applicable
to
that
copy.
3.
Object
Code
Incorporating
Material
from
Library
Header
Files.
The
object
code
form
of
an
Application
may
incorporate
material
from
a
header
file
that
is
part
of
the
Library.
You
may
convey
such
object
code
under
terms
of
your
choice,
provided
that,
if
the
incorporated
material
is
not
limited
to
numerical
parameters,
data
structure
layouts
and
accessors,
or
small
macros,
inline
functions
and
templates
(ten
or
fewer
lines
in
length),
you
do
both
of
the
following:
a)
Give
prominent
notice
with
each
copy
of
the
object
code
that
the
Library
is
used
in
it
and
that
the
Library
and
its
use
are
covered
by
this
License.
b)
Accompany
the
object
code
with
a
copy
of
the
GNU
GPL
and
this
license
document.
4.
Combined
Works.
You
may
convey
a
Combined
Work
under
terms
of
your
choice
that,
taken
together,
effectively
do
not
restrict
modification
of
the
portions
of
the
Library
contained
in
the
Combined
Work
and
reverse
engineering
for
debugging
such
modifications,
if
you
also
do
each
of
the
following:
a)
Give
prominent
notice
with
each
copy
of
the
Combined
Work
that
the
Library
is
used
in
it
and
that
the
Library
and
its
use
are
covered
by
this
License.
b)
Accompany
the
Combined
Work
with
a
copy
of
the
GNU
GPL
and
this
license
document.
c)
For
a
Combined
Work
that
displays
copyright
notices
during
execution,
include
the
copyright
notice
for
the
Library
among
these
notices,
as
well
as
a
reference
directing
the
user
to
the
copies
of
the
GNU
GPL
and
this
license
document.
d)
Do
one
of
the
following:
0)
Convey
the
Minimal
Corresponding
Source
under
the
terms
of
this
License,
and
the
Corresponding
Application
Code
in
a
form
suitable
for,
and
under
terms
that
permit,
the
user
to
recombine
or
relink
the
Application
with
a
modified
version
of
the
Linked
Version
to
produce
a
modified
Combined
Work,
in
the
manner
specified
by
section
6
of
the
GNU
GPL
for
conveying
Corresponding
Source.
1)
Use
a
suitable
shared
library
mechanism
for
linking
with
the
Library.
A
suitable
mechanism
is
one
that
(a)
uses
at
run
time
a
copy
of
the
Library
already
present
on
the
user's
computer
system,
and
(b)
will
operate
properly
with
a
modified
version
of
the
Library
that
is
interface-compatible
with
the
Linked
Version.
e)
Provide
Installation
Information,
but
only
if
you
would
otherwise
be
required
to
provide
such
information
under
section
6
of
the
GNU
GPL,
and
only
to
the
extent
that
such
information
is
necessary
to
install
and
execute
a
modified
version
of
the
Combined
Work
produced
by
recombining
or
relinking
the
Application
with
a
modified
version
of
the
Linked
Version.
(If
you
use
option
4d0,
the
Installation
Information
must
accompany
the
Minimal
Corresponding
Source
and
Corresponding
Application
Code.
If
you
use
option
4d1,
you
must
provide
the
Installation
Information
in
the
manner
specified
by
section
6
of
the
GNU
GPL
for
conveying
Corresponding
Source.)
5.
Combined
Libraries.
You
may
place
library
facilities
that
are
a
work
based
on
the
Library
side
by
side
in
a
single
library
together
with
other
library
facilities
that
are
not
Applications
and
are
not
covered
by
this
License,
and
convey
such
a
combined
library
under
terms
of
your
choice,
if
you
do
both
of
the
following:
a)
Accompany
the
combined
library
with
a
copy
of
the
same
work
based
on
the
Library,
uncombined
with
any
other
library
facilities,
conveyed
under
the
terms
of
this
License.
b)
Give
prominent
notice
with
the
combined
library
that
part
of
it
is
a
work
based
on
the
Library,
and
explaining
where
to
find
the
accompanying
uncombined
form
of
the
same
work.
6.
Revised
Versions
of
the
GNU
Lesser
General
Public
License.
The
Free
Software
Foundation
may
publish
revised
and/or
new
versions
of
the
GNU
Lesser
General
Public
License
from
time
to
time.
Such
new
versions
will
be
similar
in
spirit
to
the
present
version,
but
may
differ
in
detail
to
address
new
problems
or
concerns.
Each
version
is
given
a
distinguishing
version
number.
If
the
Library
as
you
received
it
specifies
that
a
certain
numbered
version
of
the
GNU
Lesser
General
Public
License
"or
any
later
version"
applies
to
it,
you
have
the
option
of
following
the
terms
and
conditions
either
of
that
published
version
or
of
any
later
version
published
by
the
Free
Software
Foundation.
If
the
Library
as
you
received
it
does
not
specify
a
version
number
of
the
GNU
Lesser
General
Public
License,
you
may
choose
any
version
of
the
GNU
Lesser
General
Public
License
ever
published
by
the
Free
Software
Foundation.
If
the
Library
as
you
received
it
specifies
that
a
proxy
can
decide
whether
future
versions
of
the
GNU
Lesser
General
Public
License
shall
apply,
that
proxy's
public
statement
of
acceptance
of
any
version
is
permanent
authorization
for
you
to
choose
that
version
for
the
Library.
*/
#include
"LinkedListAPI.h"
/**
Function
to
initialize
the
list
metadata
head
to
the
appropriate
function
pointers.
Allocates
memory
to
the
struct.
*@return
pointer
to
the
list
head
*@param
printFunction
function
pointer
to
print
a
single
node
of
the
list
*@param
deleteFunction
function
pointer
to
delete
a
single
piece
of
data
from
the
list
*@param
compareFunction
function
pointer
to
compare
two
nodes
of
the
list
in
order
to
test
for
equality
or
order
**/
List
initializeList(char*
(*printFunction)(void*
toBePrinted),void
(*deleteFunction)(void*
toBeDeleted),int
(*compareFunction)(const
void*
first,const
void*
second)){
List
tmpList;
/*
replace
with
assert
if
(printFunction
==
NULL
||
deleteFunction
==
NULL
||
compareFunction
==
NULL){
return
NULL;
}
*/
tmpList.head
=
NULL;
tmpList.tail
=
NULL;
tmpList.length
=
0;
tmpList.deleteData
=
deleteFunction;
tmpList.compare
=
compareFunction;
tmpList.printData
=
printFunction;
return
tmpList;
}
/**
Deletes
the
entire
linked
list,
freeing
all
memory.
*
uses
the
supplied
function
pointer
to
release
allocated
memory
for
the
data
*
returns
NULL
on
success
or
the
head
of
the
list
on
failure.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
List-type
dummy
node
*@return
on
success:
NULL,
on
failure:
head
of
list
**/
void
clearList(List*
list){
if
(list
==
NULL){
return;
}
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
return;
}
Node*
tmp;
while
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
!=
NULL){
list->deleteData(list->head->data);
string start = 6
string start = 23
string start = 29
NUMBER OF arrows IN WORD list->deleteData(list->head->data); : 3
tmp
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
list->head->next;
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->next; : 2
free(tmp);
}
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
NULL;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
NULL;
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
=
0;
}
/**Function
for
creating
a
node
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
data
should
be
of
same
size
of
void
pointer
on
the
users
machine
to
avoid
size
conflicts.
data
must
be
valid.
*data
must
be
cast
to
void
pointer
before
being
added.
*@post
data
is
valid
to
be
added
to
a
linked
list
*@return
On
success
returns
a
node
that
can
be
added
to
a
linked
list.
On
failure,
returns
NULL.
*@param
data
-
is
a
void
*
pointer
to
any
data
type.
Data
must
be
allocated
on
the
heap.
**/
Node*
initializeNode(void*
data){
Node*
tmpNode;
tmpNode
=
(Node*)malloc(sizeof(Node));
if
(tmpNode
==
NULL){
return
NULL;
}
tmpNode->data
string start = 9
NUMBER OF arrows IN WORD tmpNode->data : 1
=
data;
tmpNode->previous
string start = 9
NUMBER OF arrows IN WORD tmpNode->previous : 1
=
NULL;
tmpNode->next
string start = 9
NUMBER OF arrows IN WORD tmpNode->next : 1
=
NULL;
return
tmpNode;
}
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertBack(List*
list,
void*
toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
Node*
newNode
=
initializeNode(toBeAdded);
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
}else{
newNode->previous
string start = 9
NUMBER OF arrows IN WORD newNode->previous : 1
=
list->tail;
string start = 6
NUMBER OF arrows IN WORD list->tail; : 1
list->tail->next
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->tail->next : 2
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
newNode;
}
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
+=
1;
}
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertFront(List*
list,
void*
toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
Node*
newNode
=
initializeNode(toBeAdded);
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
}else{
newNode->next
string start = 9
NUMBER OF arrows IN WORD newNode->next : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
list->head->previous
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->previous : 2
=
newNode;
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
}
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
+=
1;
}
/**Returns
a
pointer
to
the
data
at
the
front
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
head
of
the
list
**/
void*
getFromFront(List
list){
if
(list.head
==
NULL){
return
NULL;
}
return
list.head->data;
string start = 11
NUMBER OF arrows IN WORD list.head->data; : 1
}
/**Returns
a
pointer
to
the
data
at
the
back
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
tail
of
the
list
**/
void*
getFromBack(List
list){
if
(list.tail
==
NULL){
return
NULL;
}
return
list.tail->data;
string start = 11
NUMBER OF arrows IN WORD list.tail->data; : 1
}
/**
Uses
the
comparison
function
pointer
to
place
the
element
in
the
*
appropriate
position
in
the
list.
*
should
be
used
as
the
only
insert
function
if
a
sorted
list
is
required.
*@pre
List
exists
and
has
memory
allocated
to
it.
Node
to
be
added
is
valid.
*@post
The
node
to
be
added
will
be
placed
immediately
before
or
after
the
first
occurrence
of
a
related
node
*@param
list
a
pointer
to
the
dummy
head
of
the
list
containing
function
pointers
for
delete
and
compare,
as
well
as
a
pointer
to
the
first
and
last
element
of
the
list.
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
*@return
returns
EXIT_SUCCESS
on
success,
and
EXIT_FAILURE
on
failure.
**/
void
insertSorted(List
*list,
void
*toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL){
insertBack(list,
toBeAdded);
return;
}
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
list->head->data)
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->data) : 2
<=
0){
insertFront(list,
toBeAdded);
return;
}
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
list->tail->data)
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->tail->data) : 2
>
0){
insertBack(list,
toBeAdded);
return;
}
Node*
currNode
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
while
(currNode
!=
NULL){
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
currNode->data)
string start = 10
NUMBER OF arrows IN WORD currNode->data) : 1
<=
0){
char*
currDescr
=
list->printData(currNode->data);
string start = 6
string start = 26
NUMBER OF arrows IN WORD list->printData(currNode->data); : 2
char*
newDescr
=
list->printData(toBeAdded);
string start = 6
NUMBER OF arrows IN WORD list->printData(toBeAdded); : 1
free(currDescr);
free(newDescr);
Node*
newNode
=
initializeNode(toBeAdded);
newNode->next
string start = 9
NUMBER OF arrows IN WORD newNode->next : 1
=
currNode;
newNode->previous
string start = 9
NUMBER OF arrows IN WORD newNode->previous : 1
=
currNode->previous;
string start = 10
NUMBER OF arrows IN WORD currNode->previous; : 1
currNode->previous->next
string start = 10
string start = 20
NUMBER OF arrows IN WORD currNode->previous->next : 2
=
newNode;
currNode->previous
string start = 10
NUMBER OF arrows IN WORD currNode->previous : 1
=
newNode;
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
+=
1;
return;
}
currNode
=
currNode->next;
string start = 10
NUMBER OF arrows IN WORD currNode->next; : 1
}
return;
}
void*
deleteDataFromList(List
*list,
void
*toBeDeleted)
{
if(toBeDeleted
==
NULL)
{
return
NULL;
}
if(list
==
NULL)
{
printf("List
is
not
alloacted
properly\n");
return
NULL;
}
if(list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
head
==
NULL)
{
printf("List
is
empty\n");
return
NULL;
}
//if
the
tail
is
the
node
to
be
deleted
then
delete
it
and
replace
the
tail
if(list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
compare(list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
tail
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
data,
toBeDeleted)
==
0)
{
Node*
toBeFreed
=
list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
tail;
if(list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
tail
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
previous
!=
NULL)
{
list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
tail
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
previous
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
next
=
NULL;
}
list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
tail
=
list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
tail
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
previous;
void*
toBeReturned
=
toBeFreed
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
data;
free(toBeFreed);
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
-=
1;
return
toBeReturned;
}
else
if(list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
compare(list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
head
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
data,
toBeDeleted)
==
0)//if
the
head
is
the
node
to
be
deleted
then
delete
it
and
replace
the
head
{
Node*
toBeFreed
=
list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
head;
list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
head
=
list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
head
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
next;
if(list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
head
!=
NULL)
{
list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
head
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
previous
=
NULL;
}
void*
toBeReturned
=
toBeFreed
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
data;
free(toBeFreed);
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
-=
1;
return
toBeReturned;
}
//set
tempNode
to
the
head
and
use
it
for
looping
Node*
tempNode
=
list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
head;
while(tempNode
!=
NULL)
{
if(list
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
compare(tempNode
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
data,
toBeDeleted)
==
0)//if
you
find
the
node
break
{
break;
}
tempNode
=
tempNode
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
next;
}
//if
the
no
node
is
found
return
if(tempNode
==
NULL)
{
return
NULL;
}
//bypass
the
node
to
be
deleted
by
connecting
its
previous
node
and
next
node
tempNode
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
previous
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
next
=
tempNode
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
next;
tempNode
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
next
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
previous
=
tempNode
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
previous;
//save
the
node
data,
then
the
node
itself
void*
toBeReturned
=
tempNode
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
data;
free(tempNode);
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
-=
1;
return
toBeReturned;
}
/**Returns
a
string
that
contains
a
string
representation
of
the
list
traversed
from
head
to
tail.
Utilize
an
iterator
and
the
list's
printData
function
pointer
to
create
the
string.
returned
string
must
be
freed
by
the
calling
function.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
Pointer
to
linked
list
dummy
head.
*@return
on
success:
char
*
to
string
representation
of
list
(must
be
freed
after
use).
on
failure:
NULL
**/
char*
toString(List
list){
ListIterator
iter
=
createIterator(list);
char*
str;
str
=
(char*)malloc(sizeof(char));
strcpy(str,
"");
void*
elem;
while(
(elem
=
nextElement(&iter))
!=
NULL){
char*
currDescr
=
list.printData(elem);
int
newLen
=
strlen(str)+50+strlen(currDescr);
str
=
(char*)realloc(str,
newLen);
strcat(str,
"\n");
strcat(str,
currDescr);
free(currDescr);
}
return
str;
}
ListIterator
createIterator(List
list){
ListIterator
iter;
/*
replace
with
assert
if
(list
==
NULL){
return
NULL;
}
*/
iter.current
=
list.head;
return
iter;
}
void*
nextElement(ListIterator*
iter){
Node*
tmp
=
iter->current;
string start = 6
NUMBER OF arrows IN WORD iter->current; : 1
if
(tmp
!=
NULL){
iter->current
string start = 6
NUMBER OF arrows IN WORD iter->current : 1
=
iter->current->next;
string start = 6
string start = 15
NUMBER OF arrows IN WORD iter->current->next; : 2
return
tmp->data;
string start = 5
NUMBER OF arrows IN WORD tmp->data; : 1
}else{
return
NULL;
}
}
int
getLength(List
list){
return
list.length;
}
void*
findElement(List
list,
bool
(*customCompare)(const
void*
first,const
void*
second),
const
void*
searchRecord){
ListIterator
iter
=
createIterator(list);
void*
elem;
while(
(elem
=
nextElement(&iter))
!=
NULL){
if
(customCompare(elem,
searchRecord)){
return
elem;
}
}
return
NULL;
}
/*
*
strings.c
-
Advanced
string
manipulation
library,
has
functionality
you'd
find
in
PHPs
string
library
*
*
Copyright
2018
Jake
Besworth
*
*
Licensed
under
the
Apache
License,
Version
2.0
(the
"License");
*
you
may
not
use
this
file
except
in
compliance
with
the
License.
*
You
may
obtain
a
copy
of
the
License
at
*
*
http://www.apache.org/licenses/LICENSE-2.0
*
*
Unless
required
by
applicable
law
or
agreed
to
in
writing,
software
*
distributed
under
the
License
is
distributed
on
an
"AS
IS"
BASIS,
*
WITHOUT
WARRANTIES
OR
CONDITIONS
OF
ANY
KIND,
either
express
or
implied.
*
See
the
License
for
the
specific
language
governing
permissions
and
*
limitations
under
the
License.
*
*/
#include
<ctype.h>
#include
<stdint.h>
#include
<stdio.h>
#include
<stdlib.h>
#include
<string.h>
#include
"GEDCOMutilities.h"
/*
Number
of
words
allocated
per
allocation,
more
is
less
CPU
intensive,
but
more
memory
intensive
*/
#define
ALLOCATION_WORD_SIZE
6
/*
Number
of
characters
allocation
per
allocation,
more
is
less
CPU
intensive,
but
more
memory
intensive
*/
#define
ALLOCATION_CHARACTER_SIZE
32
char
*
integerToASCII(const
int
integer)
{
static
char
storage[200]
=
{0};
sprintf(storage,
"%d",
integer);
return
storage;
}
int
asciiToInteger(const
char
*
const
integer)
{
/*
No
number
*/
if(integer
==
NULL
||
integer[0]
==
'\0')
{
return
0;
}
return
strtol(integer,
NULL,
0);
}
int
stringIsDigit(const
char
*
const
string,
const
uint8_t
allDigits,
const
size_t
stringLength)
{
int32_t
i
=
stringLength
-
1;
if(string
==
NULL)
{
return
0;
}
while(i
>=
0)
{
if(!isdigit(string[i]))
{
if(!allDigits
||
(string[i]
!=
'.'
&&
string[i]
!=
'-'))
{
return
0;
}
}
i--;
}
return
1;
}
char
*
stripWhitespace(char
*
string)
{
if(string
==
NULL)
{
return
NULL;
}
string
=
removeStringCharacter(string,
'
');
string
=
removeStringCharacter(string,
'\t');
string
=
removeStringCharacter(string,
'\n');
string
=
removeStringCharacter(string,
'\r');
return
string;
}
char
*
replaceStringCharacter(char
*
string,
const
char
replace,
const
char
replacement)
{
if(string
==
NULL)
{
/*
logError("Warning:
string
pointer
empty");
*/
return
NULL;
}
char
*
stringRoot
=
string;
while(*string
!=
'\0')
{
if(*string
==
replace)
{
*string
=
replacement;
}
string++;
}
return
stringRoot;
}
char
*
removeStringCharacter(char
*
string,
const
char
remove)
{
if(string
==
NULL)
{
/*
logError("Warning:
string
pointer
empty");
*/
return
NULL;
}
char
*
stringRoot
=
string;
char
*
stringWrite
=
string;
while(*string
!=
'\0')
{
if(*string
!=
remove)
{
*stringWrite
=
*string;
stringWrite++;
}
string++;
}
*stringWrite
=
'\0';
return
stringRoot;
}
int
substringPosition(const
char
*
haystack,
const
char
*
needle,
int
numberOfPositions)
{
uint32_t
i,
j;
size_t
hLength,
nLength;
int
position
=
-1;
if(haystack
==
NULL
||
needle
==
NULL)
{
/*
logError("Warning:
Haystack
or
Needle
were
empty");
*/
return
0;
}
hLength
=
strlen(haystack);
nLength
=
strlen(needle);
/*
haystack
can't
be
less
than
needle
*/
if(hLength
<
nLength)
{
return
0;
}
for(i
=
0;
i
<
hLength;
i++)
{
/*
Haystack
too
short
to
contain
needle
*/
if((hLength
-
i)
<
nLength)
{
break;
}
/*
Check
if
needle
exists
in
haystack
at
point
i
*/
else
if(needle[0]
==
haystack[i])
{
for(j
=
0;
j
<
nLength;
j++)
{
if(needle[j]
!=
haystack[j
+
i])
{
break;
}
}
/*
Found
position!
*/
if(j
==
nLength)
{
position
=
i;
if(numberOfPositions
==
0)
{
continue;
}
else
if(numberOfPositions
==
1)
{
break;
}
numberOfPositions--;
}
}
}
return
position;
}
/*
Not
related
to
tokenizing,
but
substring
match
function
is
useful
*/
int
substringOccurences(const
char
*
haystack,
const
char
*
needle)
{
uint32_t
i,
j;
size_t
hLength,
nLength;
uint32_t
count
=
0;
if(haystack
==
NULL
||
needle
==
NULL)
{
/*
logError("Warning:
Haystack
or
Needle
were
empty");
*/
return
0;
}
hLength
=
strlen(haystack);
nLength
=
strlen(needle);
/*
haystack
can't
be
less
than
needle
*/
if(hLength
<
nLength)
{
return
0;
}
for(i
=
0;
i
<
hLength;
i++)
{
/*
Haystack
too
short
to
contain
needle
*/
if((hLength
-
i)
<
nLength)
{
break;
}
/*
Check
if
needle
exists
in
haystack
at
point
i
*/
else
if(needle[0]
==
haystack[i])
{
for(j
=
0;
j
<
nLength;
j++)
{
if(needle[j]
!=
haystack[j
+
i])
{
break;
}
}
if(j
==
nLength)
{
count++;
}
/*
This
assume
j
can
never
be
zero
There
might
be
a
better
optimization...
*/
/*
i
+=
(j
-
1);
*/
}
}
return
count;
}
void
tokenFree(char
**
token)
{
int
i
=
0;
if(token
!=
NULL)
{
while(token[i]
!=
NULL)
{
free(token[i]);
i++;
}
free(token);
}
}
int
tokenCount(char
**
token)
{
int
i
=
0;
if(token
!=
NULL)
{
while(token[i]
!=
NULL)
{
i++;
}
}
return
i;
}
char
**
tokenCreate(const
char
*
const
block,
const
char
delimiter,
const
uint8_t
allowEmpty,
const
uint32_t
maxTokens)
{
char
**
tokens;
size_t
length;
/*
Token
Word
Placement
*/
uint32_t
i
=
0;
/*
Block
String
Placement
*/
uint32_t
j
=
0;
uint32_t
maxTokensCount
=
maxTokens;
/*
Remove
the
+
1?
Just
for
safety
of
allocation_word_size
*/
uint32_t
wordAllocations
=
ALLOCATION_WORD_SIZE
+
1;
uint32_t
characterAllocations
=
ALLOCATION_CHARACTER_SIZE
+
1;
/*
Initial
Allocation
*/
tokens
=
malloc(sizeof(char
*)
*
wordAllocations);
tokens[0]
=
malloc(sizeof(char)
*
characterAllocations);
tokens[0][0]
=
'\0';
tokens[1]
=
NULL;
if(block
==
NULL
||
block[0]
==
'\0')
{
/*
logError("Warning:
String
to
tokenize
empty");
*/
return
tokens;
}
/*
Keep
looping
until
we
run
out
of
stream
or
find
a
newline
(assuming
delimiter
is
NOT
newline)
*/
while(block[j]
!=
'\0')
{
/*
If
we
hit
a
delimiter
(skip
if
last
token
is
empty,
we
will
reuse
*/
if(block[j]
==
delimiter
&&
(maxTokens
==
0
||
maxTokensCount
>
0))
{
if(allowEmpty
||
tokens[i][0]
!=
'\0')
{
i++;
/*
We
have
run
out
of
allocations
*/
if(wordAllocations
<=
(i
+
1))
{
wordAllocations
+=
ALLOCATION_WORD_SIZE
+
1;
characterAllocations
=
ALLOCATION_CHARACTER_SIZE
+
1;
tokens
=
realloc(tokens,
(sizeof(char
*)
*
wordAllocations));
}
tokens[i]
=
malloc(sizeof(char)
*
characterAllocations);
tokens[i][0]
=
'\0';
tokens[i
+
1]
=
NULL;
if(maxTokens
!=
0)
{
maxTokensCount--;
}
}
}
else
{
length
=
strlen(tokens[i]);
if(characterAllocations
<=
(length
+
1))
{
characterAllocations
+=
ALLOCATION_CHARACTER_SIZE
+
1;
tokens[i]
=
realloc(tokens[i],
(sizeof(char)
*
characterAllocations));
}
tokens[i][length
+
1]
=
'\0';
tokens[i][length]
=
block[j];
}
j++;
}
return
tokens;
}
char
*
stringConcatenation(char
*
destination,
const
char
*
const
source,
const
char
delimiter)
{
if(source
==
NULL)
{
return
destination;
}
if(destination
==
NULL)
{
destination
=
calloc(sizeof(char),
(strlen(source)
+
1));
if(destination
==
NULL)
{
return
NULL;
}
return
strcpy(destination,
source);
}
if(destination[0]
==
'\0')
{
free(destination);
destination
=
calloc(sizeof(char),
(strlen(source)
+
1));
if(destination
==
NULL)
{
return
NULL;
}
return
strcpy(destination,
source);
}
size_t
destinationLength
=
strlen(destination)
+
1;
size_t
sourceLength
=
strlen(source)
+
1;
if(delimiter
!=
'\0')
{
destination
=
realloc(destination,
destinationLength
+
sourceLength
+
1);
if(destination
==
NULL)
{
return
NULL;
}
destination[destinationLength
-
1]
=
delimiter;
destination[destinationLength]
=
'\0';
return
strncat(destination,
source,
sourceLength);
}
else
{
destination
=
realloc(destination,
destinationLength
+
sourceLength);
if(destination
==
NULL)
{
return
NULL;
}
return
strncat(destination,
source,
sourceLength);
}
}
char
*
stringCopy(const
char
*
const
str)
{
if(str
==
NULL)
{
return
NULL;
}
size_t
strSize
=
strlen(str)
+
1;
char
*
copyStr
=
malloc(sizeof(char)
*
strSize);
return
strncpy(copyStr,
str,
strSize);
}
/*
*
general.c
-
Simple
System-level
functions
like
fileGetContents
*
*
Copyright
2018
Jake
Besworth
*
*
Licensed
under
the
Apache
License,
Version
2.0
(the
"License");
*
you
may
not
use
this
file
except
in
compliance
with
the
License.
*
You
may
obtain
a
copy
of
the
License
at
*
*
http://www.apache.org/licenses/LICENSE-2.0
*
*
Unless
required
by
applicable
law
or
agreed
to
in
writing,
software
*
distributed
under
the
License
is
distributed
on
an
"AS
IS"
BASIS,
*
WITHOUT
WARRANTIES
OR
CONDITIONS
OF
ANY
KIND,
either
express
or
implied.
*
See
the
License
for
the
specific
language
governing
permissions
and
*
limitations
under
the
License.
*
*/
/*
Standard
Include
*/
#include
<stdio.h>
#include
<stdlib.h>
#include
<string.h>
/*
Standard
System
Include
*/
#include
<sys/stat.h>
#include
<time.h>
#include
<unistd.h>
#ifndef
F_OK
#define
F_OK
0
#endif
#include
"GEDCOMutilities.h"
size_t
freadEndian(void
*ptr,
size_t
size,
size_t
nmemb,
FILE
*stream)
{
int
temp
=
1;
size_t
returnValue;
/*
Little
Endian
*/
if(*((char
*)
&temp)
==
0)
{
return
fread(ptr,
size,
nmemb,
stream);
}
else
{
if(size
>
8)
{
/*
logError("Error:
fread
with
little
endian
does
not
support
>
8
(%d)
size",
(int)
size);
*/
return
0;
}
returnValue
=
fread(ptr,
size,
nmemb,
stream);
if(size
==
8)
{
*((uint64_t
*)
ptr)
=
endianSwap64(*((uint64_t
*)
ptr));
}
else
if(size
==
4)
{
*((uint32_t
*)
ptr)
=
endianSwap32(*((uint32_t
*)
ptr));
}
else
if(size
==
2)
{
*((uint16_t
*)
ptr)
=
endianSwap16(*((uint16_t
*)
ptr));
}
return
returnValue;
}
}
size_t
fwriteEndian(const
void
*ptr,
size_t
size,
size_t
nmemb,
FILE
*stream)
{
int
temp
=
1;
size_t
swap
=
0;
/*
Little
Endian
*/
if(*((char
*)
&temp)
==
0)
{
return
fwrite(ptr,
size,
nmemb,
stream);
}
else
{
if(size
>
8)
{
/*
logError("Error:
fwrite
with
little
endian
does
not
support
>
8
(%d)
size",
(int)
size);
*/
return
0;
}
else
if(size
==
8)
{
swap
=
(uint64_t)
*((const
uint64_t
*)
ptr);
swap
=
endianSwap64(swap);
}
else
if(size
==
4)
{
swap
=
(uint32_t)
*((const
uint32_t
*)
ptr);
swap
=
endianSwap32(swap);
}
else
if(size
==
2)
{
swap
=
(uint16_t)
*((const
uint16_t
*)
ptr);
swap
=
endianSwap16(swap);
}
/*
1
Byte
stream,
no
endianness
*/
return
fwrite(&swap,
size,
nmemb,
stream);
}
}
void
fileAppendContents(const
char
*
filename,
const
char
*
contents)
{
filePutContentsBinary(filename,
contents,
strlen(contents),
1,
1);
}
void
filePutContents(const
char
*
filename,
const
char
*
contents)
{
filePutContentsBinary(filename,
contents,
strlen(contents),
1,
0);
}
void
filePutContentsBinary(const
char
*
filename,
const
void
*
contents,
const
size_t
contentsSize,
const
size_t
size,
const
uint8_t
append)
{
filePutContentsBinaryEndian(filename,
contents,
contentsSize,
size,
append,
0);
}
void
filePutContentsBinaryEndian(const
char
*
filename,
const
void
*
contents,
const
size_t
contentsSize,
const
size_t
size,
uint8_t
const
append,
const
uint8_t
endian)
{
FILE
*
fp
=
NULL;
size_t
readSize
=
0;
if(filename
==
NULL
||
contents
==
NULL)
{
/*
logError("Warning:
filename
or
contents
NULL");
*/
return;
}
fp
=
openFile(filename,
(append
?
"ab"
:
"wb"),
0);
if(fp
==
NULL)
{
/*
logError("Fatal
Error:
cannot
open
file
{%s}",
filename);
*/
return;
}
if(endian)
{
readSize
=
fwriteEndian(contents,
size,
contentsSize,
fp);
}
else
{
readSize
=
fwrite(contents,
size,
contentsSize,
fp);
}
fflush(fp);
fclose(fp);
if(readSize
!=
contentsSize)
{
/*
logError("Warning:
frwite
didn't
write
all
bytes
to
file");
*/
}
}
unsigned
long
fileGetContentsBinary(const
char
*
filename,
char
**
filecontents,
const
size_t
offset,
const
size_t
maxLength,
const
size_t
size)
{
return
fileGetContentsBinaryEndian(filename,
filecontents,
offset,
maxLength,
size,
0);
}
unsigned
long
fileGetContentsBinaryEndian(const
char
*
filename,
char
**
filecontents,
const
size_t
offset,
const
size_t
maxLength,
const
size_t
size,
const
uint8_t
endian)
{
FILE
*
fp
=
NULL;
unsigned
long
end;
if(filename
==
NULL
||
filecontents
==
NULL)
{
/*
logError("Warning:
filename
or
filecontents
NULL");
*/
return
0;
}
fp
=
openFile(filename,
"rb",
1);
if(fp
==
NULL)
{
/*
logError("Error:
cannot
open
file
{%s}",
filename);
*/
return
0;
}
/*
Read
contents
in
one
go
into
variable
*/
fseek(fp,
0,
SEEK_END);
end
=
ftell(fp);
fseek(fp,
0,
SEEK_SET);
/*
Set
an
offet
to
reading
later
*/
if(offset
>
0
&&
offset
<
end)
{
fseek(fp,
offset,
SEEK_CUR);
end
-=
offset;
}
/*
Set
a
max
length
*/
if(maxLength
>
0
&&
maxLength
<
end)
{
end
=
(unsigned
long)
maxLength;
}
/*
Pad
extra
cell
with
0
for
strings...
*/
*filecontents
=
calloc(end
+
(size
==
1
?
1
:
0),
size);
if(*filecontents
==
NULL)
{
/*
logError("Fatal
Error:
Malloc
return
NULL,
system
out
of
memory");
*/
exit(EXIT_FAILURE);
}
if(endian)
{
if(freadEndian(*filecontents,
size,
end,
fp)
!=
end)
{
/*
logError("Warning:
fread
unsuccessful");
*/
}
}
else
{
if(fread(*filecontents,
size,
end,
fp)
!=
end)
{
/*
logError("Warning:
fread
unsuccessful");
*/
}
}
fclose(fp);
return
end;
}
char
*
fileGetContents(const
char
*
filename)
{
char
*
filecontents
=
NULL;
fileGetContentsBinary(filename,
&filecontents,
0,
0,
1);
return
filecontents;
}
char
*
getTime(void)
{
static
char
date[100]
=
{0};
time_t
rawtime;
struct
tm
*
timeinfo;
time(&rawtime);
timeinfo
=
localtime(&rawtime);
snprintf(date,
100,
"%02d:%02d:%02d",
timeinfo->tm_hour,
string start = 10
NUMBER OF arrows IN WORD timeinfo->tm_hour, : 1
timeinfo->tm_min,
string start = 10
NUMBER OF arrows IN WORD timeinfo->tm_min, : 1
timeinfo->tm_sec);
string start = 10
NUMBER OF arrows IN WORD timeinfo->tm_sec); : 1
if(date[strlen(date)-1]
==
'\n')
{
date[strlen(date)-1]
=
'\0';
}
return
date;
}
char
*
getDate(void)
{
char
*
date
=
NULL;
time_t
rawtime;
struct
tm
*
timeinfo;
time(&rawtime);
timeinfo
=
localtime(&rawtime);
date
=
asctime(timeinfo);
if(date[strlen(date)-1]
==
'\n')
{
date[strlen(date)-1]
=
'\0';
}
return
date;
}
FILE
*
openFile(const
char
*
const
filename,
const
char
*
mode,
const
uint8_t
fileMustExist)
{
FILE
*
fp
=
NULL;
struct
stat
path;
if(filename
==
NULL)
{
/*
logError("Warning:
Filename
NULL");
*/
return
NULL;
}
if(mode
==
NULL)
{
/*
logError("Warning:
Mode
NULL");
*/
return
NULL;
}
/*
Check
if
file
exists
*/
if(fileMustExist)
{
/*
Check
if
directory
*/
if(stat(filename,
&path))
{
/*
Flush
errno
*/
perror(NULL);
/*
logError("Warning:
stat
cannot
read
filename:
%s",
filename);
*/
return
NULL;
}
if(S_ISDIR(path.st_mode))
{
/*
logError("Warning:
openFile
on
directory
for
filename:
%s",
filename);
*/
return
NULL;
}
if(access(filename,
F_OK)
!=
0)
{
/*
logError("Warning:
File
\"%s\"
does
not
exist",
filename);
*/
return
NULL;
}
}
fp
=
fopen(filename,
mode);
if(fp
==
NULL)
{
/*
logError("Warning:
File
\"%s\"
could
not
be
opened",
filename);
*/
}
return
fp;
}
/*
*
strmap
version
2.0.1
*
*
Copyright
(c)
2009,
2011,
2013
Per
Ola
Kristensson.
*
*
Software
Modified
and
still
under
license.
*
*
GNU
Lesser
General
Public
License
for
more
details.
*
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
*
along
with
strmap.
If
not,
see
<http://www.gnu.org/licenses/>.
*/
#include
<stdio.h>
#include
<stdlib.h>
#include
<string.h>
#include
"hash.h"
#define
STORE_ALLOCATION_SIZE_LARGE
1000
/*
*
Gets
a
pair
from
a
bucket
using
a
key
*
*
@param
*bucket
The
bucket
to
search
*
@param
*key
The
key
to
find
*
*
@return
Key
Value
Pair
on
success
or
NULL
otherwise
*
*/
static
Pair
*
get_pair(Bucket
*bucket,
const
char
*key);
/*
*
Classic
djb2
hash
*
*
@param
*str
The
string
to
hash
*
*
@return
the
unsigned
long
djb2
hash
*
*/
static
unsigned
long
hash(const
char
*str);
Store
*
createStore(void)
{
Store
*
map
=
malloc(sizeof(Store));
if(map
==
NULL)
{
/*
logError("Error:
Malloc
return
NULL,
system
out
of
memory");
*/
exit(EXIT_FAILURE);
}
map->count
string start = 5
NUMBER OF arrows IN WORD map->count : 1
=
STORE_ALLOCATION_SIZE_LARGE;
map->buckets
string start = 5
NUMBER OF arrows IN WORD map->buckets : 1
=
calloc(map->count,
string start = 12
NUMBER OF arrows IN WORD calloc(map->count, : 1
sizeof(Bucket));
/*
Allow
custom
types
to
be
created
(used
for
free-ing)
*/
map->type
string start = 5
NUMBER OF arrows IN WORD map->type : 1
=
STORE_MALLOC;
if(map->buckets
string start = 8
NUMBER OF arrows IN WORD if(map->buckets : 1
==
NULL)
{
/*
logError("Error:
Malloc
return
NULL,
system
out
of
memory");
*/
free(map);
return
NULL;
}
return
map;
}
void
freeStore(Store
*
map)
{
unsigned
int
i,
j,
n,
m;
Bucket
*
bucket;
Pair
*
pair;
if(map
==
NULL)
{
return;
}
n
=
map->count;
string start = 5
NUMBER OF arrows IN WORD map->count; : 1
bucket
=
map->buckets;
string start = 5
NUMBER OF arrows IN WORD map->buckets; : 1
i
=
0;
while(i
<
n)
{
m
=
bucket->count;
string start = 8
NUMBER OF arrows IN WORD bucket->count; : 1
pair
=
bucket->pairs;
string start = 8
NUMBER OF arrows IN WORD bucket->pairs; : 1
j
=
0;
while(j
<
m)
{
free(pair->key);
string start = 11
NUMBER OF arrows IN WORD free(pair->key); : 1
/*
Value
is
a
dynamic
value
so
we
use
enumeration
to
determine
how
to
clean
up
*/
if(map->type
string start = 8
NUMBER OF arrows IN WORD if(map->type : 1
==
STORE_MALLOC)
{
}
pair++;
j++;
}
free(bucket->pairs);
string start = 13
NUMBER OF arrows IN WORD free(bucket->pairs); : 1
bucket++;
i++;
}
free(map->buckets);
string start = 10
NUMBER OF arrows IN WORD free(map->buckets); : 1
free(map);
}
void
*
getStoreValue(const
Store
*map,
const
char
*key)
{
unsigned
int
index;
Bucket
*
bucket;
Pair
*
pair;
if(map
==
NULL)
{
/*
logError("Warning:
map
object
empty");
*/
return
NULL;
}
if(key
==
NULL)
{
/*
logError("Warning:
provided
key
empty");
*/
return
NULL;
}
index
=
hash(key)
%
map->count;
string start = 5
NUMBER OF arrows IN WORD map->count; : 1
bucket
=
&(map->buckets[index]);
string start = 7
NUMBER OF arrows IN WORD &(map->buckets[index]); : 1
pair
=
get_pair(bucket,
key);
/*
No
error
message,
we
use
this
for
keyExists
as
well
*/
if(pair
==
NULL)
{
return
NULL;
}
return
pair->value;
string start = 6
NUMBER OF arrows IN WORD pair->value; : 1
}
int
storeKeyExists(const
Store
*map,
const
char
*key)
{
if(getStoreValue(map,
key)
!=
NULL)
{
return
1;
}
else
{
return
0;
}
}
int
addStoreValue(const
Store
*map,
const
char
*key,
void
*value)
{
unsigned
int
index;
Bucket
*bucket;
Pair
*tmp_pairs,
*pair;
char
*new_key;
if(map
==
NULL)
{
/*
logError("Warning:
map
object
empty");
*/
return
0;
}
if(key
==
NULL)
{
/*
logError("Warning:
provided
key
empty");
*/
return
0;
}
/*
Get
a
pointer
to
the
bucket
the
key
string
hashes
to
*/
index
=
hash(key)
%
map->count;
string start = 5
NUMBER OF arrows IN WORD map->count; : 1
bucket
=
&(map->buckets[index]);
string start = 7
NUMBER OF arrows IN WORD &(map->buckets[index]); : 1
/*
Check
if
we
can
handle
insertion
by
simply
replacing
*
an
existing
value
in
a
key-value
pair
in
the
bucket.
*/
if((pair
=
get_pair(bucket,
key))
!=
NULL)
{
if(pair->value
string start = 9
NUMBER OF arrows IN WORD if(pair->value : 1
!=
value)
{
/*
key
already
mapped
*/
if(map->type
string start = 8
NUMBER OF arrows IN WORD if(map->type : 1
==
STORE_MALLOC)
{
}
/*
Copy
the
new
value
into
the
pair
that
matches
the
key
*/
pair->value
string start = 6
NUMBER OF arrows IN WORD pair->value : 1
=
value;
}
return
1;
}
/*
Allocate
space
for
a
new
key
and
value
*/
new_key
=
malloc(sizeof(char)
*
(strlen(key)
+
1));
if(new_key
==
NULL)
{
/*
logError("Error:
Malloc
return
NULL,
system
out
of
memory");
*/
return
0;
}
if(bucket->count
string start = 11
NUMBER OF arrows IN WORD if(bucket->count : 1
==
0)
{
/*
The
bucket
is
empty,
lazily
allocate
space
for
a
single
*
key-value
pair.
*/
bucket->pairs
string start = 8
NUMBER OF arrows IN WORD bucket->pairs : 1
=
malloc(sizeof(Pair));
if(bucket->pairs
string start = 11
NUMBER OF arrows IN WORD if(bucket->pairs : 1
==
NULL)
{
/*
logError("Error:
Malloc
return
NULL,
system
out
of
memory");
*/
free(new_key);
if(map->type
string start = 8
NUMBER OF arrows IN WORD if(map->type : 1
==
STORE_MALLOC)
{
}
return
0;
}
bucket->count
string start = 8
NUMBER OF arrows IN WORD bucket->count : 1
=
1;
}
else
{
/*
The
bucket
wasn't
empty
but
no
pair
existed
that
matches
the
provided
*
key,
so
create
a
new
key-value
pair.
*/
tmp_pairs
=
realloc(bucket->pairs,
string start = 16
NUMBER OF arrows IN WORD realloc(bucket->pairs, : 1
sizeof(Pair)
*
(bucket->count
string start = 9
NUMBER OF arrows IN WORD (bucket->count : 1
+
1));
if(tmp_pairs
==
NULL)
{
/*
logError("Error:
Malloc
return
NULL,
system
out
of
memory");
*/
free(new_key);
free(value);
return
0;
}
bucket->pairs
string start = 8
NUMBER OF arrows IN WORD bucket->pairs : 1
=
tmp_pairs;
bucket->count++;
string start = 8
NUMBER OF arrows IN WORD bucket->count++; : 1
}
/*
Get
the
last
pair
in
the
chain
for
the
bucket
*/
pair
=
&(bucket->pairs[bucket->count
string start = 10
string start = 24
NUMBER OF arrows IN WORD &(bucket->pairs[bucket->count : 2
-
1]);
pair->key
string start = 6
NUMBER OF arrows IN WORD pair->key : 1
=
new_key;
pair->value
string start = 6
NUMBER OF arrows IN WORD pair->value : 1
=
value;
/*
Copy
the
key
and
its
value
into
the
key-value
pair
*/
strcpy(pair->key,
string start = 13
NUMBER OF arrows IN WORD strcpy(pair->key, : 1
key);
return
1;
}
int
getStoreValueCount(const
Store
*map)
{
unsigned
int
i,
j,
n,
m;
unsigned
int
count;
Bucket
*bucket;
Pair
*pair;
if(map
==
NULL)
{
/*
logError("Warning:
map
object
empty");
*/
return
0;
}
bucket
=
map->buckets;
string start = 5
NUMBER OF arrows IN WORD map->buckets; : 1
n
=
map->count;
string start = 5
NUMBER OF arrows IN WORD map->count; : 1
i
=
0;
count
=
0;
while(i
<
n)
{
pair
=
bucket->pairs;
string start = 8
NUMBER OF arrows IN WORD bucket->pairs; : 1
m
=
bucket->count;
string start = 8
NUMBER OF arrows IN WORD bucket->count; : 1
j
=
0;
while(j
<
m)
{
count++;
pair++;
j++;
}
bucket++;
i++;
}
return
count;
}
/*
enumerate
over
all
key
and
values
and
send
them
to
user
specified
function
*/
int
storeEnum(const
Store
*map,
sm_enum_func
enum_func,
const
void
*obj)
{
unsigned
int
i,
j,
n,
m;
Bucket
*bucket;
Pair
*pair;
if(map
==
NULL)
{
/*
logError("Warning:
map
object
empty");
*/
return
0;
}
if(enum_func
==
NULL)
{
/*
logError("Warning:
enum
funct
empty");
*/
return
0;
}
bucket
=
map->buckets;
string start = 5
NUMBER OF arrows IN WORD map->buckets; : 1
n
=
map->count;
string start = 5
NUMBER OF arrows IN WORD map->count; : 1
i
=
0;
while(i
<
n)
{
pair
=
bucket->pairs;
string start = 8
NUMBER OF arrows IN WORD bucket->pairs; : 1
m
=
bucket->count;
string start = 8
NUMBER OF arrows IN WORD bucket->count; : 1
j
=
0;
while(j
<
m)
{
enum_func(pair->key,
string start = 16
NUMBER OF arrows IN WORD enum_func(pair->key, : 1
pair->value,
string start = 6
NUMBER OF arrows IN WORD pair->value, : 1
obj);
pair++;
j++;
}
bucket++;
i++;
}
return
1;
}
static
Pair
*
get_pair(Bucket
*bucket,
const
char
*key)
{
unsigned
int
i,
n;
Pair
*pair;
n
=
bucket->count;
string start = 8
NUMBER OF arrows IN WORD bucket->count; : 1
if(n
==
0)
{
return
NULL;
}
pair
=
bucket->pairs;
string start = 8
NUMBER OF arrows IN WORD bucket->pairs; : 1
i
=
0;
while(i
<
n)
{
if(pair->key
string start = 9
NUMBER OF arrows IN WORD if(pair->key : 1
!=
NULL
&&
pair->value
string start = 6
NUMBER OF arrows IN WORD pair->value : 1
!=
NULL)
{
if(strcmp(pair->key,
string start = 16
NUMBER OF arrows IN WORD if(strcmp(pair->key, : 1
key)
==
0)
{
return
pair;
}
}
pair++;
i++;
}
return
NULL;
}
static
unsigned
long
hash(const
char
*str)
{
unsigned
long
hash
=
5381;
int
c;
while((c
=
*str++))
{
hash
=
((hash
<<
5)
+
hash)
+
c;
}
return
hash;
}
/*
GNU
LESSER
GENERAL
PUBLIC
LICENSE
Version
3,
29
June
2007
Copyright
(C)
2007
Free
Software
Foundation,
Inc.
<http://fsf.org/>
Everyone
is
permitted
to
copy
and
distribute
verbatim
copies
of
this
license
document,
but
changing
it
is
not
allowed.
This
version
of
the
GNU
Lesser
General
Public
License
incorporates
the
terms
and
conditions
of
version
3
of
the
GNU
General
Public
License,
supplemented
by
the
additional
permissions
listed
below.
0.
Additional
Definitions.
As
used
herein,
"this
License"
refers
to
version
3
of
the
GNU
Lesser
General
Public
License,
and
the
"GNU
GPL"
refers
to
version
3
of
the
GNU
General
Public
License.
"The
Library"
refers
to
a
covered
work
governed
by
this
License,
other
than
an
Application
or
a
Combined
Work
as
defined
below.
An
"Application"
is
any
work
that
makes
use
of
an
interface
provided
by
the
Library,
but
which
is
not
otherwise
based
on
the
Library.
Defining
a
subclass
of
a
class
defined
by
the
Library
is
deemed
a
mode
of
using
an
interface
provided
by
the
Library.
A
"Combined
Work"
is
a
work
produced
by
combining
or
linking
an
Application
with
the
Library.
The
particular
version
of
the
Library
with
which
the
Combined
Work
was
made
is
also
called
the
"Linked
Version".
The
"Minimal
Corresponding
Source"
for
a
Combined
Work
means
the
Corresponding
Source
for
the
Combined
Work,
excluding
any
source
code
for
portions
of
the
Combined
Work
that,
considered
in
isolation,
are
based
on
the
Application,
and
not
on
the
Linked
Version.
The
"Corresponding
Application
Code"
for
a
Combined
Work
means
the
object
code
and/or
source
code
for
the
Application,
including
any
data
and
utility
programs
needed
for
reproducing
the
Combined
Work
from
the
Application,
but
excluding
the
System
Libraries
of
the
Combined
Work.
1.
Exception
to
Section
3
of
the
GNU
GPL.
You
may
convey
a
covered
work
under
sections
3
and
4
of
this
License
without
being
bound
by
section
3
of
the
GNU
GPL.
2.
Conveying
Modified
Versions.
If
you
modify
a
copy
of
the
Library,
and,
in
your
modifications,
a
facility
refers
to
a
function
or
data
to
be
supplied
by
an
Application
that
uses
the
facility
(other
than
as
an
argument
passed
when
the
facility
is
invoked),
then
you
may
convey
a
copy
of
the
modified
version:
a)
under
this
License,
provided
that
you
make
a
good
faith
effort
to
ensure
that,
in
the
event
an
Application
does
not
supply
the
function
or
data,
the
facility
still
operates,
and
performs
whatever
part
of
its
purpose
remains
meaningful,
or
b)
under
the
GNU
GPL,
with
none
of
the
additional
permissions
of
this
License
applicable
to
that
copy.
3.
Object
Code
Incorporating
Material
from
Library
Header
Files.
The
object
code
form
of
an
Application
may
incorporate
material
from
a
header
file
that
is
part
of
the
Library.
You
may
convey
such
object
code
under
terms
of
your
choice,
provided
that,
if
the
incorporated
material
is
not
limited
to
numerical
parameters,
data
structure
layouts
and
accessors,
or
small
macros,
inline
functions
and
templates
(ten
or
fewer
lines
in
length),
you
do
both
of
the
following:
a)
Give
prominent
notice
with
each
copy
of
the
object
code
that
the
Library
is
used
in
it
and
that
the
Library
and
its
use
are
covered
by
this
License.
b)
Accompany
the
object
code
with
a
copy
of
the
GNU
GPL
and
this
license
document.
4.
Combined
Works.
You
may
convey
a
Combined
Work
under
terms
of
your
choice
that,
taken
together,
effectively
do
not
restrict
modification
of
the
portions
of
the
Library
contained
in
the
Combined
Work
and
reverse
engineering
for
debugging
such
modifications,
if
you
also
do
each
of
the
following:
a)
Give
prominent
notice
with
each
copy
of
the
Combined
Work
that
the
Library
is
used
in
it
and
that
the
Library
and
its
use
are
covered
by
this
License.
b)
Accompany
the
Combined
Work
with
a
copy
of
the
GNU
GPL
and
this
license
document.
c)
For
a
Combined
Work
that
displays
copyright
notices
during
execution,
include
the
copyright
notice
for
the
Library
among
these
notices,
as
well
as
a
reference
directing
the
user
to
the
copies
of
the
GNU
GPL
and
this
license
document.
d)
Do
one
of
the
following:
0)
Convey
the
Minimal
Corresponding
Source
under
the
terms
of
this
License,
and
the
Corresponding
Application
Code
in
a
form
suitable
for,
and
under
terms
that
permit,
the
user
to
recombine
or
relink
the
Application
with
a
modified
version
of
the
Linked
Version
to
produce
a
modified
Combined
Work,
in
the
manner
specified
by
section
6
of
the
GNU
GPL
for
conveying
Corresponding
Source.
1)
Use
a
suitable
shared
library
mechanism
for
linking
with
the
Library.
A
suitable
mechanism
is
one
that
(a)
uses
at
run
time
a
copy
of
the
Library
already
present
on
the
user's
computer
system,
and
(b)
will
operate
properly
with
a
modified
version
of
the
Library
that
is
interface-compatible
with
the
Linked
Version.
e)
Provide
Installation
Information,
but
only
if
you
would
otherwise
be
required
to
provide
such
information
under
section
6
of
the
GNU
GPL,
and
only
to
the
extent
that
such
information
is
necessary
to
install
and
execute
a
modified
version
of
the
Combined
Work
produced
by
recombining
or
relinking
the
Application
with
a
modified
version
of
the
Linked
Version.
(If
you
use
option
4d0,
the
Installation
Information
must
accompany
the
Minimal
Corresponding
Source
and
Corresponding
Application
Code.
If
you
use
option
4d1,
you
must
provide
the
Installation
Information
in
the
manner
specified
by
section
6
of
the
GNU
GPL
for
conveying
Corresponding
Source.)
5.
Combined
Libraries.
You
may
place
library
facilities
that
are
a
work
based
on
the
Library
side
by
side
in
a
single
library
together
with
other
library
facilities
that
are
not
Applications
and
are
not
covered
by
this
License,
and
convey
such
a
combined
library
under
terms
of
your
choice,
if
you
do
both
of
the
following:
a)
Accompany
the
combined
library
with
a
copy
of
the
same
work
based
on
the
Library,
uncombined
with
any
other
library
facilities,
conveyed
under
the
terms
of
this
License.
b)
Give
prominent
notice
with
the
combined
library
that
part
of
it
is
a
work
based
on
the
Library,
and
explaining
where
to
find
the
accompanying
uncombined
form
of
the
same
work.
6.
Revised
Versions
of
the
GNU
Lesser
General
Public
License.
The
Free
Software
Foundation
may
publish
revised
and/or
new
versions
of
the
GNU
Lesser
General
Public
License
from
time
to
time.
Such
new
versions
will
be
similar
in
spirit
to
the
present
version,
but
may
differ
in
detail
to
address
new
problems
or
concerns.
Each
version
is
given
a
distinguishing
version
number.
If
the
Library
as
you
received
it
specifies
that
a
certain
numbered
version
of
the
GNU
Lesser
General
Public
License
"or
any
later
version"
applies
to
it,
you
have
the
option
of
following
the
terms
and
conditions
either
of
that
published
version
or
of
any
later
version
published
by
the
Free
Software
Foundation.
If
the
Library
as
you
received
it
does
not
specify
a
version
number
of
the
GNU
Lesser
General
Public
License,
you
may
choose
any
version
of
the
GNU
Lesser
General
Public
License
ever
published
by
the
Free
Software
Foundation.
If
the
Library
as
you
received
it
specifies
that
a
proxy
can
decide
whether
future
versions
of
the
GNU
Lesser
General
Public
License
shall
apply,
that
proxy's
public
statement
of
acceptance
of
any
version
is
permanent
authorization
for
you
to
choose
that
version
for
the
Library.
*/
#include
<stdbool.h>
#include
"GEDCOMparser.h"
#include
"GEDCOMutilities.h"
#include
"LinkedListAPI.h"
#include
"hash.h"
/*
*
*/
static
inline
GEDCOMerror
parseGEDCOM(char
*
filecontents,
GEDCOMobject**
obj);
static
char*
printHeader(void*
toBePrinted);
static
char*
printSubmitter(void*
toBePrinted);
GEDCOMerror
createGEDCOM(char*
fileName,
GEDCOMobject**
obj)
{
/*
We're
using
a
mutable
function
to
remove
all
whitespace
*/
char
*
fileNameCopy
=
stringCopy(fileName);
/*
The
base
pointer
for
obj
needs
to
have
an
address
*/
if(obj
==
NULL)
{
free(fileNameCopy);
return
*obj
=
NULL,
(GEDCOMerror)
{OTHER_ERROR,
-1};
}
char
*
filecontents
=
NULL;
/*
File
name
cannot
be
an
empty
string
or
NULL
*
File
name
must
have
the
.ged
extension
(we're
using
a
more
robust
solution
that
strstr,
but
that
works
as
well)
*
File
represented
by
this
name
must
exist
and
must
be
readable
*/
if(fileNameCopy
==
NULL
||
fileName
==
NULL
||
stripWhitespace(fileNameCopy)[0]
==
'\0'
||
substringPosition(fileName,
".ged",
0)
!=
(strlen(fileName)
-
4)
||
(filecontents
=
fileGetContents(fileName))
==
NULL)
{
free(fileNameCopy);
return
*obj
=
NULL,
(GEDCOMerror)
{INV_FILE,
-1};
}
free(fileNameCopy);
GEDCOMerror
response
=
parseGEDCOM(filecontents,
obj);
free(filecontents);
return
response;
}
/*
XMACRO
with
All
GEDCOM
Tags
*/
typedef
enum
{
#define
GTAG_ENUM
\
ENUM_PAIR("",
GTAG_NO_TAG)
\
ENUM_PAIR("ABBR",
GTAG_ABBREVIATION)
\
ENUM_PAIR("ADDR",
GTAG_ADDRESS)
\
ENUM_PAIR("ADR1",
GTAG_ADDRESS1)
\
ENUM_PAIR("ADR2",
GTAG_ADDRESS2)
\
ENUM_PAIR("ADOP",
GTAG_ADOPTION)
\
ENUM_PAIR("AFN",
GTAG_AFN)
\
ENUM_PAIR("AGE",
GTAG_AGE)
\
ENUM_PAIR("AGNC",
GTAG_AGENCY)
\
ENUM_PAIR("ALIA",
GTAG_ALIAS)
\
ENUM_PAIR("ANCE",
GTAG_ANCESTORS)
\
ENUM_PAIR("ANCI",
GTAG_ANCES_INTEREST)
\
ENUM_PAIR("ANUL",
GTAG_ANNULMENT)
\
ENUM_PAIR("ASSO",
GTAG_ASSOCIATES)
\
ENUM_PAIR("AUTH",
GTAG_AUTHOR)
\
ENUM_PAIR("BAPL",
GTAG_BAPTISM_LDS)
\
ENUM_PAIR("BAPM",
GTAG_BAPTISM)
\
ENUM_PAIR("BARM",
GTAG_BAR_MITZVAH)
\
ENUM_PAIR("BASM",
GTAG_BAS_MITZVAH)
\
ENUM_PAIR("BIRT",
GTAG_BIRTH)
\
ENUM_PAIR("BLES",
GTAG_BLESSING)
\
ENUM_PAIR("BLOB",
GTAG_BINARY_OBJECT)
\
ENUM_PAIR("BURI",
GTAG_BURIAL)
\
ENUM_PAIR("CALN",
GTAG_CALL_NUMBER)
\
ENUM_PAIR("CAST",
GTAG_CASTE)
\
ENUM_PAIR("CAUS",
GTAG_CAUSE)
\
ENUM_PAIR("CENS",
GTAG_CENSUS)
\
ENUM_PAIR("CHAN",
GTAG_CHANGE)
\
ENUM_PAIR("CHAR",
GTAG_CHARACTER)
\
ENUM_PAIR("CHIL",
GTAG_CHILD)
\
ENUM_PAIR("CHR",
GTAG_CHRISTENING)
\
ENUM_PAIR("CHRA",
GTAG_ADULT_CHRISTENING)
\
ENUM_PAIR("CITY",
GTAG_CITY)
\
ENUM_PAIR("CONC",
GTAG_CONCATENATION)
\
ENUM_PAIR("CONF",
GTAG_CONFIRMATION)
\
ENUM_PAIR("CONL",
GTAG_CONFIRMATION_L)
\
ENUM_PAIR("CONT",
GTAG_CONTINUED)
\
ENUM_PAIR("COPR",
GTAG_COPYRIGHT)
\
ENUM_PAIR("CORP",
GTAG_CORPORATE)
\
ENUM_PAIR("CREM",
GTAG_CREMATION)
\
ENUM_PAIR("CTRY",
GTAG_COUNTRY)
\
ENUM_PAIR("DATA",
GTAG_DATA)
\
ENUM_PAIR("DATE",
GTAG_DATE)
\
ENUM_PAIR("DEAT",
GTAG_DEATH)
\
ENUM_PAIR("DESC",
GTAG_DESCENDANTS)
\
ENUM_PAIR("DESI",
GTAG_DESCENDANT_INT)
\
ENUM_PAIR("DEST",
GTAG_DESTINATION)
\
ENUM_PAIR("DIV",
GTAG_DIVORCE)
\
ENUM_PAIR("DIVF",
GTAG_DIVORCE_FILED)
\
ENUM_PAIR("DSCR",
GTAG_PHY_DESCRIPTION)
\
ENUM_PAIR("EDUC",
GTAG_EDUCATION)
\
ENUM_PAIR("EMAIL",
GTAG_EMAIL)
\
ENUM_PAIR("EMIG",
GTAG_EMIGRATION)
\
ENUM_PAIR("ENDL",
GTAG_ENDOWMENT)
\
ENUM_PAIR("ENGA",
GTAG_ENGAGEMENT)
\
ENUM_PAIR("EVEN",
GTAG_EVENT)
\
ENUM_PAIR("FACT",
GTAG_FACT)
\
ENUM_PAIR("FACT",
GTAG_structure)
\
ENUM_PAIR("FAM",
GTAG_FAMILY)
\
ENUM_PAIR("FAMC",
GTAG_FAMILY_CHILD)
\
ENUM_PAIR("FAMF",
GTAG_FAMILY_FILE)
\
ENUM_PAIR("FAMS",
GTAG_FAMILY_SPOUSE)
\
ENUM_PAIR("FAX",
GTAG_FAX)
\
ENUM_PAIR("FCOM",
GTAG_FIRST_COMMUNION)
\
ENUM_PAIR("FILE",
GTAG_FILE)
\
ENUM_PAIR("FONE",
GTAG_PHONETIC)
\
ENUM_PAIR("FORM",
GTAG_FORMAT)
\
ENUM_PAIR("GEDC",
GTAG_GEDCOM)
\
ENUM_PAIR("GIVN",
GTAG_GIVEN_NAME)
\
ENUM_PAIR("GRAD",
GTAG_GRADUATION)
\
ENUM_PAIR("HEAD",
GTAG_HEADER)
\
ENUM_PAIR("HUSB",
GTAG_HUSBAND)
\
ENUM_PAIR("IDNO",
GTAG_IDENT_NUMBER)
\
ENUM_PAIR("IMMI",
GTAG_IMMIGRATION)
\
ENUM_PAIR("INDI",
GTAG_INDIVIDUAL)
\
ENUM_PAIR("LANG",
GTAG_LANGUAGE)
\
ENUM_PAIR("LATI",
GTAG_LATITUDE)
\
ENUM_PAIR("LEGA",
GTAG_LEGATEE)
\
ENUM_PAIR("LONG",
GTAG_LONGITUDE)
\
ENUM_PAIR("MAP",
GTAG_MAP)
\
ENUM_PAIR("MARB",
GTAG_MARRIAGE_BANN)
\
ENUM_PAIR("MARC",
GTAG_MARR_CONTRACT)
\
ENUM_PAIR("MARL",
GTAG_MARR_LICENSE)
\
ENUM_PAIR("MARR",
GTAG_MARRIAGE)
\
ENUM_PAIR("MARS",
GTAG_MARR_SETTLEMENT)
\
ENUM_PAIR("MEDI",
GTAG_MEDIA)
\
ENUM_PAIR("NAME",
GTAG_NAME)
\
ENUM_PAIR("NATI",
GTAG_NATIONALITY)
\
ENUM_PAIR("NATU",
GTAG_NATURALIZATION)
\
ENUM_PAIR("NCHI",
GTAG_CHILDREN_COUNT)
\
ENUM_PAIR("NICK",
GTAG_NICKNAME)
\
ENUM_PAIR("NMR",
GTAG_MARRIAGE_COUNT)
\
ENUM_PAIR("NOTE",
GTAG_NOTE)
\
ENUM_PAIR("NPFX",
GTAG_NAME_PREFIX)
\
ENUM_PAIR("NSFX",
GTAG_NAME_SUFFIX)
\
ENUM_PAIR("OBJE",
GTAG_OBJECT)
\
ENUM_PAIR("OCCU",
GTAG_OCCUPATION)
\
ENUM_PAIR("ORDI",
GTAG_ORDINANCE)
\
ENUM_PAIR("ORDN",
GTAG_ORDINATION)
\
ENUM_PAIR("PAGE",
GTAG_PAGE)
\
ENUM_PAIR("PEDI",
GTAG_PEDIGREE)
\
ENUM_PAIR("PHON",
GTAG_PHONE)
\
ENUM_PAIR("PLAC",
GTAG_PLACE)
\
ENUM_PAIR("POST",
GTAG_POSTAL_CODE)
\
ENUM_PAIR("PROB",
GTAG_PROBATE)
\
ENUM_PAIR("PROP",
GTAG_PROPERTY)
\
ENUM_PAIR("PUBL",
GTAG_PUBLICATION)
\
ENUM_PAIR("QUAY",
GTAG_QUALITY_OF_DATA)
\
ENUM_PAIR("REFN",
GTAG_REFERENCE)
\
ENUM_PAIR("RELA",
GTAG_RELATIONSHIP)
\
ENUM_PAIR("RELI",
GTAG_RELIGION)
\
ENUM_PAIR("REPO",
GTAG_REPOSITORY)
\
ENUM_PAIR("RESI",
GTAG_RESIDENCE)
\
ENUM_PAIR("RESN",
GTAG_RESTRICTION)
\
ENUM_PAIR("RETI",
GTAG_RETIREMENT)
\
ENUM_PAIR("RFN",
GTAG_REC_FILE_NUMBER)
\
ENUM_PAIR("RIN",
GTAG_REC_ID_NUMBER)
\
ENUM_PAIR("ROLE",
GTAG_ROLE)
\
ENUM_PAIR("ROMN",
GTAG_ROMANIZED)
\
ENUM_PAIR("SEX",
GTAG_SEX)
\
ENUM_PAIR("SLGC",
GTAG_SEALING_CHILD)
\
ENUM_PAIR("SLGS",
GTAG_SEALING_SPOUSE)
\
ENUM_PAIR("SOUR",
GTAG_SOURCE)
\
ENUM_PAIR("SPFX",
GTAG_SURN_PREFIX)
\
ENUM_PAIR("SSN",
GTAG_SOC_SEC_NUMBER)
\
ENUM_PAIR("STAE",
GTAG_STATE)
\
ENUM_PAIR("STAT",
GTAG_STATUS)
\
ENUM_PAIR("SUBM",
GTAG_SUBMITTER)
\
ENUM_PAIR("SUBN",
GTAG_SUBMISSION)
\
ENUM_PAIR("SURN",
GTAG_SURNAME)
\
ENUM_PAIR("TEMP",
GTAG_TEMPLE)
\
ENUM_PAIR("TEXT",
GTAG_TEXT)
\
ENUM_PAIR("TIME",
GTAG_TIME)
\
ENUM_PAIR("TITL",
GTAG_TITLE)
\
ENUM_PAIR("TRLR",
GTAG_TRAILER)
\
ENUM_PAIR("TYPE",
GTAG_TYPE)
\
ENUM_PAIR("VERS",
GTAG_VERSION)
\
ENUM_PAIR("WIFE",
GTAG_WIFE)
\
ENUM_PAIR("WWW",
GTAG_WEB)
\
ENUM_PAIR("WILL",
GTAG_WILL)
\
#define
ENUM_PAIR(a,b)
b,
GTAG_ENUM
#undef
ENUM_PAIR
GTAG_SIZE
}
gTag;
/*
MACRO
with
all
valid
event
tags
*/
#define
EVENT_SET_ENUM
\
ENUM_SINGLE(GTAG_BIRTH)
\
ENUM_SINGLE(GTAG_DEATH)
\
ENUM_SINGLE(GTAG_BURIAL)
\
ENUM_SINGLE(GTAG_CREMATION)
\
ENUM_SINGLE(GTAG_CHILDREN_COUNT)
\
ENUM_SINGLE(GTAG_MARRIAGE_COUNT)
\
ENUM_SINGLE(GTAG_ADOPTION)
\
ENUM_SINGLE(GTAG_MARRIAGE)
\
ENUM_SINGLE(GTAG_DIVORCE)
\
ENUM_SINGLE(GTAG_ENGAGEMENT)
\
ENUM_SINGLE(GTAG_MARRIAGE_BANN)
\
ENUM_SINGLE(GTAG_MARR_LICENSE)
\
ENUM_SINGLE(GTAG_MARR_SETTLEMENT)
\
ENUM_SINGLE(GTAG_MARR_CONTRACT)
\
ENUM_SINGLE(GTAG_DIVORCE_FILED)
\
ENUM_SINGLE(GTAG_ANNULMENT)
\
ENUM_SINGLE(GTAG_RESIDENCE)
\
ENUM_SINGLE(GTAG_EDUCATION)
\
ENUM_SINGLE(GTAG_GRADUATION)
\
ENUM_SINGLE(GTAG_OCCUPATION)
\
ENUM_SINGLE(GTAG_RETIREMENT)
\
ENUM_SINGLE(GTAG_PHY_DESCRIPTION)
\
ENUM_SINGLE(GTAG_NATIONALITY)
\
ENUM_SINGLE(GTAG_IMMIGRATION)
\
ENUM_SINGLE(GTAG_EMIGRATION)
\
ENUM_SINGLE(GTAG_NATURALIZATION)
\
ENUM_SINGLE(GTAG_CENSUS)
\
ENUM_SINGLE(GTAG_SOC_SEC_NUMBER)
\
ENUM_SINGLE(GTAG_IDENT_NUMBER)
\
ENUM_SINGLE(GTAG_PROPERTY)
\
ENUM_SINGLE(GTAG_TITLE)
\
ENUM_SINGLE(GTAG_WILL)
\
ENUM_SINGLE(GTAG_PROBATE)
\
ENUM_SINGLE(GTAG_RELIGION)
\
ENUM_SINGLE(GTAG_CHRISTENING)
\
ENUM_SINGLE(GTAG_BAPTISM)
\
ENUM_SINGLE(GTAG_ADULT_CHRISTENING)
\
ENUM_SINGLE(GTAG_BAR_MITZVAH)
\
ENUM_SINGLE(GTAG_BAS_MITZVAH)
\
ENUM_SINGLE(GTAG_BLESSING)
\
ENUM_SINGLE(GTAG_FIRST_COMMUNION)
\
ENUM_SINGLE(GTAG_ORDINATION)
\
ENUM_SINGLE(GTAG_ORDINANCE)
\
ENUM_SINGLE(GTAG_CONFIRMATION)
\
ENUM_SINGLE(GTAG_CASTE)
\
ENUM_SINGLE(GTAG_SEALING_CHILD)
\
ENUM_SINGLE(GTAG_SEALING_SPOUSE)
\
ENUM_SINGLE(GTAG_BAPTISM_LDS)
\
ENUM_SINGLE(GTAG_CONFIRMATION_L)
\
ENUM_SINGLE(GTAG_ENDOWMENT)
\
ENUM_SINGLE(GTAG_FACT)
\
ENUM_SINGLE(GTAG_EVENT)
\
/*
Dates
x
macro
*/
#define
MONTH_ENUM
\
ENUM_PAIR("JAN",
1)
\
ENUM_PAIR("FEB",
2)
\
ENUM_PAIR("MAR",
3)
\
ENUM_PAIR("APR",
4)
\
ENUM_PAIR("MAY",
5)
\
ENUM_PAIR("JUN",
6)
\
ENUM_PAIR("JUL",
7)
\
ENUM_PAIR("AUG",
8)
\
ENUM_PAIR("SEP",
9)
\
ENUM_PAIR("OCT",
10)
\
ENUM_PAIR("NOV",
11)
\
ENUM_PAIR("DEC",
12)
\
/*
XMACRO
Mapping
String
CHAR
type
to
ENUM
*/
#define
CHAR_SET_ENUM
\
ENUM_PAIR("ANSEL",
ANSEL)
\
ENUM_PAIR("UTF-8",
UTF8)
\
ENUM_PAIR("UNICODE",
UNICODE)
\
ENUM_PAIR("ASCII",
ASCII)
\
static
CharSet
getCharSet(const
char
*
const
key)
{
if(key
==
NULL)
{
return
0;
}
#define
ENUM_PAIR(a,b)
if(strcmp(key,
a)
==
0)
return
b;
CHAR_SET_ENUM
#undef
ENUM_PAIR
return
0;
}
/*
Not
needed
in
current
implementation
static
int
getMonthFromString(const
char
*
const
key)
{
if(key
==
NULL)
{
return
0;
}
#define
ENUM_PAIR(a,b)
if(strcmp(key,
a)
==
0)
return
b;
MONTH_ENUM
#undef
ENUM_PAIR
return
0;
}*/
static
int
validCharSet(const
char
*
const
key)
{
if(key
==
NULL)
{
return
0;
}
#define
ENUM_PAIR(a,b)
if(strcmp(key,
a)
==
0)
return
1;
CHAR_SET_ENUM
#undef
ENUM_PAIR
return
0;
}
static
gTag
getgTag(const
char
*
const
key)
{
if(key
==
NULL)
{
return
0;
}
#define
ENUM_PAIR(a,b)
if(strcmp(key,
a)
==
0)
return
b;
GTAG_ENUM
#undef
ENUM_PAIR
return
0;
}
static
char
*
getStringFromgTag(const
gTag
tag)
{
#define
ENUM_PAIR(a,b)
if(tag
==
b)
return
a;
GTAG_ENUM
#undef
ENUM_PAIR
return
NULL;
}
static
int
isReference(const
char
*
const
key)
{
if(key
==
NULL)
{
return
0;
}
size_t
keyLength
=
strlen(key);
if(keyLength
<
3)
{
return
0;
}
/*
Don't
check
characters
inside
pointer,
not
contents
matter
*/
if(key[0]
!=
'@'
||
key[keyLength
-
1]
!=
'@')
{
return
0;
}
return
1;
}
static
void
deleteDummy(void*
toBeDeleted)
{
(void)toBeDeleted;
}
#define
GEDCOM_DELIMITER
'
'
#define
GEDCOM_NEWLINE
'\n'
#define
GEDCOM_REPLACE_NEWLINE
'\r'
#define
GEDCOM_MAX_LINE_LENGTH
255
#define
RECORD_HEADER_OR_INV
(i
==
0)
?
INV_HEADER
:
INV_RECORD
static
inline
GEDCOMerror
parseGEDCOM(char
*
filecontents,
GEDCOMobject
**
obj)
{
char
**
lines
=
NULL;
char
**
tokens
=
NULL;
char
*
values
=
NULL;
/*
i
is
for
lines,
j
is
for
tokens
in
a
line
*/
int
i
=
0;
int
j
=
0;
int
level
=
0;
int
previousLevel
=
0;
int
lastEventLevel
=
0;
int
hasEncoding
=
0;
int
hasSubmitter
=
0;
/*
The
last
0-level
tag
/
object
(the
main
record)
*/
gTag
parentTag
=
GTAG_NO_TAG;
void
*
parentObject
=
NULL;
/*
Current
Tag
/
Object
being
worked
on
*/
gTag
currentTag
=
GTAG_NO_TAG;
void
*
currentObject
=
NULL;
/*
Last
tag
/
object
in
the
previous
level
(useful
for
events
which
are
nested
in
parent
records,
and
have
sub
values
*/
gTag
lastEventTag
=
GTAG_NO_TAG;
void
*
lastEventObject
=
NULL;
/*
Filled
with
a
5
character
reference
if
one
exists
in
a
given
line
*/
char
*
reference
=
NULL;
/*
Hashmap
with
pointers
(char
5)
mapping
to
void
pointers
*/
Store
*
referenceStore
=
createStore();
Store
*
referencePlaceStore
=
createStore();
/*
Remove
all
return
carriages
in
favour
of
newlines
*/
filecontents
=
replaceStringCharacter(filecontents,
GEDCOM_REPLACE_NEWLINE,
GEDCOM_NEWLINE);
/*
Tokenize
the
file
contents
by
line
*/
lines
=
tokenCreate(filecontents,
GEDCOM_NEWLINE,
0,
0);
/*
GEDCOM
must
have
at
least
1
header,
1
submitter,
1
trailing,
and
1
record
*/
if(tokenCount(lines)
<
4)
{
return
freeStore(referencePlaceStore),
freeStore(referenceStore),
*obj
=
NULL,
tokenFree(lines),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
i
+
1};
}
*obj
=
calloc(sizeof(GEDCOMobject),
1);
(*obj)->header
string start = 8
NUMBER OF arrows IN WORD (*obj)->header : 1
=
NULL;
(*obj)->submitter
string start = 8
NUMBER OF arrows IN WORD (*obj)->submitter : 1
=
NULL;
(*obj)->families
string start = 8
NUMBER OF arrows IN WORD (*obj)->families : 1
=
initializeList(&printFamily,
&deleteFamily,
&compareFamilies);
(*obj)->individuals
string start = 8
NUMBER OF arrows IN WORD (*obj)->individuals : 1
=
initializeList(&printIndividual,
&deleteIndividual,
&compareIndividuals);
while(lines[i]
!=
NULL)
{
tokens
=
tokenCreate(lines[i],
GEDCOM_DELIMITER,
1,
0);
if(strlen(lines[i])
>
GEDCOM_MAX_LINE_LENGTH)
{
return
freeStore(referencePlaceStore),
freeStore(referenceStore),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
i
+
1};
}
j
=
0;
previousLevel
=
level;
currentObject
=
NULL;
currentTag
=
GTAG_NO_TAG;
while(tokens[j]
!=
NULL)
{
const
size_t
preStripTokenLength
=
strlen(tokens[j]);
/*
Remove
all
tabs,
other
whitespace
are
removed
already
*/
stripWhitespace(tokens[j]);
/*
`level
+
delim
+
[optional_xref_ID]
+
tag
+
[optional_line_value]
+
terminator`
*/
/*
First
element
must
be
a
digit
*/
if(j
==
0)
{
/*
Must
be
between
`0
to
99`,
must
not
contain
leading
zeroes
`0`
*
Each
new
**level
number**
must
be
**no
higher**
than
the
previous
line
plus
`1`
*
No
leading
whitespace
*/
if(stringIsDigit(tokens[j],
1,
strlen(tokens[j]))
&&
strlen(tokens[j])
<=
2
&&
atoi(tokens[j])
<=
(previousLevel
+
1)
&&
strlen(tokens[j])
==
preStripTokenLength)
{
level
=
atoi(tokens[j]);
}
else
{
return
freeStore(referencePlaceStore),
freeStore(referenceStore),
free(values),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
i
+
1};
}
/*
Unset
events
after
get
back
to
their
level
*/
if(level
<=
lastEventLevel)
{
lastEventTag
=
GTAG_NO_TAG;
lastEventObject
=
NULL;
lastEventLevel
=
0;
}
j++;
continue;
}
/*
If
the
second
token
is
a
pointer,
add
to
the
hashmap
*/
reference
=
NULL;
if(isReference(tokens[j]))
{
reference
=
tokens[j];
j++;
}
/*
Get
the
GEDCOM
tag
equivalent,
must
be
non-zero
*/
currentTag
=
getgTag(tokens[j]);
/*
Header
must
be
at
line
0
*/
if(i
==
0
&&
currentTag
!=
GTAG_HEADER)
{
return
freeStore(referencePlaceStore),
freeStore(referenceStore),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{INV_GEDCOM,
-1};
}
/*
Last
record
must
be
TRAILER
*/
if(i
+
1
==
tokenCount(lines)
&&
currentTag
!=
GTAG_TRAILER)
{
return
freeStore(referencePlaceStore),
freeStore(referenceStore),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{INV_GEDCOM,
-1};
}
/*
Only
accept
these
4
at
level
0
*/
if((currentTag
==
GTAG_INDIVIDUAL
||
currentTag
==
GTAG_HEADER
||
currentTag
==
GTAG_TRAILER)
&&
level
!=
0)
{
return
freeStore(referencePlaceStore),
freeStore(referenceStore),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
i
+
1};
}
/*
Get
the
values
after
the
tag
*/
values
=
calloc(sizeof(char),
1);
if(tokens[j+1]
!=
NULL)
{
j++;
while(tokens[j]
!=
NULL)
{
values
=
stringConcatenation(values,
tokens[j],
GEDCOM_DELIMITER);
j++;
}
j--;
}
/*
Check
for
CONT
or
CONC
tags
using
a
look
ahead
loop*/
int
k
=
i
+
1;
while(lines[k]
!=
NULL)
{
char
**
linePieces
=
tokenCreate(lines[k],
GEDCOM_DELIMITER,
0,
0);
int
l
=
2;
if(linePieces
==
NULL
||
linePieces[0][0]
==
'\0')
{
tokenFree(linePieces);
break;
}
/*
Line
invalid
GEDCOM
*/
if(tokenCount(linePieces)
<
2)
{
return
tokenFree(linePieces),
freeStore(referencePlaceStore),
freeStore(referenceStore),
free(values),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
k
+
1};
}
stripWhitespace(linePieces[0]);
/*
Check
that
first
token
is
a
valid
GEDCOM
level
*/
if(!stringIsDigit(linePieces[0],
1,
strlen(linePieces[0]))
||
strlen(linePieces[0])
>
2
||
atoi(linePieces[0])
>
(level
+
1))
{
return
tokenFree(linePieces),
freeStore(referencePlaceStore),
freeStore(referenceStore),
free(values),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
k
+
1};
}
stripWhitespace(linePieces[1]);
if(getgTag(linePieces[1])
==
GTAG_CONCATENATION)
{
if(strlen(values)
+
2
>
GEDCOM_MAX_LINE_LENGTH)
{
return
tokenFree(linePieces),
freeStore(referencePlaceStore),
freeStore(referenceStore),
free(values),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
k
+
1};
}
values
=
stringConcatenation(values,
"
\n",
'\0');
while(linePieces[l]
!=
NULL)
{
/*
Adding
the
token
to
the
values
array
is
too
big
for
GEDCOM
line
*/
if(strlen(values)
+
strlen(linePieces[l])
>
GEDCOM_MAX_LINE_LENGTH)
{
return
tokenFree(linePieces),
freeStore(referencePlaceStore),
freeStore(referenceStore),
free(values),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
k
+
1};
}
values
=
stringConcatenation(values,
linePieces[l],
GEDCOM_DELIMITER);
l++;
}
tokenFree(linePieces);
}
else
if(getgTag(linePieces[1])
==
GTAG_CONTINUED)
{
while(linePieces[l]
!=
NULL)
{
/*
Adding
the
token
to
the
values
array
is
too
big
for
GEDCOM
line
*/
if(strlen(values)
+
strlen(linePieces[l])
>
GEDCOM_MAX_LINE_LENGTH)
{
return
tokenFree(linePieces),
freeStore(referencePlaceStore),
freeStore(referenceStore),
free(values),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
k
+
1};
}
values
=
stringConcatenation(values,
linePieces[l],
'\0');
l++;
}
tokenFree(linePieces);
}
else
{
tokenFree(linePieces);
break;
}
k++;
}
i
=
k
-
1;
/*
GEDCOM
exceeds
256
characters
*/
if(strlen(values)
>
GEDCOM_MAX_LINE_LENGTH)
{
free(values);
break;
}
if(level
==
0)
{
if(currentTag
==
GTAG_HEADER)
{
currentObject
=
calloc(sizeof(Header),
1);
((Header
*)
currentObject)->submitter
string start = 16
NUMBER OF arrows IN WORD currentObject)->submitter : 1
=
NULL;
((Header
*)
currentObject)->otherFields
string start = 16
NUMBER OF arrows IN WORD currentObject)->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
(*obj)->header
string start = 8
NUMBER OF arrows IN WORD (*obj)->header : 1
=
currentObject;
}
/*
Last
line
must
be
the
trailer
tag
*/
else
if(currentTag
==
GTAG_TRAILER)
{
free(values);
break;
}
else
if(currentTag
==
GTAG_SUBMITTER)
{
currentObject
=
calloc(sizeof(Submitter)
+
(255
*
sizeof(char)),
1);
((Submitter
*)
currentObject)->otherFields
string start = 16
NUMBER OF arrows IN WORD currentObject)->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
(*obj)->submitter
string start = 8
NUMBER OF arrows IN WORD (*obj)->submitter : 1
=
currentObject;
(*obj)->header->submitter
string start = 8
string start = 16
NUMBER OF arrows IN WORD (*obj)->header->submitter : 2
=
currentObject;
}
else
if(currentTag
==
GTAG_FAMILY)
{
currentObject
=
calloc(sizeof(Family),
1);
((Family
*)
currentObject)->wife
string start = 16
NUMBER OF arrows IN WORD currentObject)->wife : 1
=
NULL;
((Family
*)
currentObject)->husband
string start = 16
NUMBER OF arrows IN WORD currentObject)->husband : 1
=
NULL;
((Family
*)
currentObject)->children=
string start = 16
NUMBER OF arrows IN WORD currentObject)->children= : 1
initializeList(&printIndividual,
&deleteDummy,
&compareIndividuals);
((Family
*)
currentObject)->events=
string start = 16
NUMBER OF arrows IN WORD currentObject)->events= : 1
initializeList(&printEvent,
&deleteEvent,
&compareEvents);
((Family
*)
currentObject)->otherFields=
string start = 16
NUMBER OF arrows IN WORD currentObject)->otherFields= : 1
initializeList(&printField,
&deleteField,
&compareFields);
insertBack(&((*obj)->families),
string start = 21
NUMBER OF arrows IN WORD insertBack(&((*obj)->families), : 1
(void*)currentObject);
/*
Add
reference
if
exists
-
Note:
No
reference
validation
(requires
another
hashmap)
such
as
if
hashmap->value
string start = 9
NUMBER OF arrows IN WORD hashmap->value : 1
is
the
actual
tag
being
referenced*/
addStoreValue(referenceStore,
reference,
(void
*)currentObject);
}
else
if(currentTag
==
GTAG_INDIVIDUAL)
{
currentObject
=
calloc(sizeof(Individual),
1);
((Individual
*)
currentObject)->givenName
string start = 16
NUMBER OF arrows IN WORD currentObject)->givenName : 1
=
calloc(sizeof(char),
1);
((Individual
*)
currentObject)->surname
string start = 16
NUMBER OF arrows IN WORD currentObject)->surname : 1
=
calloc(sizeof(char),
1);
((Individual
*)
currentObject)->events=
string start = 16
NUMBER OF arrows IN WORD currentObject)->events= : 1
initializeList(&printEvent,
&deleteEvent,
&compareEvents);
((Individual
*)
currentObject)->families=
string start = 16
NUMBER OF arrows IN WORD currentObject)->families= : 1
initializeList(&printFamily,
&deleteDummy,
&compareFamilies);
((Individual
*)
currentObject)->otherFields=
string start = 16
NUMBER OF arrows IN WORD currentObject)->otherFields= : 1
initializeList(&printField,
&deleteField,
&compareFields);
insertBack(&((*obj)->individuals),
string start = 21
NUMBER OF arrows IN WORD insertBack(&((*obj)->individuals), : 1
(void*)currentObject);
/*
Add
reference
if
exists
*/
addStoreValue(referenceStore,
reference,
(void
*)currentObject);
}
else
if(currentTag
==
GTAG_NO_TAG)
{
if(level
==
0)
{
free(values);
break;
}
}
else
{
return
freeStore(referencePlaceStore),
freeStore(referenceStore),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
i
+
1};
}
}
else
if(parentTag
==
GTAG_HEADER)
{
if(currentTag
==
GTAG_SOURCE)
{
strncpy(((Header*
)
parentObject)->source,
string start = 15
NUMBER OF arrows IN WORD parentObject)->source, : 1
values,
strlen(values));
}
else
if(currentTag
==
GTAG_VERSION)
{
((Header*
)
parentObject)->gedcVersion
string start = 15
NUMBER OF arrows IN WORD parentObject)->gedcVersion : 1
=
atof(values);
}
else
if(currentTag
==
GTAG_SUBMITTER)
{
hasSubmitter
=
1;
}
else
if(currentTag
==
GTAG_CHARACTER)
{
if(!validCharSet(values))
{
return
freeStore(referencePlaceStore),
freeStore(referenceStore),
free(values),
deleteGEDCOM(*obj),
(*obj
=
NULL),
tokenFree(lines),
tokenFree(tokens),
(GEDCOMerror)
{RECORD_HEADER_OR_INV,
i
+
1};
}
((Header*
)
parentObject)->encoding
string start = 15
NUMBER OF arrows IN WORD parentObject)->encoding : 1
=
getCharSet(values);
hasEncoding
=
1;
}
/*
Generic
Field
*/
else
{
Field
*
otherField
=
calloc(sizeof(Field),
1);
otherField->tag
string start = 12
NUMBER OF arrows IN WORD otherField->tag : 1
=
stringCopy(getStringFromgTag(currentTag));
otherField->value
string start = 12
NUMBER OF arrows IN WORD otherField->value : 1
=
stringCopy(values);
insertBack(&(((Header
*)
parentObject)->otherFields),
string start = 15
NUMBER OF arrows IN WORD parentObject)->otherFields), : 1
(void*)otherField);
}
}
/*
Children
Tags
*/
else
if(currentTag
==
GTAG_SUBMITTER)
{
//
Do
nothing
}
else
if(parentTag
==
GTAG_SUBMITTER)
{
if(currentTag
==
GTAG_NAME)
{
strncpy(((Submitter*
)
parentObject)->submitterName,
string start = 15
NUMBER OF arrows IN WORD parentObject)->submitterName, : 1
values,
60);
}
else
if(currentTag
==
GTAG_ADDRESS)
{
strcpy(((Submitter*
)
parentObject)->address,
string start = 15
NUMBER OF arrows IN WORD parentObject)->address, : 1
values);
}
/*
Generic
Field
*/
else
{
Field
*
otherField
=
calloc(sizeof(Field),
1);
otherField->tag
string start = 12
NUMBER OF arrows IN WORD otherField->tag : 1
=
stringCopy(getStringFromgTag(currentTag));
otherField->value
string start = 12
NUMBER OF arrows IN WORD otherField->value : 1
=
stringCopy(values);
insertBack(&(((Submitter
*)
parentObject)->otherFields),
string start = 15
NUMBER OF arrows IN WORD parentObject)->otherFields), : 1
(void*)otherField);
}
}
else
if(parentTag
==
GTAG_INDIVIDUAL)
{
#define
ENUM_SINGLE(a)
lastEventTag
==
a
||
if(EVENT_SET_ENUM
0)
#undef
ENUM_SINGLE
{
/*
There
are
A
LOT
of
possible
ways
to
do
dates,
we'll
do
the
most
common
(CALENDAR_ESCAPE_CHARACTER
is
a
nightmare)
*/
if(currentTag
==
GTAG_DATE)
{
char
**
datePieces
=
tokenCreate(values,
GEDCOM_DELIMITER,
0,
0);
/*
[4
DATE
BEF
1
JAN
1900]
*/
if(tokenCount(datePieces)
==
4)
{
/*
Forget
the
BEF,
AFT
tags...
*/
free(((Event
*)
lastEventObject)->date);
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->date); : 1
((Event
*)
lastEventObject)->date
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->date : 1
=
stringCopy(values
+
3);
}
/*
[4
DATE
31
DEC
1900]
*/
else
if(tokenCount(datePieces)
==
3)
{
free(((Event
*)
lastEventObject)->date);
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->date); : 1
((Event
*)
lastEventObject)->date
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->date : 1
=
stringCopy(values);
}
tokenFree(datePieces);
}
else
if(currentTag
==
GTAG_PLACE)
{
free(((Event
*)
lastEventObject)->place);
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->place); : 1
((Event
*)
lastEventObject)->place
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->place : 1
=
stringCopy(values);
}
else
{
Field
*
otherField
=
calloc(sizeof(Field),
1);
otherField->tag
string start = 12
NUMBER OF arrows IN WORD otherField->tag : 1
=
stringCopy(getStringFromgTag(currentTag));
otherField->value
string start = 12
NUMBER OF arrows IN WORD otherField->value : 1
=
stringCopy(values);
insertBack(&(((Event
*)
lastEventObject)->otherFields),
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->otherFields), : 1
(void*)otherField);
}
}
/*
Found
an
event
*/
#define
ENUM_SINGLE(a)
currentTag
==
a
||
else
if(EVENT_SET_ENUM
0)
#undef
ENUM_SINGLE
{
if(isReference(values))
{
/*
Note:
Does
not
check
if
is
valid
child
(and
not
some
other
reference...)
*/
currentObject
=
getStoreValue(referenceStore,
values);
}
else
{
currentObject
=
calloc(sizeof(Event),
1);
strncpy(((Event
*)
currentObject)->type,
string start = 16
NUMBER OF arrows IN WORD currentObject)->type, : 1
getStringFromgTag(currentTag),
4);
((Event
*)
currentObject)->date
string start = 16
NUMBER OF arrows IN WORD currentObject)->date : 1
=
calloc(sizeof(char),
1);
((Event
*)
currentObject)->place
string start = 16
NUMBER OF arrows IN WORD currentObject)->place : 1
=
calloc(sizeof(char),
1);
((Event
*)
currentObject)->otherFields
string start = 16
NUMBER OF arrows IN WORD currentObject)->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
/*
Set
last
level
reference
*/
lastEventObject
=
currentObject;
lastEventTag
=
currentTag;
lastEventLevel
=
level;
}
insertBack(&(((Individual
*)
parentObject)->events),
string start = 15
NUMBER OF arrows IN WORD parentObject)->events), : 1
currentObject);
}
else
if(currentTag
==
GTAG_FAMILY
||
currentTag
==
GTAG_FAMILY_CHILD
||
currentTag
==
GTAG_FAMILY_FILE
||
currentTag
==
GTAG_FAMILY_SPOUSE)
{
if(isReference(values))
{
/*
Note:
Does
not
check
if
is
valid
child
(and
not
some
other
reference...)
*/
currentObject
=
getStoreValue(referenceStore,
values);
insertBack(&(((Individual
*)
parentObject)->families),
string start = 15
NUMBER OF arrows IN WORD parentObject)->families), : 1
(void*)currentObject);
addStoreValue(referencePlaceStore,
integerToASCII(i),
(void
*)parentObject);
}
}
else
if(currentTag
==
GTAG_NAME)
{
char
**
namePieces
=
tokenCreate(values,
GEDCOM_DELIMITER,
0,
0);
if(tokenCount(namePieces)
==
2)
{
free(((Individual
*)
parentObject)->givenName);
string start = 15
NUMBER OF arrows IN WORD parentObject)->givenName); : 1
free(((Individual
*)
parentObject)->surname);
string start = 15
NUMBER OF arrows IN WORD parentObject)->surname); : 1
((Individual
*)
parentObject)->givenName
string start = 15
NUMBER OF arrows IN WORD parentObject)->givenName : 1
=
stringCopy(namePieces[0]);
namePieces[1][strlen(namePieces[1])
-
1]
=
'\0';
((Individual
*)
parentObject)->surname
string start = 15
NUMBER OF arrows IN WORD parentObject)->surname : 1
=
stringCopy(namePieces[1]
+
1);
}
tokenFree(namePieces);
}
else
if(currentTag
==
GTAG_GIVEN_NAME)
{
free(((Individual
*)
parentObject)->givenName);
string start = 15
NUMBER OF arrows IN WORD parentObject)->givenName); : 1
((Individual
*)
parentObject)->givenName
string start = 15
NUMBER OF arrows IN WORD parentObject)->givenName : 1
=
stringCopy(values);
}
else
if(currentTag
==
GTAG_SURNAME)
{
free(((Individual
*)
parentObject)->surname);
string start = 15
NUMBER OF arrows IN WORD parentObject)->surname); : 1
((Individual
*)
parentObject)->surname
string start = 15
NUMBER OF arrows IN WORD parentObject)->surname : 1
=
stringCopy(values);
}
/*
Generic
Field
*/
else
{
Field
*
otherField
=
calloc(sizeof(Field),
1);
otherField->tag
string start = 12
NUMBER OF arrows IN WORD otherField->tag : 1
=
stringCopy(getStringFromgTag(currentTag));
otherField->value
string start = 12
NUMBER OF arrows IN WORD otherField->value : 1
=
stringCopy(values);
insertBack(&(((Family
*)
parentObject)->otherFields),
string start = 15
NUMBER OF arrows IN WORD parentObject)->otherFields), : 1
(void*)otherField);
}
}
else
if(parentTag
==
GTAG_FAMILY)
{
#define
ENUM_SINGLE(a)
lastEventTag
==
a
||
if(EVENT_SET_ENUM
0)
#undef
ENUM_SINGLE
{
/*
There
are
A
LOT
of
possible
ways
to
do
dates,
we'll
do
the
most
common
(CALENDAR_ESCAPE_CHARACTER
is
a
nightmare)
*/
if(currentTag
==
GTAG_DATE)
{
char
**
datePieces
=
tokenCreate(values,
GEDCOM_DELIMITER,
0,
0);
/*
[4
DATE
BEF
1
JAN
1900]
*/
if(tokenCount(datePieces)
==
4)
{
/*
Forget
the
BEF,
AFT
tags...
*/
free(((Event
*)
lastEventObject)->date);
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->date); : 1
((Event
*)
lastEventObject)->date
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->date : 1
=
stringCopy(values
+
3);
}
/*
[4
DATE
31
DEC
1900]
*/
else
if(tokenCount(datePieces)
==
3)
{
free(((Event
*)
lastEventObject)->date);
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->date); : 1
((Event
*)
lastEventObject)->date
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->date : 1
=
stringCopy(values);
}
tokenFree(datePieces);
}
else
if(currentTag
==
GTAG_PLACE)
{
free(((Event
*)
lastEventObject)->place);
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->place); : 1
((Event
*)
lastEventObject)->place
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->place : 1
=
stringCopy(values);
}
else
{
Field
*
otherField
=
calloc(sizeof(Field),
1);
otherField->tag
string start = 12
NUMBER OF arrows IN WORD otherField->tag : 1
=
stringCopy(getStringFromgTag(currentTag));
otherField->value
string start = 12
NUMBER OF arrows IN WORD otherField->value : 1
=
stringCopy(values);
insertBack(&(((Event
*)
lastEventObject)->otherFields),
string start = 18
NUMBER OF arrows IN WORD lastEventObject)->otherFields), : 1
(void*)otherField);
}
}
/*
Found
an
event
*/
#define
ENUM_SINGLE(a)
currentTag
==
a
||
else
if(EVENT_SET_ENUM
0)
#undef
ENUM_SINGLE
{
currentObject
=
calloc(sizeof(Event),
1);
strncpy(((Event
*)
currentObject)->type,
string start = 16
NUMBER OF arrows IN WORD currentObject)->type, : 1
getStringFromgTag(currentTag),
4);
((Event
*)
currentObject)->date
string start = 16
NUMBER OF arrows IN WORD currentObject)->date : 1
=
calloc(sizeof(char),
1);
((Event
*)
currentObject)->place
string start = 16
NUMBER OF arrows IN WORD currentObject)->place : 1
=
calloc(sizeof(char),
1);
((Event
*)
currentObject)->otherFields
string start = 16
NUMBER OF arrows IN WORD currentObject)->otherFields : 1
=
initializeList(&printField,
&deleteField,
&compareFields);
/*
Set
last
level
reference
*/
lastEventObject
=
currentObject;
lastEventTag
=
currentTag;
lastEventLevel
=
level;
insertBack(&(((Family
*)
parentObject)->events),
string start = 15
NUMBER OF arrows IN WORD parentObject)->events), : 1
currentObject);
}
/*
Not
allow
individuals
or
family
to
be
created
nested,
thus
this
must
be
a
reference
*/
else
if(currentTag
==
GTAG_WIFE)
{
/*
Cannot
create
individuals
from
within
a
family
*/
if(isReference(values))
{
((Family
*)
parentObject)->wife
string start = 15
NUMBER OF arrows IN WORD parentObject)->wife : 1
=
getStoreValue(referenceStore,
values);
addStoreValue(referencePlaceStore,
integerToASCII(i),
(void
*)parentObject);
}
}
else
if(currentTag
==
GTAG_HUSBAND)
{
/*
Cannot
create
individuals
from
within
a
family
*/
if(isReference(values))
{
((Family
*)
parentObject)->husband
string start = 15
NUMBER OF arrows IN WORD parentObject)->husband : 1
=
getStoreValue(referenceStore,
values);
addStoreValue(referencePlaceStore,
integerToASCII(i),
(void
*)parentObject);
}
}
else
if(currentTag
==
GTAG_CHILD)
{
/*
Cannot
create
individuals
from
within
a
family
*/
if(isReference(values))
{
addStoreValue(referencePlaceStore,
integerToASCII(i),
(void
*)parentObject);
}
}
/*
Generic
Field
*/
else
{
Field
*
otherField
=
calloc(sizeof(Field),
1);
otherField->tag
string start = 12
NUMBER OF arrows IN WORD otherField->tag : 1
=
stringCopy(getStringFromgTag(currentTag));
otherField->value
string start = 12
NUMBER OF arrows IN WORD otherField->value : 1
=
stringCopy(values);
insertBack(&(((Family
*)
parentObject)->otherFields),
string start = 15
NUMBER OF arrows IN WORD parentObject)->otherFields), : 1
(void*)otherField);
}
}
/*
Set
the
parentObject
reference
*/
if(level
==
0)
{
parentObject
=
currentObject;
parentTag
=
currentTag;
}
free(values);
j++;
}
tokenFree(tokens);
i++;
currentTag
=
GTAG_NO_TAG;
}
/*
Recurse
and
get
match
all
the
other
missing
references
*/
i
=
0;
while(lines[i]
!=
NULL)
{
tokens
=
tokenCreate(lines[i],
GEDCOM_DELIMITER,
0,
0);
j
=
0;
previousLevel
=
level;
currentObject
=
NULL;
currentTag
=
GTAG_NO_TAG;
while(tokens[j]
!=
NULL)
{
/*
Remove
all
tabs,
other
whitespace
are
removed
already
*/
stripWhitespace(tokens[j]);
/*
`level
+
delim
+
[optional_xref_ID]
+
tag
+
[optional_line_value]
+
terminator`
*/
/*
First
element
must
be
a
digit
*/
if(j
==
0)
{
level
=
atoi(tokens[j]);
j++;
continue;
}
/*
If
the
second
token
is
a
pointer,
add
to
the
hashmap
*/
reference
=
NULL;
if(isReference(tokens[j]))
{
reference
=
tokens[j];
j++;
}
/*
Get
the
GEDCOM
tag
equivalent,
must
be
non-zero
*/
currentTag
=
getgTag(tokens[j]);
/*
Get
the
values
after
the
tag
*/
values
=
calloc(sizeof(char),
1);
if(tokens[j+1]
!=
NULL)
{
j++;
while(tokens[j]
!=
NULL)
{
values
=
stringConcatenation(values,
tokens[j],
GEDCOM_DELIMITER);
j++;
}
j--;
}
if(level
==
0)
{
/*
Last
line
must
be
the
trailer
tag
*/
if(currentTag
==
GTAG_TRAILER)
{
free(values);
break;
}
}
if(parentTag
==
GTAG_INDIVIDUAL)
{
if(currentTag
==
GTAG_FAMILY
||
currentTag
==
GTAG_FAMILY_CHILD
||
currentTag
==
GTAG_FAMILY_FILE
||
currentTag
==
GTAG_FAMILY_SPOUSE)
{
if(isReference(values))
{
/*
Note:
Does
not
check
if
is
valid
child
(and
not
some
other
reference...)
*/
parentObject
=
getStoreValue(referencePlaceStore,
integerToASCII(i));
currentObject
=
getStoreValue(referenceStore,
values);
insertBack(&(((Individual
*)
parentObject)->families),
string start = 15
NUMBER OF arrows IN WORD parentObject)->families), : 1
(void*)currentObject);
}
}
}
else
if(parentTag
==
GTAG_FAMILY)
{
/*
Not
allow
individuals
or
family
to
be
created
nested,
thus
this
must
be
a
reference
*/
if(currentTag
==
GTAG_WIFE)
{
/*
Cannot
create
individuals
from
within
a
family
*/
if(isReference(values))
{
parentObject
=
getStoreValue(referencePlaceStore,
integerToASCII(i));
((Family
*)
parentObject)->wife
string start = 15
NUMBER OF arrows IN WORD parentObject)->wife : 1
=
getStoreValue(referenceStore,
values);
}
}
else
if(currentTag
==
GTAG_HUSBAND)
{
/*
Cannot
create
individuals
from
within
a
family
*/
if(isReference(values))
{
parentObject
=
getStoreValue(referencePlaceStore,
integerToASCII(i));
((Family
*)
parentObject)->husband
string start = 15
NUMBER OF arrows IN WORD parentObject)->husband : 1
=
getStoreValue(referenceStore,
values);
addStoreValue(referencePlaceStore,
integerToASCII(i),
(void
*)parentObject);
}
}
else
if(currentTag
==
GTAG_CHILD)
{
/*
Cannot
create
individuals
from
within
a
family
*/
if(isReference(values))
{
parentObject
=
getStoreValue(referencePlaceStore,
integerToASCII(i));
insertBack(&(((Family
*)
parentObject)->children),
string start = 15
NUMBER OF arrows IN WORD parentObject)->children), : 1
(void*)getStoreValue(referenceStore,
values));
}
}
}
/*
Set
the
parentObject
reference
*/
if(level
==
0)
{
parentTag
=
currentTag;
}
free(values);
j++;
}
tokenFree(tokens);
i++;
currentTag
=
GTAG_NO_TAG;
}
tokenFree(lines);
freeStore(referenceStore);
freeStore(referencePlaceStore);
//
Check
any
irregularities
with
our
defined
records
if((*obj)->submitter
string start = 11
NUMBER OF arrows IN WORD if((*obj)->submitter : 1
==
NULL)
{
return
deleteGEDCOM(*obj),
(*obj
=
NULL),
(GEDCOMerror)
{INV_GEDCOM,
-1};
}
else
if(((*obj)->header)->source[0]
string start = 12
string start = 21
NUMBER OF arrows IN WORD if(((*obj)->header)->source[0] : 2
==
'\0')
{
return
deleteGEDCOM(*obj),
(*obj
=
NULL),
(GEDCOMerror)
{INV_HEADER,
1};
}
else
if(((*obj)->header)->gedcVersion
string start = 12
string start = 21
NUMBER OF arrows IN WORD if(((*obj)->header)->gedcVersion : 2
<
1.0)
{
return
deleteGEDCOM(*obj),
(*obj
=
NULL),
(GEDCOMerror)
{INV_HEADER,
1};
}
else
if(!hasEncoding)
{
return
deleteGEDCOM(*obj),
(*obj
=
NULL),
(GEDCOMerror)
{INV_HEADER,
1};
}
else
if(!hasSubmitter)
{
return
deleteGEDCOM(*obj),
(*obj
=
NULL),
(GEDCOMerror)
{INV_HEADER,
1};
}
else
{
return
(GEDCOMerror)
{OK,
-1};
}
}
static
char*
printHeader(void*
toBePrinted)
{
if(toBePrinted
==
NULL)
{
return
NULL;
}
Header
*
header
=
(Header
*)
toBePrinted;
char
*
contents
=
NULL;
void
*
elem
=
NULL;
char
*
print
=
NULL;
contents
=
stringConcatenation(contents,
"Header
Source:
",
'\0');
contents
=
stringConcatenation(contents,
header->source,
string start = 8
NUMBER OF arrows IN WORD header->source, : 1
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"GEDCOM
Version:
",
'\0');
contents
=
stringConcatenation(contents,
integerToASCII(header->gedcVersion),
string start = 23
NUMBER OF arrows IN WORD integerToASCII(header->gedcVersion), : 1
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Encoding:
",
'\0');
contents
=
stringConcatenation(contents,
integerToASCII(header->encoding),
string start = 23
NUMBER OF arrows IN WORD integerToASCII(header->encoding), : 1
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Submitter:
",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
print
=
printSubmitter(header->submitter);
string start = 23
NUMBER OF arrows IN WORD printSubmitter(header->submitter); : 1
contents
=
stringConcatenation(contents,
print,
'\0');
free(print);
contents
=
stringConcatenation(contents,
"Other
Fields:
",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
/*
Print
Individuals
*/
ListIterator
iter
=
createIterator(header->otherFields);
string start = 23
NUMBER OF arrows IN WORD createIterator(header->otherFields); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
print
=
(header->otherFields).printData((Field
string start = 9
NUMBER OF arrows IN WORD (header->otherFields).printData((Field : 1
*)
elem);
contents
=
stringConcatenation(contents,
"
",
'\0');
contents
=
stringConcatenation(contents,
print,
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
free(print);
}
return
contents;
}
static
char*
printSubmitter(void*
toBePrinted)
{
if(toBePrinted
==
NULL)
{
return
NULL;
}
Submitter
*
submitter
=
(Submitter
*)
toBePrinted;
char
*
contents
=
NULL;
void
*
elem
=
NULL;
char
*
print
=
NULL;
contents
=
stringConcatenation(contents,
"Submitter
Name:
",
'\0');
contents
=
stringConcatenation(contents,
submitter->submitterName,
string start = 11
NUMBER OF arrows IN WORD submitter->submitterName, : 1
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Submitter
Address:
",
'\0');
contents
=
stringConcatenation(contents,
submitter->address,
string start = 11
NUMBER OF arrows IN WORD submitter->address, : 1
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
ListIterator
iter
=
createIterator(submitter->otherFields);
string start = 26
NUMBER OF arrows IN WORD createIterator(submitter->otherFields); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
print
=
(submitter->otherFields).printData((Field
string start = 12
NUMBER OF arrows IN WORD (submitter->otherFields).printData((Field : 1
*)
elem);
contents
=
stringConcatenation(contents,
"
",
'\0');
contents
=
stringConcatenation(contents,
print,
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
free(print);
}
return
contents;
}
void
deleteGEDCOM(GEDCOMobject*
obj)
{
if(obj
==
NULL)
{
return;
}
if(obj->header
string start = 8
NUMBER OF arrows IN WORD if(obj->header : 1
!=
NULL)
{
clearList(&((obj->header)->otherFields));
string start = 18
string start = 27
NUMBER OF arrows IN WORD clearList(&((obj->header)->otherFields)); : 2
free(obj->header);
string start = 10
NUMBER OF arrows IN WORD free(obj->header); : 1
}
clearList(&(obj->families));
string start = 17
NUMBER OF arrows IN WORD clearList(&(obj->families)); : 1
clearList(&(obj->individuals));
string start = 17
NUMBER OF arrows IN WORD clearList(&(obj->individuals)); : 1
if(obj->submitter
string start = 8
NUMBER OF arrows IN WORD if(obj->submitter : 1
!=
NULL)
{
clearList(&((obj->submitter)->otherFields));
string start = 18
string start = 30
NUMBER OF arrows IN WORD clearList(&((obj->submitter)->otherFields)); : 2
free(obj->submitter);
string start = 10
NUMBER OF arrows IN WORD free(obj->submitter); : 1
}
free(obj);
}
/**
Function
to
create
a
string
representation
of
a
GEDCOMobject.
*@pre
GEDCOMobject
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOMobject
has
not
been
modified
in
any
way,
and
a
string
representing
the
GEDCOM
contents
has
been
created
*@return
a
string
contaning
a
humanly
readable
representation
of
a
GEDCOMobject
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
char*
printGEDCOM(const
GEDCOMobject*
obj)
{
char
*
contents
=
NULL;
char
*
print
=
NULL;
void
*
elem
=
NULL;
if(obj
==
NULL)
{
return
NULL;
}
print
=
printHeader(obj->header);
string start = 17
NUMBER OF arrows IN WORD printHeader(obj->header); : 1
contents
=
stringConcatenation(contents,
print,
'\0');
free(print);
print
=
printSubmitter(obj->submitter);
string start = 20
NUMBER OF arrows IN WORD printSubmitter(obj->submitter); : 1
contents
=
stringConcatenation(contents,
print,
'\0');
free(print);
/*
Print
Individuals
*/
ListIterator
iter
=
createIterator(obj->individuals);
string start = 20
NUMBER OF arrows IN WORD createIterator(obj->individuals); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
print
=
(obj->individuals).printData((Individual
string start = 6
NUMBER OF arrows IN WORD (obj->individuals).printData((Individual : 1
*)
elem);
contents
=
stringConcatenation(contents,
print,
'\0');
free(print);
}
/*
Print
families
*/
iter
=
createIterator(obj->families);
string start = 20
NUMBER OF arrows IN WORD createIterator(obj->families); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
print
=
(obj->families).printData((Family
string start = 6
NUMBER OF arrows IN WORD (obj->families).printData((Family : 1
*)
elem);
contents
=
stringConcatenation(contents,
print,
'\0');
free(print);
}
return
contents;
}
Individual
*
cloneIndividual(const
Individual
*
obj)
{
Individual
*
temp
=
NULL;
if(obj
==
NULL)
{
return
NULL;
}
temp
=
calloc(sizeof(Individual),
1);;
if(temp
==
NULL)
{
return
NULL;
}
/*
Reset
Certain
Properties
*/
temp->givenName
string start = 6
NUMBER OF arrows IN WORD temp->givenName : 1
=
stringCopy(obj->givenName);
string start = 16
NUMBER OF arrows IN WORD stringCopy(obj->givenName); : 1
temp->surname
string start = 6
NUMBER OF arrows IN WORD temp->surname : 1
=
stringCopy(obj->surname);
string start = 16
NUMBER OF arrows IN WORD stringCopy(obj->surname); : 1
((Individual
*)
temp)->events=
string start = 7
NUMBER OF arrows IN WORD temp)->events= : 1
initializeList(&printEvent,
&deleteEvent,
&compareEvents);
((Individual
*)
temp)->families=
string start = 7
NUMBER OF arrows IN WORD temp)->families= : 1
initializeList(&printFamily,
&deleteDummy,
&compareFamilies);
((Individual
*)
temp)->otherFields=
string start = 7
NUMBER OF arrows IN WORD temp)->otherFields= : 1
initializeList(&printField,
&deleteField,
&compareFields);
return
temp;
}
/**
Function
to
"convert"
the
GEDCOMerror
into
a
humanly
redabale
string.
*@return
a
string
contaning
a
humanly
readable
representation
of
the
error
code
*@param
err
-
an
error
struct
**/
char*
printError(GEDCOMerror
err)
{
char
*
representation
=
calloc(sizeof(char),
200);
if(err.type
==
OK)
{
strcpy(representation,
"OK");
}
else
if(err.type
==
INV_FILE)
{
strcpy(representation,
"invalid
file");
}
else
if(err.type
==
INV_GEDCOM)
{
strcpy(representation,
"invalid
GEDCOM");
}
else
if(err.type
==
INV_HEADER)
{
strcpy(representation,
"invalid
header");
}
else
if(err.type
==
INV_RECORD)
{
strcpy(representation,
"invalid
record");
}
else
if(err.type
==
OTHER_ERROR)
{
strcpy(representation,
"other
error");
}
if(err.line
!=
-1)
{
strcat(representation,
"
(line
");
strcat(representation,
integerToASCII(err.line));
strcat(representation,
")");
}
return
representation;
}
void
deleteEvent(void*
toBeDeleted)
{
if(toBeDeleted
==
NULL)
{
return;
}
Event
*
event
=
(Event
*)
toBeDeleted;
free(event->date);
string start = 12
NUMBER OF arrows IN WORD free(event->date); : 1
free(event->place);
string start = 12
NUMBER OF arrows IN WORD free(event->place); : 1
clearList(&(event->otherFields));
string start = 19
NUMBER OF arrows IN WORD clearList(&(event->otherFields)); : 1
free(event);
}
int
compareEvents(const
void*
first,const
void*
second)
{
if(first
==
NULL
||
second
==
NULL)
{
return
0;
}
Event
*
event1
=
(Event
*)
first;
Event
*
event2
=
(Event
*)
second;
/*
Just
Check
the
Types
*/
return
strcmp(event1->type,
string start = 15
NUMBER OF arrows IN WORD strcmp(event1->type, : 1
event2->type);
string start = 8
NUMBER OF arrows IN WORD event2->type); : 1
/*
if(event1->date
string start = 11
NUMBER OF arrows IN WORD if(event1->date : 1
==
NULL
||
strcmp(event1->date,
string start = 15
NUMBER OF arrows IN WORD strcmp(event1->date, : 1
"")
==
0
||
event2->date
string start = 8
NUMBER OF arrows IN WORD event2->date : 1
==
NULL
||
strcmp(event2->date,
string start = 15
NUMBER OF arrows IN WORD strcmp(event2->date, : 1
"")
==
0)
{
if(event1->type
string start = 11
NUMBER OF arrows IN WORD if(event1->type : 1
==
NULL
||
event2->type
string start = 8
NUMBER OF arrows IN WORD event2->type : 1
==
NULL)
{
return
0;
}
return
strcmp(first->type,
string start = 14
NUMBER OF arrows IN WORD strcmp(first->type, : 1
second->type);
string start = 8
NUMBER OF arrows IN WORD second->type); : 1
}
char
**
event1Pieces
=
tokenCreate(event1->date,
string start = 20
NUMBER OF arrows IN WORD tokenCreate(event1->date, : 1
GEDCOM_DELIMITER,
0,
0);
char
**
event2Pieces
=
tokenCreate(event2->date,
string start = 20
NUMBER OF arrows IN WORD tokenCreate(event2->date, : 1
GEDCOM_DELIMITER,
0,
0);
if(tokenCount(event1Pieces)
!=
3
||
tokenCount(event2Pieces)
!=
3)
{
return
0;
}
if(asciiToInteger(event1Pieces[2])
static
int
getMonthFromString(const
char
*
const
key)
//Represents
a
generic
event,
e.g.
individual
event,
family
event,
etc.
typedef
struct
{
//The
max
length
of
this
field
is
known
from
the
GEDCOM
spec,
so
we
can
use
a
statically
allocated
array
char
type[5];
//Empty
string
if
not
provided
char*
date;
//Empty
string
if
not
provided
char*
place;
//All
other
event
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Event;
return
1;
*/
}
char*
printEvent(void*
toBePrinted)
{
if(toBePrinted
==
NULL)
{
return
NULL;
}
Event
*
event
=
(Event
*)
toBePrinted;
char
*
contents
=
NULL;
void
*
elem
=
NULL;
char
*
print
=
NULL;
contents
=
stringConcatenation(contents,
"~Event~",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Type:
",
'\0');
contents
=
stringConcatenation(contents,
event->type,
string start = 7
NUMBER OF arrows IN WORD event->type, : 1
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Date:
",
'\0');
contents
=
stringConcatenation(contents,
event->date,
string start = 7
NUMBER OF arrows IN WORD event->date, : 1
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Place:
",
'\0');
contents
=
stringConcatenation(contents,
event->place,
string start = 7
NUMBER OF arrows IN WORD event->place, : 1
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Other
Fields:
",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
ListIterator
iter
=
createIterator(event->otherFields);
string start = 22
NUMBER OF arrows IN WORD createIterator(event->otherFields); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
print
=
(event->otherFields).printData((Field
string start = 8
NUMBER OF arrows IN WORD (event->otherFields).printData((Field : 1
*)
elem);
contents
=
stringConcatenation(contents,
"
",
'\0');
contents
=
stringConcatenation(contents,
print,
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
free(print);
}
return
contents;
}
void
deleteIndividual(void*
toBeDeleted)
{
if(toBeDeleted
==
NULL)
{
return;
}
Individual
*
individual
=
(Individual
*)
toBeDeleted;
free(individual->givenName);
string start = 17
NUMBER OF arrows IN WORD free(individual->givenName); : 1
free(individual->surname);
string start = 17
NUMBER OF arrows IN WORD free(individual->surname); : 1
clearList(&(individual->events));
string start = 24
NUMBER OF arrows IN WORD clearList(&(individual->events)); : 1
clearList(&(individual->families));
string start = 24
NUMBER OF arrows IN WORD clearList(&(individual->families)); : 1
clearList(&(individual->otherFields));
string start = 24
NUMBER OF arrows IN WORD clearList(&(individual->otherFields)); : 1
free(individual);
}
int
compareIndividuals(const
void*
first,const
void*
second)
{
if(first
==
NULL
||
second
==
NULL)
{
return
0;
}
char
*
firstName
=
stringConcatenation(NULL,
((Individual
*)
first)->givenName,
string start = 8
NUMBER OF arrows IN WORD first)->givenName, : 1
'\0');
firstName
=
stringConcatenation(firstName,
",",
'\0');
firstName
=
stringConcatenation(firstName,
((Individual
*)
first)->surname,
string start = 8
NUMBER OF arrows IN WORD first)->surname, : 1
'\0');
char
*
secondName
=
stringConcatenation(NULL,
((Individual
*)
second)->givenName,
string start = 9
NUMBER OF arrows IN WORD second)->givenName, : 1
'\0');
secondName
=
stringConcatenation(secondName,
",",
'\0');
secondName
=
stringConcatenation(secondName,
((Individual
*)
second)->surname,
string start = 9
NUMBER OF arrows IN WORD second)->surname, : 1
'\0');
int
result
=
strcmp(firstName,
secondName);
free(firstName);
free(secondName);
return
result;
}
int
compareIndividualsByPointer(const
void*
first,const
void*
second)
{
if(first
==
NULL
||
second
==
NULL)
{
return
0;
}
return
!(first
==
second);
}
char*
printIndividual(void*
toBePrinted)
{
if(toBePrinted
==
NULL)
{
return
NULL;
}
Individual
*
individual
=
(Individual
*)
toBePrinted;
char
*
contents
=
NULL;
void
*
elem
=
NULL;
char
*
print
=
NULL;
contents
=
stringConcatenation(contents,
"~Individual~",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Given
Name:
",
'\0');
contents
=
stringConcatenation(contents,
individual->givenName,
string start = 12
NUMBER OF arrows IN WORD individual->givenName, : 1
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Surname:
",
'\0');
contents
=
stringConcatenation(contents,
individual->surname,
string start = 12
NUMBER OF arrows IN WORD individual->surname, : 1
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Events:
",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
ListIterator
iter
=
createIterator(individual->events);
string start = 27
NUMBER OF arrows IN WORD createIterator(individual->events); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
print
=
(individual->events).printData((Event
string start = 13
NUMBER OF arrows IN WORD (individual->events).printData((Event : 1
*)
elem);
contents
=
stringConcatenation(contents,
"
",
'\0');
contents
=
stringConcatenation(contents,
print,
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
free(print);
}
contents
=
stringConcatenation(contents,
"\n",
'\0');
contents
=
stringConcatenation(contents,
"Other
Fields:
",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
iter
=
createIterator(individual->otherFields);
string start = 27
NUMBER OF arrows IN WORD createIterator(individual->otherFields); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
print
=
(individual->otherFields).printData((Field
string start = 13
NUMBER OF arrows IN WORD (individual->otherFields).printData((Field : 1
*)
elem);
contents
=
stringConcatenation(contents,
"
",
'\0');
contents
=
stringConcatenation(contents,
print,
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
free(print);
}
return
contents;
}
void
deleteFamily(void*
toBeDeleted)
{
if(toBeDeleted
==
NULL)
{
return;
}
Family
*
family
=
(Family
*)
toBeDeleted;
clearList(&(family->children));
string start = 20
NUMBER OF arrows IN WORD clearList(&(family->children)); : 1
clearList(&(family->events));
string start = 20
NUMBER OF arrows IN WORD clearList(&(family->events)); : 1
clearList(&(family->otherFields));
string start = 20
NUMBER OF arrows IN WORD clearList(&(family->otherFields)); : 1
free(family);
}
int
compareFamilies(const
void*
first,const
void*
second)
{
return
0;
}
char*
printFamily(void*
toBePrinted)
{
if(toBePrinted
==
NULL)
{
return
NULL;
}
Family
*
family
=
(Family
*)
toBePrinted;
char
*
contents
=
NULL;
void
*
elem
=
NULL;
char
*
print
=
NULL;
contents
=
stringConcatenation(contents,
"~Family~",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
print
=
printIndividual(family->husband);
string start = 24
NUMBER OF arrows IN WORD printIndividual(family->husband); : 1
contents
=
stringConcatenation(contents,
"Husband:
",
'\0');
contents
=
stringConcatenation(contents,
print,
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
free(print);
print
=
printIndividual(family->wife);
string start = 24
NUMBER OF arrows IN WORD printIndividual(family->wife); : 1
contents
=
stringConcatenation(contents,
"Wife:
",
'\0');
contents
=
stringConcatenation(contents,
print,
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
free(print);
contents
=
stringConcatenation(contents,
"Children:
",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
/*
Print
Individuals
*/
ListIterator
iter
=
createIterator(family->children);
string start = 23
NUMBER OF arrows IN WORD createIterator(family->children); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
print
=
(family->children).printData((Individual
string start = 9
NUMBER OF arrows IN WORD (family->children).printData((Individual : 1
*)
elem);
contents
=
stringConcatenation(contents,
"
",
'\0');
contents
=
stringConcatenation(contents,
print,
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
free(print);
}
contents
=
stringConcatenation(contents,
"Events:
",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
iter
=
createIterator(family->events);
string start = 23
NUMBER OF arrows IN WORD createIterator(family->events); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
print
=
(family->events).printData((Event
string start = 9
NUMBER OF arrows IN WORD (family->events).printData((Event : 1
*)
elem);
contents
=
stringConcatenation(contents,
"
",
'\0');
contents
=
stringConcatenation(contents,
print,
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
free(print);
}
contents
=
stringConcatenation(contents,
"Other
Fields:
",
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
iter
=
createIterator(family->otherFields);
string start = 23
NUMBER OF arrows IN WORD createIterator(family->otherFields); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
print
=
(family->otherFields).printData((Field
string start = 9
NUMBER OF arrows IN WORD (family->otherFields).printData((Field : 1
*)
elem);
contents
=
stringConcatenation(contents,
"
",
'\0');
contents
=
stringConcatenation(contents,
print,
'\0');
contents
=
stringConcatenation(contents,
"\n",
'\0');
free(print);
}
return
contents;
}
void
deleteField(void*
toBeDeleted)
{
if(toBeDeleted
==
NULL)
{
return;
}
Field
*
field
=
(Field
*)
toBeDeleted;
free(field->tag);
string start = 12
NUMBER OF arrows IN WORD free(field->tag); : 1
free(field->value);
string start = 12
NUMBER OF arrows IN WORD free(field->value); : 1
free(field);
}
int
compareFields(const
void*
first,const
void*
second)
{
return
0;
}
char*
printField(void*
toBePrinted)
{
if(toBePrinted
==
NULL)
{
return
NULL;
}
Field
*
field
=
(Field
*)
toBePrinted;
char
*
contents
=
NULL;
contents
=
stringConcatenation(contents,
"Tag:
",
'\0');
contents
=
stringConcatenation(contents,
field->tag,
string start = 7
NUMBER OF arrows IN WORD field->tag, : 1
'\0');
contents
=
stringConcatenation(contents,
",
",
'\0');
contents
=
stringConcatenation(contents,
"Value:
",
'\0');
contents
=
stringConcatenation(contents,
field->value,
string start = 7
NUMBER OF arrows IN WORD field->value, : 1
'\0');
return
contents;
}
/**
Function
that
searches
for
an
individual
in
the
list
using
a
comparator
function.
*
If
an
individual
is
found,
a
pointer
to
the
Individual
record
*
Returns
NULL
if
the
individual
is
not
found.
*@pre
GEDCOM
object
exists,is
not
NULL,
and
is
valid.
Comparator
function
has
been
provided.
*@post
GEDCOM
object
remains
unchanged.
*@return
The
Individual
record
associated
with
the
person
that
matches
the
search
criteria.
If
the
Individual
record
is
not
found,
return
NULL.
*If
multiple
records
match
the
search
criteria,
return
the
first
one.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
compare
-
a
pointer
to
comparator
fuction
for
customizing
the
search
*@param
person
-
a
pointer
to
search
data,
which
contains
seach
criteria
*Note:
while
the
arguments
of
compare()
and
person
are
all
void,
i
+
1t
is
assumed
that
records
they
point
to
are
*
all
of
the
same
type
-
just
like
arguments
to
the
compare()
function
in
the
List
struct
**/
Individual*
findPerson(const
GEDCOMobject*
familyRecord,
bool
(*compare)(const
void*
first,
const
void*
second),
const
void*
person)
{
void
*
elem
=
NULL;
if(familyRecord
==
NULL
||
compare
==
NULL
||
person
==
NULL)
{
return
NULL;
}
/*
We're
making
the
assumption
all
"persons"
are
stored
in
individuals
because
we
don't
allow
circular
individual
creation
*/
ListIterator
iter
=
createIterator(familyRecord->individuals);
string start = 29
NUMBER OF arrows IN WORD createIterator(familyRecord->individuals); : 1
while
((elem
=
nextElement(&iter))
!=
NULL){
const
int
response
=
compare((void
*)
elem,
(void
*)
person);
if(response)
{
return
elem;
}
}
return
NULL;
}
/**
Function
to
return
a
list
of
all
descendants
of
an
individual
in
a
GEDCOM
*@pre
GEDCOM
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOM
object
has
not
been
modified
in
any
way,
and
a
list
of
descendants
has
been
created
*@return
a
list
of
descendants.
The
list
may
be
empty.
All
list
members
must
be
of
type
Individual,
and
can
appear
in
any
order.
*All
list
members
must
be
COPIES
of
the
Individual
records
in
the
GEDCOM
file.
If
the
returned
list
is
freed,
the
original
GEDCOM
*must
remain
unaffected.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
person
-
the
Individual
record
whose
descendants
we
want
**/
List
getDescendants(const
GEDCOMobject*
familyRecord,
const
Individual*
person)
{
List
descendants
=
initializeList(&printIndividual,
&deleteIndividual,
&compareIndividuals);
void
*
elem
=
NULL;
void
*
childElem
=
NULL;
void
*
descendantElem
=
NULL;
if(familyRecord
==
NULL
||
person
==
NULL)
{
return
descendants;
}
/*
We're
making
the
assumption
all
"persons"
are
stored
in
individuals
because
we
don't
allow
circular
individual
creation
*/
ListIterator
iter
=
createIterator(familyRecord->families);
string start = 29
NUMBER OF arrows IN WORD createIterator(familyRecord->families); : 1
/*
Find
all
the
instances
of
where
person
is
a
wife
or
husband
*/
while
((elem
=
nextElement(&iter))
!=
NULL){
if(((Family
*)
elem)->husband
string start = 7
NUMBER OF arrows IN WORD elem)->husband : 1
!=
NULL
&&
compareIndividualsByPointer((void
*)
((Family
*)
elem)->husband,
string start = 7
NUMBER OF arrows IN WORD elem)->husband, : 1
(void
*)
person)
==
0)
{
/*
We're
making
the
assumption
all
"persons"
are
stored
in
individuals
because
we
don't
allow
circular
individual
creation
*/
ListIterator
childIter
=
createIterator(((Family
*)
elem)->children);
string start = 7
NUMBER OF arrows IN WORD elem)->children); : 1
/*
Iterate
on
their
children,
and
find
their
descendants
*/
while
((childElem
=
nextElement(&childIter))
!=
NULL){
List
childDescendants
=
getDescendants(familyRecord,
childElem);
ListIterator
descendantsIter
=
createIterator(childDescendants);
/*
Merge
descendants
with
main
list
*/
while
((descendantElem
=
nextElement(&descendantsIter))
!=
NULL){
insertBack(&descendants,
cloneIndividual(descendantElem));
}
insertBack(&descendants,
cloneIndividual(childElem));
clearList(&childDescendants);
}
}
else
if(((Family
*)
elem)->wife
string start = 7
NUMBER OF arrows IN WORD elem)->wife : 1
!=
NULL
&&
compareIndividualsByPointer((void
*)
((Family
*)
elem)->wife,
string start = 7
NUMBER OF arrows IN WORD elem)->wife, : 1
(void
*)
person)
==
0)
{
/*
We're
making
the
assumption
all
"persons"
are
stored
in
individuals
because
we
don't
allow
circular
individual
creation
*/
ListIterator
childIter
=
createIterator(((Family
*)
elem)->children);
string start = 7
NUMBER OF arrows IN WORD elem)->children); : 1
/*
Iterate
on
their
children,
and
find
their
descendants
*/
while
((childElem
=
nextElement(&childIter))
!=
NULL){
List
childDescendants
=
getDescendants(familyRecord,
childElem);
ListIterator
descendantsIter
=
createIterator(childDescendants);
/*
Merge
descendants
with
main
list
*/
while
((descendantElem
=
nextElement(&descendantsIter))
!=
NULL){
insertBack(&descendants,
cloneIndividual(descendantElem));
}
insertBack(&descendants,
cloneIndividual(childElem));
clearList(&childDescendants);
}
}
}
return
descendants;
}
/**************
2750
W2018
A1
GEDCOM
Parser
Student1
**************/
#ifndef
GEDCOMPARSER_H
#define
GEDCOMPARSER_H
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
#include
"LinkedListAPI.h"
//For
simplicity,
the
examples
we
will
use
will
only
use
the
ASCII
subset
of
these
encodings
typedef
enum
cSet
{ANSEL,
UTF8,
UNICODE,
ASCII}
CharSet;
//error
code
enum
typedef
enum
eCode
{OK,
INV_FILE,
INV_GEDCOM,
INV_HEADER,
INV_RECORD,
OTHER}
ErrorCode;
//Represents
a
generic
event,
e.g.
individual
event,
family
event,
etc.
typedef
struct
{
//The
max
length
of
this
field
is
known
from
the
GEDCOM
spec,
so
we
can
use
a
statically
allocated
array
char
type[5];
//Empty
string
if
not
provided
char*
date;
//Empty
string
if
not
provided
char*
place;
//All
other
event
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Event;
//Represents
a
generic
field.
This
will
be
used
in
A2.
typedef
struct
{
//Field
tag.
Must
not
be
NULL/empty.
char*
tag;
//Field
value.
Must
not
be
NULL/empty.
char*
value;
}
Field;
//Represents
a
submitter
record.
This
is
a
separate
type/struct,
in
case
we
decide
to
expand
it
in
later
assignments
typedef
struct
{
//Submitter
name
has
a
max
length
and
only
appears
once,
so
we
can
hardcode
it
char
submitterName[61];
//All
other
submitter
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
//Submitted
address.
We
use
a
C99
flexible
array
member,
which
we
will
discuss
in
class.
char
address[];
}
Submitter;
/*
Represents
the
GEDCOM
header
Only
includes
required
fields
("line
values"
in
GEDCOM
terminology)
Note
that
while
GEDCOM_FORM
is
required,
but
for
us
it
will
always
be
Lineage-Linked
*/
typedef
struct
{
//Header
source
-
i.e.
software
that
produced
the
GEDCOM
file
char
source[249];
//GEDCOM
version
float
gedcVersion;
//Encoding.
We
use
an
enum,
since
there
are
only
4
possible
values.
CharSet
encoding;
//Reference
to
the
submitter
record
Submitter*
submitter;
//All
other
header
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Header;
//Represends
GEDCOM
individual
record
typedef
struct
{
//Set
to
empty
string
if
not
present
in
file
char*
givenName;
//Set
to
empty
string
if
not
present
in
file
char*
surname;
//Collection
of
events.
All
objects
in
the
list
will
be
of
type
Event.
It
may
be
empty.
List
events;
//Collection
of
family
references.
All
objects
in
the
list
will
be
of
type
Family.
It
may
be
empty.
List
families;
//All
other
individual
record
fields.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Individual;
//Represends
GEDCOM
family
record
typedef
struct
{
//Wife
reference
(can
be
null)
Individual*
wife;
//Husband
reference
(can
be
null)
Individual*
husband;
//List
of
child
references.
All
objects
in
the
list
will
be
of
type
Individual.
It
may
be
empty.
List
children;
//List
of
other
fields
in
the
family
record.
All
objects
in
the
list
will
be
of
type
Field.
It
may
be
empty.
List
otherFields;
}
Family;
//Represents
a
GEDCOM
object
typedef
struct
{
//Header.
Must
not
be
NULL.
Header*
header;
//Family
records.
All
objects
in
the
list
will
be
of
type
Family.
It
may
be
empty.
List
families;
//Must
contain
type
//Individual
records.
All
objects
in
the
list
will
be
of
type
Individual.
It
may
be
empty.
List
individuals;
//Must
contain
type
Family
//Submitter.
Must
not
be
NULL.
Submitter*
submitter;
//All
other
records
should
be
ignored
for
now
}
GEDCOMobject;
//Error
type
typedef
struct
{
ErrorCode
type;
int
line;
}
GEDCOMerror;
//*****************************************
GEDCOOM
object
functions
*****************************************
/**
Function
to
create
a
GEDCOM
object
based
on
the
contents
of
an
GEDCOM
file.
*@pre
File
name
cannot
be
an
empty
string
or
NULL.
File
name
must
have
the
.ged
extension.
File
represented
by
this
name
must
exist
and
must
be
readable.
*@post
Either:
A
valid
GEDCOM
has
been
created,
its
address
was
stored
in
the
variable
obj,
and
OK
was
returned
or
An
error
occurred,
the
GEDCOM
was
not
created,
all
temporary
memory
was
freed,
obj
was
set
to
NULL,
and
the
appropriate
error
code
was
returned
*@return
the
error
code
indicating
success
or
the
error
encountered
when
parsing
the
GEDCOM
*@param
fileName
-
a
string
containing
the
name
of
the
GEDCOM
file
*@param
a
double
pointer
to
a
GEDCOMobject
struct
that
needs
to
be
allocated
**/
GEDCOMerror
createGEDCOM(char*
fileName,
GEDCOMobject**
obj);
/**
Function
to
create
a
string
representation
of
a
GEDCOMobject.
*@pre
GEDCOMobject
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOMobject
has
not
been
modified
in
any
way,
and
a
string
representing
the
GEDCOM
contents
has
been
created
*@return
a
string
contaning
a
humanly
readable
representation
of
a
GEDCOMobject
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
char*
printGEDCOM(const
GEDCOMobject*
obj);
/**
Function
to
delete
all
GEDCOM
object
content
and
free
all
the
memory.
*@pre
GEDCOM
object
exists,
is
not
null,
and
has
not
been
freed
*@post
GEDCOM
object
had
been
freed
*@return
none
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
void
deleteGEDCOM(GEDCOMobject*
obj);
/**
Function
to
"convert"
the
GEDCOMerror
into
a
humanly
redabale
string.
*@return
a
string
contaning
a
humanly
readable
representation
of
the
error
code
*@param
err
-
an
error
struct
**/
char*
printError(GEDCOMerror
err);
/**
Function
that
searches
for
an
individual
in
the
list
using
a
comparator
function.
*
If
an
individual
is
found,
a
pointer
to
the
Individual
record
*
Returns
NULL
if
the
individual
is
not
found.
*@pre
GEDCOM
object
exists,is
not
NULL,
and
is
valid.
Comparator
function
has
been
provided.
*@post
GEDCOM
object
remains
unchanged.
*@return
The
Individual
record
associated
with
the
person
that
matches
the
search
criteria.
If
the
Individual
record
is
not
found,
return
NULL.
*If
multiple
records
match
the
search
criteria,
return
the
first
one.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
compare
-
a
pointer
to
comparator
fuction
for
customizing
the
search
*@param
person
-
a
pointer
to
search
data,
which
contains
seach
criteria
*Note:
while
the
arguments
of
compare()
and
person
are
all
void,
it
is
assumed
that
records
they
point
to
are
*
all
of
the
same
type
-
just
like
arguments
to
the
compare()
function
in
the
List
struct
**/
Individual*
findPerson(const
GEDCOMobject*
familyRecord,
bool
(*compare)(const
void*
first,
const
void*
second),
const
void*
person);
/**
Function
to
return
a
list
of
all
descendants
of
an
individual
in
a
GEDCOM
*@pre
GEDCOM
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOM
object
has
not
been
modified
in
any
way,
and
a
list
of
descendants
has
been
created
*@return
a
list
of
descendants.
The
list
may
be
empty.
All
list
members
must
be
of
type
Individual,
and
can
appear
in
any
order.
*All
list
members
must
be
COPIES
of
the
Individual
records
in
the
GEDCOM
file.
If
the
returned
list
is
freed,
the
original
GEDCOM
*must
remain
unaffected.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
person
-
the
Individual
record
whose
descendants
we
want
**/
List
getDescendants(const
GEDCOMobject*
familyRecord,
const
Individual*
person);
//************************************************************************************************************
//******************************************
List
helper
functions
*******************************************
void
deleteEvent(void*
toBeDeleted);
int
compareEvents(const
void*
first,const
void*
second);
char*
printEvent(void*
toBePrinted);
void
deleteIndividual(void*
toBeDeleted);
int
compareIndividuals(const
void*
first,const
void*
second);
char*
printIndividual(void*
toBePrinted);
void
deleteFamily(void*
toBeDeleted);
int
compareFamilies(const
void*
first,const
void*
second);
char*
printFamily(void*
toBePrinted);
void
deleteField(void*
toBeDeleted);
int
compareFields(const
void*
first,const
void*
second);
char*
printField(void*
toBePrinted);
//************************************************************************************************************
#endif
/**
*
@file
LinkedListAPI.h
*
@author
CIS*2750
F17
(based
on
the
ListADT
from
CIS*2520,
S17)
*
@date
September
2017
*
@brief
File
containing
the
function
definitions
of
a
doubly
linked
list
*/
/**************
2750
W2018
A1
GEDCOM
Parser
Student1
**************/
#ifndef
_LIST_API_
#define
_LIST_API_
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
/**
*
Node
of
a
linked
list.
This
list
is
doubly
linked,
meaning
that
it
has
points
to
both
the
node
immediately
in
front
*
of
it,
as
well
as
the
node
immediately
behind
it.
**/
typedef
struct
listNode{
void*
data;
struct
listNode*
previous;
struct
listNode*
next;
}
Node;
/**
*
Metadata
head
of
the
list.
*
Contains
no
actual
data
but
contains
*
information
about
the
list
(head
and
tail)
as
well
as
the
function
pointers
*
for
working
with
the
abstracted
list
data.
**/
typedef
struct
listHead{
Node*
head;
Node*
tail;
int
length;
void
(*deleteData)(void*
toBeDeleted);
int
(*compare)(const
void*
first,const
void*
second);
char*
(*printData)(void*
toBePrinted);
}
List;
/**
*
List
iterator
structure.
*
It
represents
an
abstract
object
for
iterating
through
the
list.
*
The
list
implemntation
is
hidden
from
the
user
**/
typedef
struct
iter{
Node*
current;
}
ListIterator;
/**
Function
to
initialize
the
list
metadata
head
with
the
appropriate
function
pointers.
*@return
the
list
struct
*@param
printFunction
function
pointer
to
print
a
single
node
of
the
list
*@param
deleteFunction
function
pointer
to
delete
a
single
piece
of
data
from
the
list
*@param
compareFunction
function
pointer
to
compare
two
nodes
of
the
list
in
order
to
test
for
equality
or
order
**/
List
initializeList(char*
(*printFunction)(void*
toBePrinted),void
(*deleteFunction)(void*
toBeDeleted),int
(*compareFunction)(const
void*
first,const
void*
second));
/**Function
for
creating
a
node
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
data
should
be
of
same
size
of
void
pointer
on
the
users
machine
to
avoid
size
conflicts.
data
must
be
valid.
*data
must
be
cast
to
void
pointer
before
being
added.
*@post
data
is
valid
to
be
added
to
a
linked
list
*@return
On
success
returns
a
node
that
can
be
added
to
a
linked
list.
On
failure,
returns
NULL.
*@param
data
-
is
a
void
*
pointer
to
any
data
type.
Data
must
be
allocated
on
the
heap.
**/
Node*
initializeNode(void*
data);
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertFront(List*
list,
void*
toBeAdded);
/**Inserts
a
Node
at
the
back
of
a
linked
list.
*List
metadata
is
updated
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertBack(List*
list,
void*
toBeAdded);
/**
Clears
the
contents
linked
list,
freeing
all
memory
asspociated
with
these
contents.
*
uses
the
supplied
function
pointer
to
release
allocated
memory
for
the
data
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
List-type
dummy
node
**/
void
clearList(List*
list);
/**
Uses
the
comparison
function
pointer
to
place
the
element
in
the
*
appropriate
position
in
the
list.
*
should
be
used
as
the
only
insert
function
if
a
sorted
list
is
required.
*@pre
List
exists
and
has
memory
allocated
to
it.
Node
to
be
added
is
valid.
*@post
The
node
to
be
added
will
be
placed
immediately
before
or
after
the
first
occurrence
of
a
related
node
*@param
list
a
pointer
to
the
dummy
head
of
the
list
containing
function
pointers
for
delete
and
compare,
as
well
as
a
pointer
to
the
first
and
last
element
of
the
list.
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertSorted(List*
list,
void*
toBeAdded);
/**
Removes
data
from
from
the
list,
deletes
the
node
and
frees
the
memory,
*
changes
pointer
values
of
surrounding
nodes
to
maintain
list
structure.
*
returns
the
data
*
You
can
assume
that
the
list
contains
no
duplicates
*@pre
List
must
exist
and
have
memory
allocated
to
it
*@post
If
toBeDeleted
was
found,
the
node
associated
with
it
is
removed
from
the
list
and
freed.
*The
list
is
re-linked.
Otherwise
the
List
is
unchanged.
*@param
list
pointer
to
the
dummy
head
of
the
list
containing
deleteFunction
function
pointer
*@param
toBeDeleted
pointer
to
data
that
is
to
be
removed
from
the
list
*@return
on
success:
void
*
pointer
to
data
on
failure:
NULL
**/
void*
deleteDataFromList(List*
list,
void*
toBeDeleted);
/**Returns
a
pointer
to
the
data
at
the
front
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
head
of
the
list
**/
void*
getFromFront(List
list);
/**Returns
a
pointer
to
the
data
at
the
back
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
tail
of
the
list
**/
void*
getFromBack(List
list);
/**Returns
a
string
that
contains
a
string
representation
of
the
list
traversed
from
head
to
tail.
Utilize
the
list's
printData
function
pointer
to
create
the
string.
returned
string
must
be
freed
by
the
calling
function.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
Pointer
to
linked
list
dummy
head.
*@return
on
success:
char
*
to
string
representation
of
list
(must
be
freed
after
use).
on
failure:
NULL
**/
char*
toString(List
list);
/**
Function
for
creating
an
iterator
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
List
exists
and
is
valid
*@post
List
remains
unchanged.
The
iterator
has
been
allocated
and
points
to
the
head
of
the
list.
*@return
The
newly
created
iterator
object.
*@param
list
-
a
pointer
to
the
list
to
iterate
over.
**/
ListIterator
createIterator(List
list);
/**
Function
that
returns
the
next
element
of
the
list
through
the
iterator.
*
This
function
returns
the
data
at
head
of
the
list
the
first
time
it
is
called
after.
*
the
iterator
was
created.
Every
subsequent
call
returns
the
data
associated
with
the
next
element.
*
Returns
NULL
once
the
end
of
the
iterator
is
reached.
*@pre
List
exists
and
is
valid.
Iterator
exists
and
is
valid.
*@post
List
remains
unchanged.
The
iterator
points
to
the
next
element
on
the
list.
*@return
The
data
associated
with
the
list
element
that
the
iterator
pointed
to
when
the
function
was
called.
*@param
iter
-
an
iterator
to
a
list.
**/
void*
nextElement(ListIterator*
iter);
/**Returns
the
number
of
elements
in
the
list.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
-
the
list
struct.
*@return
on
success:
number
of
eleemnts
in
the
list
(0
or
more).
on
failure:
-1
(e.g.
list
not
initlized
correctly)
**/
int
getLength(List
list);
/**
Function
that
searches
for
an
element
in
the
list
using
a
comparator
function.
*
If
an
element
is
found,
a
pointer
to
the
data
of
that
element
is
returned
*
Returns
NULL
if
the
element
is
not
found.
*@pre
List
exists
and
is
valid.
Comparator
function
has
been
provided.
*@post
List
remains
unchanged.
*@return
The
data
associated
with
the
list
element
that
matches
the
search
criteria.
If
element
is
not
found,
return
NULL.
*@param
list
-
a
list
sruct
*@param
customCompare
-
a
pointer
to
comparator
fuction
for
customizing
the
search
*@param
searchRecord
-
a
pointer
to
search
data,
which
contains
seach
criteria
*Note:
while
the
arguments
of
compare()
and
searchRecord
are
all
void,
it
is
assumed
that
records
they
point
to
are
*
all
of
the
same
type
-
just
like
arguments
to
the
compare()
function
in
the
List
struct
**/
void*
findElement(List
list,
bool
(*customCompare)(const
void*
first,const
void*
second),
const
void*
searchRecord);
#endif
/**************
2750
W2018
A1
GEDCOM
Parser
Student1
**************/
#ifndef
GEDCOMUTILITIES_H
#define
GEDCOMUTILITIES_H
/**
Function
that
returns
a
single
line
of
the
gedcom
file
*
that
it
reads
character
by
character
*@return
a
single
gedcom
file
line
as
a
string
(char*)
*@param
filep
-
the
pointer
to
the
gedcom
file
*@param
lineNumber
-
an
integer
pointer
that
is
increased
for
every
line
read
*@param
line
-
a
character
array
allocated
in
the
calling
function
that
the
line
is
read
into
**/
char*
readLine(FILE
*filep,
int*
lineNumber,
char*
line);
/**
Function
that
returns
a
two
dimentional
array
containing
each
word
of
a
*
gedcom
line
tokenized
by
spaces
*@return
a
2D
array
countaing
each
word
in
the
input
line
*@param
numWords
-
an
int
pointer
that
is
set
to
the
sumber
of
words
in
the
2D
array
*@param
line
-
a
char*
containing
the
line
to
be
tokenized
**/
char**
splitLine(char*
line,
int*
numWords);
/**
Function
that
searches
the
file
for
an
individual
record.
returns
file
pointer
in
correct
location
*@return
an
int
representing
if
individual
was
found
*@param
filePointer
-
the
pointer
to
the
gedcom
file
*@param
currentLine
-
a
char*
that
can
be
checked
if
it
is
the
start
of
an
individual
record
**/
int
findIndividual(FILE
*filePointer,
char*
currentLine);
/**
Function
that
scans
the
gedcom
file
for
a
submitter
xref.
when
found,
*
it
returns
leaving
the
file
pointer
at
the
correct
place
in
the
file
*@return
an
integer
representing
whether
or
not
the
submitter
was
found
*@param
filePointer
-
the
pointer
to
the
gedcom
file
*@param
currentLine
-
a
char*
containing
the
current
line
(so
it
can
be
checked
if
it
is
the
submitter
xref)
*@param
submitterReference
-
a
char*
containing
the
xref
that
needs
to
be
matched
**/
int
findSubmitter(FILE
*filePointer,
char*
currentLine,
char*
submitterReference);
#endif
/**************
2750
W2018
A1
GEDCOM
Parser
Student1
**************/
#include
"../include/LinkedListAPI.h"
#include
<assert.h>
#include
<stdio.h>
#include
<stdlib.h>
/**
Function
to
initialize
the
list
metadata
head
to
the
appropriate
function
pointers.
Allocates
memory
to
the
struct.
*@return
pointer
to
the
list
head
*@param
printFunction
function
pointer
to
print
a
single
node
of
the
list
*@param
deleteFunction
function
pointer
to
delete
a
single
piece
of
data
from
the
list
*@param
compareFunction
function
pointer
to
compare
two
nodes
of
the
list
in
order
to
test
for
equality
or
order
**/
List
initializeList(char*
(*printFunction)(void*
toBePrinted),void
(*deleteFunction)(void*
toBeDeleted),int
(*compareFunction)(const
void*
first,const
void*
second)){
List
tmpList;
//Asserts
create
a
partial
function...
assert(printFunction
!=
NULL);
assert(deleteFunction
!=
NULL);
assert(compareFunction
!=
NULL);
tmpList.head
=
NULL;
tmpList.tail
=
NULL;
//initialize
list
length
to
0
tmpList.length
=
0;
tmpList.deleteData
=
deleteFunction;
tmpList.compare
=
compareFunction;
tmpList.printData
=
printFunction;
return
tmpList;
}
/**
Deletes
the
entire
linked
list,
freeing
all
memory.
*
uses
the
supplied
function
pointer
to
release
allocated
memory
for
the
data
*
returns
NULL
on
success
or
the
head
of
the
list
on
failure.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
List-type
dummy
node
*@return
on
success:
NULL,
on
failure:
head
of
list
**/
void
clearList(List*
list){
if
(list
==
NULL){
return;
}
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
return;
}
Node*
tmp;
while
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
!=
NULL){
list->deleteData(list->head->data);
string start = 6
string start = 23
string start = 29
NUMBER OF arrows IN WORD list->deleteData(list->head->data); : 3
tmp
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
list->head->next;
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->next; : 2
free(tmp);
}
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
NULL;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
NULL;
}
/**Function
for
creating
a
node
for
the
linked
list.
*
This
node
contains
abstracted
(void
*)
data
as
well
as
previous
and
next
*
pointers
to
connect
to
other
nodes
in
the
list
*@pre
data
should
be
of
same
size
of
void
pointer
on
the
users
machine
to
avoid
size
conflicts.
data
must
be
valid.
*data
must
be
cast
to
void
pointer
before
being
added.
*@post
data
is
valid
to
be
added
to
a
linked
list
*@return
On
success
returns
a
node
that
can
be
added
to
a
linked
list.
On
failure,
returns
NULL.
*@param
data
-
is
a
void
*
pointer
to
any
data
type.
Data
must
be
allocated
on
the
heap.
**/
Node*
initializeNode(void*
data){
Node*
tmpNode;
tmpNode
=
(Node*)malloc(sizeof(Node));
if
(tmpNode
==
NULL){
return
NULL;
}
tmpNode->data
string start = 9
NUMBER OF arrows IN WORD tmpNode->data : 1
=
data;
tmpNode->previous
string start = 9
NUMBER OF arrows IN WORD tmpNode->previous : 1
=
NULL;
tmpNode->next
string start = 9
NUMBER OF arrows IN WORD tmpNode->next : 1
=
NULL;
return
tmpNode;
}
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertBack(List*
list,
void*
toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
Node*
newNode
=
initializeNode(toBeAdded);
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
}else{
newNode->previous
string start = 9
NUMBER OF arrows IN WORD newNode->previous : 1
=
list->tail;
string start = 6
NUMBER OF arrows IN WORD list->tail; : 1
list->tail->next
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->tail->next : 2
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
newNode;
}
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
=
getLength(*list);
}
/**Inserts
a
Node
at
the
front
of
a
linked
list.
List
metadata
is
updated
*
so
that
head
and
tail
pointers
are
correct.
*@pre
'List'
type
must
exist
and
be
used
in
order
to
keep
track
of
the
linked
list.
*@param
list
pointer
to
the
dummy
head
of
the
list
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertFront(List*
list,
void*
toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
Node*
newNode
=
initializeNode(toBeAdded);
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL
&&
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
==
NULL){
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
}else{
newNode->next
string start = 9
NUMBER OF arrows IN WORD newNode->next : 1
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
list->head->previous
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->previous : 2
=
newNode;
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
newNode;
}
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
=
getLength(*list);
//updating
length
}
/**Returns
a
pointer
to
the
data
at
the
front
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
head
of
the
list
**/
void*
getFromFront(List
list){
if
(list.head
==
NULL){
return
NULL;
}
return
list.head->data;
string start = 11
NUMBER OF arrows IN WORD list.head->data; : 1
}
/**Returns
a
pointer
to
the
data
at
the
back
of
the
list.
Does
not
alter
list
structure.
*@pre
The
list
exists
and
has
memory
allocated
to
it
*@param
the
list
struct
*@return
pointer
to
the
data
located
at
the
tail
of
the
list
**/
void*
getFromBack(List
list){
if
(list.tail
==
NULL){
return
NULL;
}
return
list.tail->data;
string start = 11
NUMBER OF arrows IN WORD list.tail->data; : 1
}
void*
deleteDataFromList(List*
list,
void*
toBeDeleted){
if
(list
==
NULL
||
toBeDeleted
==
NULL){
return
NULL;
}
Node*
tmp
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
while(tmp
!=
NULL){
if
(list->compare(toBeDeleted,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeDeleted, : 1
tmp->data)
string start = 5
NUMBER OF arrows IN WORD tmp->data) : 1
==
0){
//Unlink
the
node
Node*
delNode
=
tmp;
if
(tmp->previous
string start = 6
NUMBER OF arrows IN WORD (tmp->previous : 1
!=
NULL){
tmp->previous->next
string start = 5
string start = 15
NUMBER OF arrows IN WORD tmp->previous->next : 2
=
delNode->next;
string start = 9
NUMBER OF arrows IN WORD delNode->next; : 1
}else{
list->head
string start = 6
NUMBER OF arrows IN WORD list->head : 1
=
delNode->next;
string start = 9
NUMBER OF arrows IN WORD delNode->next; : 1
}
if
(tmp->next
string start = 6
NUMBER OF arrows IN WORD (tmp->next : 1
!=
NULL){
tmp->next->previous
string start = 5
string start = 11
NUMBER OF arrows IN WORD tmp->next->previous : 2
=
delNode->previous;
string start = 9
NUMBER OF arrows IN WORD delNode->previous; : 1
}else{
list->tail
string start = 6
NUMBER OF arrows IN WORD list->tail : 1
=
delNode->previous;
string start = 9
NUMBER OF arrows IN WORD delNode->previous; : 1
}
void*
data
=
delNode->data;
string start = 9
NUMBER OF arrows IN WORD delNode->data; : 1
free(delNode);
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
=
getLength(*list);
//updating
length
return
data;
}else{
tmp
=
tmp->next;
string start = 5
NUMBER OF arrows IN WORD tmp->next; : 1
}
}
return
NULL;
}
/**
Uses
the
comparison
function
pointer
to
place
the
element
in
the
*
appropriate
position
in
the
list.
*
should
be
used
as
the
only
insert
function
if
a
sorted
list
is
required.
*@pre
List
exists
and
has
memory
allocated
to
it.
Node
to
be
added
is
valid.
*@post
The
node
to
be
added
will
be
placed
immediately
before
or
after
the
first
occurrence
of
a
related
node
*@param
list
a
pointer
to
the
dummy
head
of
the
list
containing
function
pointers
for
delete
and
compare,
as
well
as
a
pointer
to
the
first
and
last
element
of
the
list.
*@param
toBeAdded
a
pointer
to
data
that
is
to
be
added
to
the
linked
list
**/
void
insertSorted(List
*list,
void
*toBeAdded){
if
(list
==
NULL
||
toBeAdded
==
NULL){
return;
}
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
=
list->length
string start = 6
NUMBER OF arrows IN WORD list->length : 1
+
1;//to
many
places
to
call
get
length
if
(list->head
string start = 7
NUMBER OF arrows IN WORD (list->head : 1
==
NULL){
insertBack(list,
toBeAdded);
return;
}
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
list->head->data)
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->head->data) : 2
<=
0){
insertFront(list,
toBeAdded);
return;
}
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
list->tail->data)
string start = 6
string start = 12
NUMBER OF arrows IN WORD list->tail->data) : 2
>
0){
insertBack(list,
toBeAdded);
return;
}
Node*
currNode
=
list->head;
string start = 6
NUMBER OF arrows IN WORD list->head; : 1
while
(currNode
!=
NULL){
if
(list->compare(toBeAdded,
string start = 7
NUMBER OF arrows IN WORD (list->compare(toBeAdded, : 1
currNode->data)
string start = 10
NUMBER OF arrows IN WORD currNode->data) : 1
<=
0){
char*
currDescr
=
list->printData(currNode->data);
string start = 6
string start = 26
NUMBER OF arrows IN WORD list->printData(currNode->data); : 2
char*
newDescr
=
list->printData(toBeAdded);
string start = 6
NUMBER OF arrows IN WORD list->printData(toBeAdded); : 1
printf("Inserting
%s
before
%s\n",
newDescr,
currDescr);
free(currDescr);
free(newDescr);
Node*
newNode
=
initializeNode(toBeAdded);
newNode->next
string start = 9
NUMBER OF arrows IN WORD newNode->next : 1
=
currNode;
newNode->previous
string start = 9
NUMBER OF arrows IN WORD newNode->previous : 1
=
currNode->previous;
string start = 10
NUMBER OF arrows IN WORD currNode->previous; : 1
currNode->previous->next
string start = 10
string start = 20
NUMBER OF arrows IN WORD currNode->previous->next : 2
=
newNode;
currNode->previous
string start = 10
NUMBER OF arrows IN WORD currNode->previous : 1
=
newNode;
return;
}
currNode
=
currNode->next;
string start = 10
NUMBER OF arrows IN WORD currNode->next; : 1
}
return;
}
/**Returns
a
string
that
contains
a
string
representation
of
the
list
traversed
from
head
to
tail.
Utilize
an
iterator
and
the
list's
printData
function
pointer
to
create
the
string.
returned
string
must
be
freed
by
the
calling
function.
*@pre
List
must
exist,
but
does
not
have
to
have
elements.
*@param
list
Pointer
to
linked
list
dummy
head.
*@return
on
success:
char
*
to
string
representation
of
list
(must
be
freed
after
use).
on
failure:
NULL
**/
char*
toString(List
list){
ListIterator
iter
=
createIterator(list);
char*
str;
str
=
(char*)malloc(sizeof(char));
strcpy(str,
"");
void*
elem;
while(
(elem
=
nextElement(&iter))
!=
NULL){
char*
currDescr
=
list.printData(elem);
int
newLen
=
strlen(str)+50+strlen(currDescr);
str
=
(char*)realloc(str,
newLen);
strcat(str,
"\n");
strcat(str,
currDescr);
free(currDescr);
}
return
str;
}
ListIterator
createIterator(List
list){
ListIterator
iter;
iter.current
=
list.head;
return
iter;
}
void*
nextElement(ListIterator*
iter){
Node*
tmp
=
iter->current;
string start = 6
NUMBER OF arrows IN WORD iter->current; : 1
if
(tmp
!=
NULL){
iter->current
string start = 6
NUMBER OF arrows IN WORD iter->current : 1
=
iter->current->next;
string start = 6
string start = 15
NUMBER OF arrows IN WORD iter->current->next; : 2
return
tmp->data;
string start = 5
NUMBER OF arrows IN WORD tmp->data; : 1
}else{
return
NULL;
}
}
/*Passes
all
test
cases*/
int
getLength(List
list)
{
/*if(list
!=
NULL)
{
return
0;
//Check
this
case.
Should
be
correct
though
}*/
int
depth
=
0;
Node*
temp
=
list.head;
/*is
.
?*/
if(temp
==
NULL)
{
return
0;
/*Check
this
case.
Should
be
correct
though*/
}
while
(temp
!=
NULL)
{
depth++;
temp
=
temp->next;
string start = 6
NUMBER OF arrows IN WORD temp->next; : 1
}
//list.length
=
depth;
return
depth;
}
/*Dummy
function
for
now*/
void*
findElement(List
list,
bool
(*customCompare)(const
void*
first,const
void*
second),
const
void*
searchRecord)
{
//call
iterator,
compare,
repeat?
//error
check
for
nulls
if
(list.head
==
NULL)
{
return
NULL;
}
Node*
element
=
list.head;
//while
list
is
valid
while
(element
!=
NULL)
{
if(customCompare(element->data,
string start = 26
NUMBER OF arrows IN WORD if(customCompare(element->data, : 1
searchRecord)
==
true)
{
return
element->data;
string start = 9
NUMBER OF arrows IN WORD element->data; : 1
}
//printf("***%d***\n",
customCompare(element->data,
string start = 23
NUMBER OF arrows IN WORD customCompare(element->data, : 1
searchRecord));
element
=
element->next;
string start = 9
NUMBER OF arrows IN WORD element->next; : 1
}
return
NULL;
}
/**************
2750
W2018
A1
GEDCOM
Parser
Student1
**************/
#include
"../include/GEDCOMparser.h"
#include
"../include/LinkedListAPI.h"
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
/*Header
functions*/
/**
Function
that
returns
a
single
line
of
the
gedcom
file
*
that
it
reads
character
by
character
*@return
a
single
gedcom
file
line
as
a
string
(char*)
*@param
filep
-
the
pointer
to
the
gedcom
file
*@param
lineNumber
-
an
integer
pointer
that
is
increased
for
every
line
read
*@param
line
-
a
character
array
allocated
in
the
calling
function
that
the
line
is
read
into
**/
char*
readLine(FILE
*filep,
int*
lineNumber,
char*
line)
{
//
can
end
with
\n
or
\r
or
combo.
SEGFAULTs
ON
END
OF
FILE
static
int
EOFread;
char
temp;
char
nextTemp;
int
i
=
-1;
if(EOFread
==
1)
{
return
NULL;//null?
}
do{
i++;
temp
=
fgetc(filep);
if(temp
==
EOF)
{
//line
=
NULL;
//printf("hit
eof\n");
EOFread
=
1;
temp
=
'\0';
line[i]
=
temp;
*lineNumber
+=
1;
return
line;
}
line[i]
=
temp;
if(i
>=
255)
{
//line
too
large
error
}
if(temp
==
'\n'
||
temp
==
'\r')
{
int
posi
=
ftell(filep);
nextTemp
=
fgetc(filep);
if(nextTemp
==
'\n'
||
nextTemp
==
'\r')
{
i++;
line[i]
=
nextTemp;
}
else
{
fseek(filep,
posi,
SEEK_SET);
}
}
}while(temp
!=
'\n'
&&
temp
!=
'\r');
*lineNumber
+=
1;
return
line;
}
/**
Function
that
returns
a
two
dimentional
array
containing
each
word
of
a
*
gedcom
line
tokenized
by
spaces
*@return
a
2D
array
countaing
each
word
in
the
input
line
*@param
numWords
-
an
int
pointer
that
is
set
to
the
sumber
of
words
in
the
2D
array
*@param
line
-
a
char*
containing
the
line
to
be
tokenized
**/
char**
splitLine(char*
line,
int*
numWords)
{
char
**wordArray
=
calloc(2,
sizeof(char
*));
//was
malloc
1
*
sizeof
char*
char
*tempWord;
int
i
=
0;
tempWord
=
strtok(line,
"
");
if
(tempWord
!=
NULL)
{
wordArray[0]
=
malloc((strlen(tempWord)
+
1)
*
sizeof(char));
strcpy(wordArray[0],
tempWord);
i
=
1;
}
do{
tempWord
=
strtok(NULL,
"
");
//printf("tempword:
%s\n",
tempWord);
if
(tempWord
!=
NULL)
{
wordArray
=
realloc(wordArray,
(i
+
1)
*sizeof(char
*));//this,
called
by
find
submitter,
allocateed
memory
that
is
not
properly
freed
wordArray[i]
=
malloc((strlen(tempWord)
+
1)
*
sizeof(char));
strcpy(wordArray[i],
tempWord);
i++;
}
/*put
stuff
in*/
}while(tempWord
!=
NULL);
*numWords
=
i;
return
wordArray;
}
/*Submitter
functions*/
/**
Function
that
scans
the
gedcom
file
for
a
submitter
xref.
when
found,
*
it
returns
leaving
the
file
pointer
at
the
correct
place
in
the
file
*@return
an
integer
representing
whether
or
not
the
submitter
was
found
*@param
filePointer
-
the
pointer
to
the
gedcom
file
*@param
currentLine
-
a
char*
containing
the
current
line
(so
it
can
be
checked
if
it
is
the
submitter
xref)
*@param
submitterReference
-
a
char*
containing
the
xref
that
needs
to
be
matched
**/
int
findSubmitter(FILE
*filePointer,
char*
currentLine,
char*
submitterReference)
{
int
foundSubmitterFlag
=
0;
int
intForReadline
=
0;
int
stringWordCount
=
0;
char
currentLineCopy[257];
char
**lineArray;
strcpy(currentLineCopy,
currentLine);//because
strtok
in
splitline
is
destructive
to
input
string
lineArray
=
splitLine(currentLineCopy,
&stringWordCount);//needs
to
be
freed?
Small
memory
leak.
Consistant
with
reading
one
line
/*Strip
newlines
on
submitter
refernce
(could
have
sworn
was
already
done)*/
int
y;
for(y
=
0;
y
<
strlen(submitterReference);
y++)/*used
to
be
no
-1*/
{
if(submitterReference[y]
==
'\n')
{
submitterReference[y]
=
'\0';
}
else
if(submitterReference[y]
==
'\r')
{
submitterReference[y]
=
'\0';
}
}
//checking
if
this
line
found
a
match,
so
i
can
free
linearray,
and
remove
this
memory
leak
if(strcmp(lineArray[0],
"0")
==
0
&&
strcmp(lineArray[1],
submitterReference)
==
0)
{
//printf("MATCH
FOUND
ON
FIRST
LINE\nMatch
is:
%s",
lineArray[1]);
foundSubmitterFlag
=
1;
int
k
=
0;
for(k
=
0;
k
<
stringWordCount;
k++)//was
stringWordCount
[[maybe
+
1?
Its
like
that
in
splitline...]]
{
free(lineArray[k]);
}
free(lineArray);
return
foundSubmitterFlag;
}
else{
int
k
=
0;
for(k
=
0;
k
<
stringWordCount;
k++)//was
stringWordCount
[[maybe
+
1?
Its
like
that
in
splitline...]]
{
free(lineArray[k]);
}
free(lineArray);
}
char**
lineArray2;
int
loopCounter
=
0;
//keeping
track
of
the
largest
ammount
of
memory
that
was
realloc'd
for
string
word
count
do
{
if(loopCounter
!=
0)
{
int
k
=
0;
for(k
=
0;
k
<
stringWordCount
;
k++)//was
stringWordCount
{
free(lineArray2[k]);
}
free(lineArray2);
}
readLine(filePointer,
&intForReadline
,currentLine);//how
does
this
work?!
should
be
currentLine
=
readL...
strcpy(currentLineCopy,
currentLine);
stringWordCount
=
0;//this
really
shouldnt
change
anything,,,but
lineArray2
=
splitLine(currentLineCopy,
&stringWordCount);
loopCounter++;//how
to
stop
this
from
infinely
looping
if
there
is
no
submission
record
EOF/
Trailer
tag
int
k,
g;
for
(k
=
0;
k
<
stringWordCount;
k++)
{
if(lineArray2[k][0]
==
'T'
&&
lineArray2[k][1]
==
'R'
&&
lineArray2[k][2]
==
'L'
&&
lineArray2[k][3]
==
'R')
{
//printf("HIT
TRAILER
BEFORE
SUBMITTER
RECORD
WAS
FOUND\n");
int
z
=
0;
for(z
=
0;
z
<
stringWordCount;
z++)//was
stringWordCount
{
free(lineArray2[z]);
}
free(lineArray2);
return
foundSubmitterFlag;
}
for(g
=
0;
g
<
strlen(lineArray2[k]);
g++)
{
if(lineArray2[k][g]
==
EOF)
{
//printf("REACHED
END
OF
FILE
BEFORE
FINDING
SUBMITTER\n");
//free
array2Memory
int
z
=
0;
for(z
=
0;
z
<
stringWordCount;
z++)//was
stringWordCount
{
free(lineArray2[z]);
}
free(lineArray2);
return
foundSubmitterFlag;
}
}
}
}while(strcmp(lineArray2[0],
"0")
!=
0
||
strcmp(lineArray2[1],
submitterReference)
!=
0);
//printf("SUBMITTER
MATCH\nMatch
is:
%s\n",
lineArray2[1]);
foundSubmitterFlag
=
1;
int
k
=
0;
for(k
=
0;
k
<
stringWordCount;
k++)//was
stringWordCount
{
free(lineArray2[k]);
}
free(lineArray2);
return
foundSubmitterFlag;
}
/*Individuals
functions*/
/**
Function
that
searches
the
file
for
an
individual
record.
returns
file
pointer
in
correct
location
*@return
an
int
representing
if
individual
was
found
*@param
filePointer
-
the
pointer
to
the
gedcom
file
*@param
currentLine
-
a
char*
that
can
be
checked
if
it
is
the
start
of
an
individual
record
**/
int
findIndividual(FILE
*filePointer,
char*
currentLine)
{
//search
for
the
tag
'INDI'
in
the
third
word
of
a
line
int
outOfIndividuals
=
0;
int
hitEOF
=
3;
int
stringWordCount
=
0;
int
readLineNum
=
0;
char**
currLineArray
=
splitLine(currentLine,
&stringWordCount);
int
y;
if(stringWordCount
>=
3)
{
for(y
=
0;
y
<
strlen(currLineArray[2]);
y++)/*used
to
be
no
-1*/
{
if(currLineArray[2][y]
==
'\n')
{
currLineArray[2][y]
=
'\0';
}
else
if(currLineArray[2][y]
==
'\r')
{
currLineArray[2][y]
=
'\0';
}
}
}
/*if(stringWordCount
>=
3)
{
printf("\n\nDEBUGGING
FIND
IND.
*****\nLINE
BEFORE
WHILE
LOOP:
%s\n",
currLineArray[2]);
}*/
while(stringWordCount
<
3
||
strcmp(currLineArray[2],
"INDI")
!=
0)
{
/*if(stringWordCount
>=
3)
{
printf("IN
WHILE
LOOP,
LINE:
%s\n",
currLineArray[2]);
}*/
//check
if
hit
end
of
file
int
k,
g;
for
(k
=
0;
k
<
stringWordCount;
k++)
{
if(currLineArray[k][0]
==
'T'
&&
currLineArray[k][1]
==
'R'
&&
currLineArray[k][2]
==
'L'
&&
currLineArray[k][3]
==
'R')
{
//printf("HIT
TRAILER
SEARCHING
FOR
INDIVIDUAL\n");
int
z
=
0;
for(z
=
0;
z
<
stringWordCount;
z++)//was
stringWordCount
{
free(currLineArray[z]);
}
free(currLineArray);
return
outOfIndividuals;
}
for(g
=
0;
g
<
strlen(currLineArray[k]);
g++)
{
if(currLineArray[k][g]
==
EOF)
{
//printf("REACHED
END
OF
FILE
SEARCHING
FOR
INDIVIDUAL\nFILE
MISSING
TRAILER!\n");
int
z
=
0;
for(z
=
0;
z
<
stringWordCount;
z++)//was
stringWordCount
{
free(currLineArray[z]);
}
free(currLineArray);
return
hitEOF;
//means
trailer
is
missing.
Triggers
error
return
in
parser
}
}
}
/*int
p
=
0;
for(p
=
0;
p
<
stringWordCount;
p++)
{
free(currLineArray[p]);
}
free(currLineArray);*/
currentLine
=
readLine(filePointer,
&readLineNum,
currentLine);
if(currentLine
==
NULL)
{
//printf("REACHED
END
OF
FILE
SEARCHING
FOR
INDIVIDUAL\nFILE
MISSING
TRAILER!\n");
//printf("Readline
returned
Null\n");
//printf("*%s*\n",
currLineArray[stringWordCount
-
1]);
outOfIndividuals
=
3;
//means
trailer
is
missing.
Triggers
error
return
in
parser
int
p
=
0;
for(p
=
0;
p
<
stringWordCount;
p++)
{
free(currLineArray[p]);
}
free(currLineArray);
return
outOfIndividuals;
}
int
p
=
0;
for(p
=
0;
p
<
stringWordCount;
p++)
{
free(currLineArray[p]);
}
free(currLineArray);
currLineArray
=
splitLine(currentLine,
&stringWordCount);
int
y;
if(stringWordCount
>=
3)
{
for(y
=
0;
y
<
strlen(currLineArray[2]);
y++)/*used
to
be
no
-1*/
{
if(currLineArray[2][y]
==
'\n')
{
currLineArray[2][y]
=
'\0';
}
else
if(currLineArray[2][y]
==
'\r')
{
currLineArray[2][y]
=
'\0';
}
}
}
}
//printf("Found
individual?\nind:
%s",
currLineArray[2]);
int
k
=
0;
for(k
=
0;
k
<
stringWordCount;
k++)//was
stringWordCount
{
free(currLineArray[k]);
}
free(currLineArray);
outOfIndividuals
=
1;
return
outOfIndividuals;
}
/**************
2750
W2018
A1
GEDCOM
Parser
Student1
**************/
#include
"../include/GEDCOMparser.h"
#include
"../include/LinkedListAPI.h"
#include
"../include/GEDCOMutilities.h"
#include
<stdio.h>
#include
<string.h>
#include
<stdlib.h>
#include
<stdbool.h>
/**
Function
to
create
a
GEDCOM
object
based
on
the
contents
of
an
GEDCOM
file.
*@pre
File
name
cannot
be
an
empty
string
or
NULL.
File
name
must
have
the
.ged
extension.
File
represented
by
this
name
must
exist
and
must
be
readable.
*@post
Either:
A
valid
GEDCOM
has
been
created,
its
address
was
stored
in
the
variable
obj,
and
OK
was
returned
or
An
error
occurred,
the
GEDCOM
was
not
created,
all
temporary
memory
was
freed,
obj
was
set
to
NULL,
and
the
appropriate
error
code
was
returned
*@return
the
error
code
indicating
success
or
the
error
encountered
when
parsing
the
GEDCOM
*@param
fileName
-
a
string
containing
the
name
of
the
GEDCOM
file
*@param
a
double
pointer
to
a
GEDCOMobject
struct
that
needs
to
be
allocated
**/
GEDCOMerror
createGEDCOM(char*
fileName,
GEDCOMobject**
obj)
{
/*Create
variables
for
function*/
//Create
Struct
that
contains
error
enum
and
list
int
GEDCOMerror
parsingError;
*obj
=
malloc(sizeof(GEDCOMobject));
//This
section
attempts
to
open
GEDCOM
file
of
given
fileName
/*TO
DO
FOR
FILE
OPENING.
INV_FILE
errors.
Line
field
=
-1
*
check
if
file
is
null
*
check
if
filename
is
empty
string
*
check
if
file
has
.ged
extention
*
file
does
not
exist
or
cannot
be
opened
*
*/
//Before
opening:
int
i
=
0;
//check
for,
and
remove
newline
in
file
name
for
(i
=
0;
i
<
strlen(fileName);
i++)
{
if(fileName[i]
==
'\n')
{
fileName[i]
=
'\0';
}
}
i
=
0;
//check
if
empty
string
if(fileName[0]
==
'\0')
{
//return
GEDCOM
filename
empty
string
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
INV_FILE
Line
=
-1
*obj
=
NULL;
parsingError.type
=
INV_FILE;
parsingError.line
=
-1;
return
parsingError;
}
//check
for
.ged
extension
bool
extensionFlag
=
false;
for
(i
=
0;
i
<
strlen(fileName);
i++)
{
if(fileName[i]
==
'.')
{
if(fileName[i
+
1]
==
'g')
{
if(fileName[i
+
2]
==
'e')
{
if(fileName[i
+
3]
==
'd')
{
extensionFlag
=
true;
break;
}
}
}
}
}
if
(extensionFlag
==
false)
{
//return
File
does
not
have
.ged
extension
INV_FILE
Line
=
-1
*obj
=
NULL;
parsingError.type
=
INV_FILE;
parsingError.line
=
-1;
return
parsingError;
}
i
=
0;
FILE
*gedFile
=
fopen(fileName,
"r");
if
(gedFile
==
NULL)
{
//return
GEDCOM
file
not
found
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
INV_FILE
Line
=
-1
fclose(gedFile);
*obj
=
NULL;
parsingError.type
=
INV_FILE;
parsingError.line
=
-1;
return
parsingError;
}
/*File
opening
errors
section
complete********/
/*Begin
header
parsing*/
int
SOURpresent
=
0;
int
DESTpresent
=
1;
//change
this
to
a
0
if
you
want
to
file
to
work
as
if
DEST
tags
are
mandatory
int
SUBMpresent
=
0;
int
GEDCpresent
=
0;
int
VERSpresent
=
0;
int
FORMpresent
=
0;
int
CHARpresent
=
0;
int
headerLineCounter
=
0;
char*
lastHeaderLineSaved
=
calloc(257,
sizeof(char*));
/*char*
parseHeader(FILE
*filePointer)
{*/
int
fileLineNum
=
0;
int
stringNumWords
=
0;
char*
fileLine
=
calloc(257,
sizeof(char*));
char
tempLine[257]=
"";
/*check
line
one
is
0
HEAD*/
memset(tempLine,
0,
strlen(tempLine));
memset(fileLine,
0,
strlen(fileLine));
strcpy(tempLine,
readLine(gedFile,
&fileLineNum,
fileLine));
tempLine[strlen(tempLine)]
=
'\0';
//printf("File
line
%d:
%s",fileLineNum,
tempLine);
char
**lineArray;
lineArray
=
splitLine(tempLine,
&stringNumWords);
int
u
=
0;
for(u
=
0;
u
<
strlen(lineArray[1]);
u++)
{
if(lineArray[1][u]
==
'\n')
{
lineArray[1][u]
=
'\0';
}
else
if(lineArray[1][u]
==
'\r')
{
lineArray[1][u]
=
'\0';
}
}
if(strcmp(lineArray[0],
"0")
!=
0
||
strcmp(lineArray[1],
"HEAD")
!=
0)
{
//printf("File
first
line
bad.\n");
for
(u
=
0;
u
<
stringNumWords;
u++)
{
free(lineArray[u]);
}
free(lineArray);
free(fileLine);
//return
NULL;
fclose(gedFile);
*obj
=
NULL;
//printf("0
head
not
found
as
start
of
file\n");
/*DELETE
ME*/
parsingError.type
=
INV_GEDCOM;
parsingError.line
=
-1;
return
parsingError;
}
//printf("First
line
correct\n");
for
(u
=
0;
u
<
stringNumWords;
u++)
{
//printf("word
%d:
%s\n",u
+1,
lineArray[u]);
free(lineArray[u]);
}
free(lineArray);
//array
of
strings
of
level
one
header
tags
sour+gedc
gedc
sour
sour
sour
date
any
any
char
headerTags[20][5]
=
{"SOUR",
"DEST",
"DATE",
"SUBM",
"SUBN",
"FILE",
"COPR",
"GEDC",
"CHAR",
"LANG",
"PLAC",
"NOTE",
"VERS",
"FORM",
"NAME",
"CORP",
"DATA",
"TIME",
"CONC",
"CONT"};
/*Possible
LVL
3
address
tag
for
CORP*/
/*Possible
LVL
4
CONT
/
CONC
tag
for
COPR*/
/*Possible
LVL
2
CONC
/
CONT
tag
for
NOTE*/
char
tempString[257]
=
"";
char
prevTag[257]
=
"";
char
prevLvlTwoTag[257]
=
"";
char*
lineAfterHeader
=
calloc(257,
sizeof(char));
/*This
holds
the
line
after
the
header
for
the
section
that
parses
the
submitter*/
char*
submitterXref
=
calloc(257,
sizeof(char));
//obj
=
malloc(sizeof(GEDCOMobject
*));
//*obj
=
malloc(sizeof(GEDCOMobject));
moved
to
top
//Header
*gedHead
=
malloc(sizeof(Header));
(*obj)->header
string start = 8
NUMBER OF arrows IN WORD (*obj)->header : 1
=
malloc(sizeof(Header));
Header
*gedHead
=
(*obj)->header;
string start = 8
NUMBER OF arrows IN WORD (*obj)->header; : 1
do
{
headerLineCounter++;
memset(tempString,
0,
strlen(tempString));
memset(fileLine,
0,
strlen(fileLine));
strcpy(tempString,
readLine(gedFile,
&fileLineNum,
fileLine));
tempString[strlen(tempString)]
=
'\0';
//printf("File
line
%d:
%s",fileLineNum,
tempString);
strcpy(lastHeaderLineSaved,
tempString);
if
(tempString[0]
==
'0')
{
//printf("THIS
STRING
TO
BE
RETURNED
%s\n",
tempString);
//char*
lineAfterHeader
=
calloc(257,
sizeof(char*));
strcpy(lineAfterHeader,
tempString);
free(fileLine);
//return
lineToReturn;
****************This
line
must
go
to
the
parse
individuals
function(actually
parse
submitter)
//THIS
LINE
JUST
FOR
testing
vv
//free(lineAfterHeader);
}
lineArray
=
splitLine(tempString,
&stringNumWords);
for
(u
=
0;
u
<
stringNumWords;
u++)
{
int
n
=
0;
for
(n
=
0;
n
<
20;
n++)/*12
=
num
of
lvl
one
head
tags*/
{
int
y;
for(y
=
0;
y
<
strlen(lineArray[1])
+
1;
y++)/*used
to
be
no
-1*/
{
if(lineArray[1][y]
==
'\n')
{
lineArray[1][y]
=
'\0';
}
else
if(lineArray[1][y]
==
'\r')
{
lineArray[1][y]
=
'\0';
}
}
if(strcmp(lineArray[1],
headerTags[n])
==
0)
{
//printf("%s\n",headerTags[n]);
if
(n
==
0)/*SOUR*/
{
//printf("SOUR
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
ARGS:
");/*MANDATORY
TAG**********/
int
w
=
0;
u
+=
stringNumWords;
strcpy(gedHead->source,
string start = 16
NUMBER OF arrows IN WORD strcpy(gedHead->source, : 1
"");
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
strcat(gedHead->source,
string start = 16
NUMBER OF arrows IN WORD strcat(gedHead->source, : 1
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
SOURpresent
=
1;
}
else
if(n
==
1)/*DEST*/
{
//printf("DEST
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
ARGS:
");/*MANDATORY
TAG**********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
DESTpresent
=
1;
}
else
if(n
==
2)/*DATE*/
{
if(strcmp(lineArray[0],
"0")
==
0)//Maybe
strcmp
needed?
{
//printf("**LVL
ONE
DATE**\nDATE
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
ARGS:
");
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
}
else
if
(strcmp(lineArray[0],
"3")
==
0)//date
subtag
in
sour
{
//printf("**LVL
TWO
SOUR
DATE**\nDATE
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
ARGS:
");
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
}
}
else
if(n
==
3)/*SUBM*/
{
//printf("SUBM
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
ARGS:
");/*MANDATORY
TAG**********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
strcpy(submitterXref,
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
SUBMpresent
=
1;
}
else
if(n
==
4)/*SUBN*/
{
//printf("SUBN
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
ARGS:
");
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
}
else
if(n
==
5)/*FILE*/
{
//printf("FILE
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
ARGS:
");
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
}
else
if(n
==
6)/*COPR
on
LVL
1.*/
{
if(strcmp(lineArray[0],
"0")
==
0)//Maybe
strcmp
needed?
{
//printf("**LVL
ONE
COPR**\nCOPR
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
ARGS:
");
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
}
else
if
(strcmp(lineArray[0],
"3")
==
0)
{
//printf("**LVL
THREE
COPR**\nCOPR
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
ARGS:
");
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevLvlTwoTag,headerTags[n]);
}
}
else
if(n
==
7)/*GEDC*/
{
//printf("GEDC
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
ARGS:
");/*MANDATORY
TAG**********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
GEDCpresent
=
1;
}
else
if(n
==
8)/*CHAR*/
{
//printf("CHAR
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);/*MANDATORY
TAG**********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
int
q;
for(q
=
0;
q
<
strlen(lineArray[w]);
q++)/*used
to
be
no
-1*/
{
if(lineArray[w][q]
==
'\n')
{
lineArray[w][q]
=
'\0';
}
else
if(lineArray[w][q]
==
'\r')
{
lineArray[w][q]
=
'\0';
}
}
//printf("%s
",
lineArray[w]);
if(strcmp(lineArray[w],
"ANSEL")
==
0)
{
gedHead->encoding
string start = 9
NUMBER OF arrows IN WORD gedHead->encoding : 1
=
ANSEL;
}
else
if(lineArray[w][0]
==
'U'
&&
lineArray[w][1]
==
'T'
&&
lineArray[w][2]
==
'F')
{
gedHead->encoding
string start = 9
NUMBER OF arrows IN WORD gedHead->encoding : 1
=
UTF8;
}
else
if(strcmp(lineArray[w],
"UNICODE")
==
0)
{
gedHead->encoding
string start = 9
NUMBER OF arrows IN WORD gedHead->encoding : 1
=
UNICODE;
}
else
if(strcmp(lineArray[w],
"ASCII")
==
0)
{
gedHead->encoding
string start = 9
NUMBER OF arrows IN WORD gedHead->encoding : 1
=
ASCII;
}
/*else{
printf("****CHAR
NOT
ASSIGNED
AN
ENCODING*****\n");
//its
because
newline
FIXED
}*/
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
CHARpresent
=
1;
}
else
if(n
==
9)/*LANG*/
{
//printf("LANG
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
}
else
if(n
==
10)/*PLAC*/
{
//printf("PLAC
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//
printf("\n");
strcpy(prevTag,headerTags[n]);
}
else
if(n
==
11)/*NOTE*/
{
//printf("NOTE
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
}
else
if(n
==
12)/*VERS*/
{
if(strcmp(prevTag,
headerTags[7])
==
0)/*Sub
tag
to
GEDC*/
{
//printf("**PREV
TAG
WAS
GEDC**\n");
//printf("VERS
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);/*MANDATORY
GEDC
SUBTAG*********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
//gedHead.gedcVersion
=
atof(lineArray[w]);
//(*obj)->header.gedcVersion
string start = 10
NUMBER OF arrows IN WORD //(*obj)->header.gedcVersion : 1
=
atof(lineArray[w]);
gedHead->gedcVersion
string start = 9
NUMBER OF arrows IN WORD gedHead->gedcVersion : 1
=
atof(lineArray[w]);
}
//(*obj)->header
string start = 10
NUMBER OF arrows IN WORD //(*obj)->header : 1
=
gedHead;
//gedHead.gedcVersion
=
atof(lineArray[w]);
//printf("\n");
strcpy(prevLvlTwoTag,headerTags[n]);
VERSpresent
=
1;
}
else
if(strcmp(prevTag,
headerTags[0])
==
0)/*Sub
tag
to
SOUR*/
{
//printf("**PREV
TAG
WAS
SOUR**\n");
//printf("VERS
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);/*this
tag
not
mandatory*********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//
printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevLvlTwoTag,headerTags[n]);
}
else
if(strcmp(prevTag,
headerTags[8])
==
0)/*Sub
tag
to
CHAR*/
{
//printf("**PREV
TAG
WAS
CHAR**\n");
//printf("VERS
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);/*this
tag
not
mandatory*********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//
printf("%s
",
lineArray[w]);
}
//
printf("\n");
strcpy(prevLvlTwoTag,headerTags[n]);
}
}
else
if(n
==
13)/*FORM*/
{
if(strcmp(prevTag,
headerTags[7])
==
0)/*Sub
tag
to
GEDC*/
{
//printf("**PREV
TAG
WAS
GEDC**\n");
//printf("FORM
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);/*MANDATORY
GEDC
SUBTAG*********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevTag,headerTags[n]);
FORMpresent
=
1;
}
else
if(strcmp(prevTag,
headerTags[10])
==
0)/*Sub
tag
to
PLAC*/
{
//printf("**PREV
TAG
WAS
PLAC**\n");
//printf("FORM
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);/*this
tag
not
mandatory*********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//
printf("\n");
strcpy(prevTag,headerTags[n]);
}
}
else
if(n
==
14)/*NAME*/
{
if(strcmp(prevTag,
headerTags[0])
==
0)/*Sub
tag
to
SOUR*/
{
//printf("**PREV
TAG
WAS
SOUR**\n");
//printf("NAME
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);/*this
tag
not
mandatory*********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevLvlTwoTag,headerTags[n]);
}
}
else
if(n
==
15)/*CORP*/
{
if(strcmp(prevTag,
headerTags[0])
==
0)/*Sub
tag
to
SOUR*/
{
//printf("**PREV
TAG
WAS
SOUR**\n");
//printf("CORP
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);/*this
tag
not
mandatory*********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevLvlTwoTag,headerTags[n]);
}
}
//ADDRESS
TAG
LVL
3
UNDER
CORT
TAG
else
if(n
==
16)/*DATA*/
{
if(strcmp(prevTag,
headerTags[0])
==
0)/*Sub
tag
to
SOUR*/
{
//printf("**PREV
TAG
WAS
SOUR**\n");
//printf("DATA
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);/*this
tag
not
mandatory*********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevLvlTwoTag,headerTags[n]);
}
}
else
if(n
==
17)/*TIME*/
{
if(strcmp(prevTag,
headerTags[0])
==
0)/*Sub
tag
to
SOUR*/
{
//printf("**PREV
TAG
WAS
SOUR**\n");
//printf("DATA
->#%s
string start = 2
NUMBER OF arrows IN WORD ->#%s : 1
ARGS:
",
lineArray[0]);/*this
tag
not
mandatory*********/
int
w
=
0;
u
+=
stringNumWords;
for
(w
=
2;
w
<
stringNumWords;
w++)/*-2
becuase
both
first
word
is
id
num,
second
is
term*/
{
//printf("%s
",
lineArray[w]);
}
//printf("\n");
strcpy(prevLvlTwoTag,headerTags[n]);
}
}
}
}
}
for
(u
=
0;
u
<
stringNumWords;
u++)
{
//printf("word
%d:
%s\n",u
+1,
lineArray[u]);
free(lineArray[u]);
}
free(lineArray);
}while(tempString[0]
!=
'0');/*Next
record
(that
is
not
header)
starts*/
//free(fileLine);
//return
NULL;
//}
/*End
header
reading*/
/*Mandatory
head
tag
verification*/
if(SOURpresent
==
0)
{
//sour
never
showed
fclose(gedFile);
free(lineAfterHeader);
free(submitterXref);
free(lastHeaderLineSaved);
*obj
=
NULL;
parsingError.type
=
INV_HEADER;
parsingError.line
=
headerLineCounter;
return
parsingError;
}
if(DESTpresent
==
0)/*This
tag
not
present
in
sample
gedcom
files*/
{
//dest
never
showed
fclose(gedFile);
free(lineAfterHeader);
free(submitterXref);
free(lastHeaderLineSaved);
*obj
=
NULL;
parsingError.type
=
INV_HEADER;
parsingError.line
=
headerLineCounter;
return
parsingError;
}
if(SUBMpresent
==
0)
{
fclose(gedFile);
free(lineAfterHeader);
free(submitterXref);
free(lastHeaderLineSaved);
*obj
=
NULL;
parsingError.type
=
INV_HEADER;
parsingError.line
=
headerLineCounter;
return
parsingError;
}
if(GEDCpresent
==
0)
{
fclose(gedFile);
free(lineAfterHeader);
free(submitterXref);
free(lastHeaderLineSaved);
*obj
=
NULL;
parsingError.type
=
INV_HEADER;
parsingError.line
=
headerLineCounter;
return
parsingError;
}
if(VERSpresent
==
0)
{
fclose(gedFile);
free(lineAfterHeader);
free(submitterXref);
free(lastHeaderLineSaved);
*obj
=
NULL;
parsingError.type
=
INV_HEADER;
parsingError.line
=
headerLineCounter;
return
parsingError;
}
if(FORMpresent
==
0)
{
fclose(gedFile);
free(lineAfterHeader);
free(submitterXref);
free(lastHeaderLineSaved);
*obj
=
NULL;
parsingError.type
=
INV_HEADER;
parsingError.line
=
headerLineCounter;
return
parsingError;
}
if(CHARpresent
==
0)
{
fclose(gedFile);
free(lineAfterHeader);
free(submitterXref);
free(lastHeaderLineSaved);
*obj
=
NULL;
parsingError.type
=
INV_HEADER;
parsingError.line
=
headerLineCounter;
return
parsingError;
}
/*End
mandatory
head
tag
verification*/
/*End
header
parsing*/
/*Begin
submitter
parsing(for
header)*/
//lineAfterHeader
holds
the
first
line
of
the
file
after
the
header
ends
[first
'0'
line]
int
posi
=
ftell(gedFile);
//ftell
position
before
scanningg
for
submitter
int
foundSubmitter
=
0;
int
submNamePresent
=
0;
foundSubmitter
=
findSubmitter(gedFile,
lineAfterHeader,
submitterXref);
//free(lineAfterHeader);
if(foundSubmitter
==
0)
{
fclose(gedFile);
free(submitterXref);
free(lineAfterHeader);//just
done
free(lastHeaderLineSaved);
*obj
=
NULL;
parsingError.type
=
INV_HEADER;
parsingError.line
=
headerLineCounter;
return
parsingError;
}
char*
subLine
=
calloc(257,
sizeof(char*));
//Submitter
*gedcSubmitter
=
calloc(1,
sizeof(gedcSubmitter)
+
(65
*
sizeof(char))
+
(2
*
sizeof(List))
+
257
*
sizeof(gedcSubmitter->address[0]));
string start = 22
NUMBER OF arrows IN WORD sizeof(gedcSubmitter->address[0])); : 1
Submitter
*gedcSubmitter
=
malloc(sizeof(Submitter));
gedHead->submitter
string start = 9
NUMBER OF arrows IN WORD gedHead->submitter : 1
=
gedcSubmitter;
char
**submitArray;
int
subArrLen
=
0;
int
y,
t,
h,
subLineCounter
=
0;
do
{
subLine
=
readLine(gedFile,
&fileLineNum
,subLine);
//check
if
subline
is
null
before
splitting
submitArray
=
splitLine(subLine,
&subArrLen);
/*
Strip
newlines
from
every
word*/
for(t
=
0;
t
<
subArrLen;
t++)//is
this
catching
everything,
or
not
the
last
word..?
{
for(y
=
0;
y
<
strlen(submitArray[t]);
y++)
{
if(submitArray[t][y]
==
EOF)
{
//printf("is
broke\n");
break;
}
if(submitArray[t][y]
==
'\n')
{
submitArray[t][y]
=
'\0';
}
else
if(submitArray[t][y]
==
'\r')
{
submitArray[t][y]
=
'\0';
}
}
}
if(strcmp(submitArray[1],
"NAME")
==
0)
{
//gedHead->gedcVersion
string start = 11
NUMBER OF arrows IN WORD //gedHead->gedcVersion : 1
=
atof(lineArray[w]);
submNamePresent
=
1;
char
nameToStruct[70]
=
"";
//printf("Name
tag
present!\n");
for(h
=
2;
h
<
subArrLen;
h++)
{
strcat(nameToStruct,
submitArray[h]);
if(h
<
subArrLen
-
1)
{
strcat(nameToStruct,
"
");
}
}
//printf("\nSTRING:
*%s*\n",
nameToStruct);
strcpy(gedcSubmitter->submitterName,
string start = 22
NUMBER OF arrows IN WORD strcpy(gedcSubmitter->submitterName, : 1
nameToStruct);
}
if(strcmp(submitArray[1],
"ADDR")
==
0)
{//printf("FOUND
AN
ADDRESS!!!!!!!!!!!!!!!!!!!!\n");
//gedHead->gedcVersion
string start = 11
NUMBER OF arrows IN WORD //gedHead->gedcVersion : 1
=
atof(lineArray[w]);
//
char
addToStruct[70]
=
"";
//printf("Name
tag
present!\n");
for(h
=
2;
h
<
subArrLen;
h++)
{
//strcat(addToStruct,
submitArray[h]);
if(h
<
subArrLen
-
1)
{
//strcat(addToStruct,
"
");
}
}
//Submitter
*str
=
malloc(sizeof(Submitter)+
(2
*
strlen(addToStruct)));
//printf("\nSTRING:
*%s*\n",
nameToStruct);
//strcpy(gedcSubmitter->address,
string start = 24
NUMBER OF arrows IN WORD //strcpy(gedcSubmitter->address, : 1
addToStruct);
//printf("ADDR:
%s\n",
addToStruct);
}
subLineCounter++;
}while(submitArray[subLineCounter
-
1][0]
==
'0');
/*Submitter
name
not
present
->
string start = 2
NUMBER OF arrows IN WORD -> : 1
invalid
submitter->invalid
string start = 11
NUMBER OF arrows IN WORD submitter->invalid : 1
header*/
if(submNamePresent
==
0)
{
for(y
=
0;
y
<
subArrLen;
y++)
{
free(submitArray[y]);
}
free(lastHeaderLineSaved);
free(submitArray);
free(submitterXref);
free(subLine);
fclose(gedFile);
*obj
=
NULL;
parsingError.type
=
INV_HEADER;
parsingError.line
=
headerLineCounter;
return
parsingError;
}
//done
with
the
array
for(y
=
0;
y
<
subArrLen;
y++)
{
free(submitArray[y]);
}
free(submitArray);
//seek
back
to
where
you
were
before
scanning
for
submitter
fseek(gedFile,
posi,
SEEK_SET);
free(lineAfterHeader);
free(submitterXref);
free(subLine);
/*END
SUBMITTER
PARSING*********/
/*BEGIN
INDIVIDUAL
PARSING*/
int
isTrailerThere
=
0;
//printf("IS
THIS
THE
MISSING
INDIVIDUAL?:
%s\n",
lineAfterHeader);
while
((isTrailerThere
=
findIndividual(gedFile,
lastHeaderLineSaved))
==
1)
{
int
readLineNum
=
0;
char*
individualLine
=
calloc(257,
sizeof(char));
individualLine
=
readLine(gedFile,
&readLineNum,
individualLine);
//printf("isTrailerHere:
%d\n",
isTrailerThere);
free(individualLine);
}
//printf("Outside:
%d\n",
isTrailerThere);
if(isTrailerThere
==
3)
{
//Trailer
in
file
was
not
found
searching
for
individuals.
Is
missing.
GEDCOM
Error
fclose(gedFile);
free(lastHeaderLineSaved);
*obj
=
NULL;
//printf("Trailer
not
found
in
individuals
search\n");
parsingError.type
=
INV_GEDCOM;
parsingError.line
=
-1;
return
parsingError;
}
//seek
back
to
where
you
were
before
scanning
for
individuals
fseek(gedFile,
posi,
SEEK_SET);
free(lastHeaderLineSaved);
/*End
individuals
parsing*/
fclose(gedFile);
//If
all
is
well,
return
OK
parsingError.type
=
OK;
parsingError.line
=
-1;
return
parsingError;
}
/**
Function
to
create
a
string
representation
of
a
GEDCOMobject.
*@pre
GEDCOMobject
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOMobject
has
not
been
modified
in
any
way,
and
a
string
representing
the
GEDCOM
contents
has
been
created
*@return
a
string
contaning
a
humanly
readable
representation
of
a
GEDCOMobject
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
char*
printGEDCOM(const
GEDCOMobject*
obj)
{
char*
gedString
=
calloc(500,
sizeof(char));
//maybe
add
up
strlens
and
malloc
to
that
size
char
versString[30]
=
"";
char
sourceString[258]
=
"Source:
";/*249+
sizeof
'source:
'
because
thats
the
static
size
in
the
sheader
struct*/
char
encodeString[40]
=
"";
char
submitterString[70]
=
"";
//char
submitterAddress[257]
=
"";
Header
*gedHeader
=
obj->header;
string start = 5
NUMBER OF arrows IN WORD obj->header; : 1
float
version
=
gedHeader->gedcVersion;
string start = 11
NUMBER OF arrows IN WORD gedHeader->gedcVersion; : 1
strcat(sourceString,
gedHeader->source);
string start = 11
NUMBER OF arrows IN WORD gedHeader->source); : 1
if(gedHeader->encoding
string start = 14
NUMBER OF arrows IN WORD if(gedHeader->encoding : 1
==
ANSEL)
{
strcpy(encodeString,
"Character
Encoding:
ANSEL\n");
}
else
if(gedHeader->encoding
string start = 14
NUMBER OF arrows IN WORD if(gedHeader->encoding : 1
==
UTF8)
{
strcpy(encodeString,
"Character
Encoding:
UTF8\n");
}
else
if(gedHeader->encoding
string start = 14
NUMBER OF arrows IN WORD if(gedHeader->encoding : 1
==
UNICODE)
{
strcpy(encodeString,
"Character
Encoding:
UNICODE\n");
}
else
if(gedHeader->encoding
string start = 14
NUMBER OF arrows IN WORD if(gedHeader->encoding : 1
==
ASCII)
{
strcpy(encodeString,
"Character
Encoding:
ASCII\n");
}
sprintf(versString,
"Gedcom
Version:
%.1f
\n",
version);
sprintf(submitterString,
"Submitter:
%s\n",
gedHeader->submitter->submitterName);
string start = 11
string start = 22
NUMBER OF arrows IN WORD gedHeader->submitter->submitterName); : 2
/*if(gedHeader->submitter->address
string start = 16
string start = 27
NUMBER OF arrows IN WORD /*if(gedHeader->submitter->address : 2
!=
NULL)
{
sprintf(submitterAddress,
"Submitter
address:
%s\n",
gedHeader->submitter->address);
string start = 11
string start = 22
NUMBER OF arrows IN WORD gedHeader->submitter->address); : 2
}*/
strcat(gedString,
sourceString);
strcat(gedString,
encodeString);
strcat(gedString,
versString);
strcat(gedString,
submitterString);
//Only
prints
header
rn
(including
submitter
records)
//strcat(gedString,
submitterAddress);
return
gedString;
}
/**
Function
to
delete
all
GEDCOM
object
content
and
free
all
the
memory.
*@pre
GEDCOM
object
exists,
is
not
null,
and
has
not
been
freed
*@post
GEDCOM
object
had
been
freed
*@return
none
*@param
obj
-
a
pointer
to
a
GEDCOMobject
struct
**/
void
deleteGEDCOM(GEDCOMobject*
obj)
{
//free(obj->header->submitter->address);
string start = 12
string start = 20
string start = 31
NUMBER OF arrows IN WORD //free(obj->header->submitter->address); : 3
free(obj->header->submitter);
string start = 10
string start = 18
NUMBER OF arrows IN WORD free(obj->header->submitter); : 2
free(obj->header);
string start = 10
NUMBER OF arrows IN WORD free(obj->header); : 1
free(obj);
}
/**
Function
to
"convert"
the
GEDCOMerror
into
a
humanly
redabale
string.
*@return
a
string
contaning
a
humanly
readable
representation
of
the
error
code
*@param
err
-
an
error
struct
**/
char*
printError(GEDCOMerror
err)
{
char*
returnString;
//char
tempString[500];
if(err.type
==
INV_FILE)
{
returnString
=
malloc(15
*
sizeof(char));
strcpy(returnString,
"Invalid
File");
}
else
if(err.type
==
INV_GEDCOM)
{
returnString
=
malloc(22
*
sizeof(char));
strcpy(returnString,
"Invalid
GEDCOM
file");
}
else
if(err.type
==
INV_HEADER)
{
returnString
=
malloc(25
*
sizeof(char)
+
28);//28
int
is
8
bytes,
20
chars
for
maximum
legnth
strcpy(returnString,
"Invalid
header.
Line:
");
char
lineString[25];
sprintf(lineString,
"%d",
err.line);
strcat(returnString,
lineString);
}
else
if(err.type
==
INV_RECORD)
{
returnString
=
malloc(25
*
sizeof(char)
+
28);//28
int
is
8
bytes,
20
chars
for
maximum
legnth
strcpy(returnString,
"Invalid
record.
Line:
");
char
lineString[25];
sprintf(lineString,
"%d",
err.line);
strcat(returnString,
lineString);
}
else
if(err.type
==
OTHER)
{
returnString
=
malloc(28
*
sizeof(char));
strcpy(returnString,
"Non
GEDCOM
error
occured");
}
else
if(err.type
==
OK)
{
returnString
=
malloc(5
*
sizeof(char));
strcpy(returnString,
"OK");
}
return
returnString;
}
/**
Function
that
searches
for
an
individual
in
the
list
using
a
comparator
function.
*
If
an
individual
is
found,
a
pointer
to
the
Individual
record
*
Returns
NULL
if
the
individual
is
not
found.
*@pre
GEDCOM
object
exists,is
not
NULL,
and
is
valid.
Comparator
function
has
been
provided.
*@post
GEDCOM
object
remains
unchanged.
*@return
The
Individual
record
associated
with
the
person
that
matches
the
search
criteria.
If
the
Individual
record
is
not
found,
return
NULL.
*If
multiple
records
match
the
search
criteria,
return
the
first
one.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
compare
-
a
pointer
to
comparator
fuction
for
customizing
the
search
*@param
person
-
a
pointer
to
search
data,
which
contains
seach
criteria
*Note:
while
the
arguments
of
compare()
and
person
are
all
void,
it
is
assumed
that
records
they
point
to
are
*
all
of
the
same
type
-
just
like
arguments
to
the
compare()
function
in
the
List
struct
**/
Individual*
findPerson(const
GEDCOMobject*
familyRecord,
bool
(*compare)(const
void*
first,
const
void*
second),
const
void*
person)
{
Individual*
locatedPerson
=
malloc(sizeof(Individual*));
locatedPerson->givenName
string start = 15
NUMBER OF arrows IN WORD locatedPerson->givenName : 1
=
"Dummy";
return
locatedPerson;
}
/**
Function
to
return
a
list
of
all
descendants
of
an
individual
in
a
GEDCOM
*@pre
GEDCOM
object
exists,
is
not
null,
and
is
valid
*@post
GEDCOM
object
has
not
been
modified
in
any
way,
and
a
list
of
descendants
has
been
created
*@return
a
list
of
descendants.
The
list
may
be
empty.
All
list
members
must
be
of
type
Individual,
and
can
appear
in
any
order.
*All
list
members
must
be
COPIES
of
the
Individual
records
in
the
GEDCOM
file.
If
the
returned
list
is
freed,
the
original
GEDCOM
*must
remain
unaffected.
*@param
familyRecord
-
a
pointer
to
a
GEDCOMobject
struct
*@param
person
-
the
Individual
record
whose
descendants
we
want
**/
List
getDescendants(const
GEDCOMobject*
familyRecord,
const
Individual*
person)
{
List
dummyList;
return
dummyList;
}
//events
void
deleteEvent(void*
toBeDeleted)
{
}
int
compareEvents(const
void*
first,const
void*
second)
{
return
0;
}
char*
printEvent(void*
toBePrinted)
{
return
"fd";
}
//individual
void
deleteIndividual(void*
toBeDeleted)
{
}
int
compareIndividuals(const
void*
first,const
void*
second)
{
return
0;
}
char*
printIndividual(void*
toBePrinted)
{
return
"fd";
}
//Family
void
deleteFamily(void*
toBeDeleted)
{
}
int
compareFamilies(const
void*
first,const
void*
second)
{
return
0;
}
char*
printFamily(void*
toBePrinted)
{
return
"dfs";
}
//fields
(other?)
void
deleteField(void*
toBeDeleted)
{
}
int
compareFields(const
void*
first,const
void*
second)
{
return
0;
}
char*
printField(void*
toBePrinted)
{
return
"dsf";
}
typedef
struct
treeNode{
int
data;
//int
nodeHeight;
//something
else
struct
treeNode*
lchild;
struct
treeNode*
rchild;
}treeNode;
typedef
struct
binaryTree{
int
totalHeight;
treeNode*
treeData;
}tree;
/*Also
a
block
dhIOgsgbpDG
*/
tree*
createBinaryTree();
int
destroyBinaryTree(tree*
oldTree);
treeNode*
PostOrderDestroyTree(treeNode*
theNode);
int
addToTree(tree*
theTree,
int
data);
int
PreOrderPrint(tree*
theTree);
void
PreOrderPrintNode(treeNode*
theNode);
int
InOrderPrint(tree*
theTree);
void
InOrderPrintNode(treeNode*
theNode);
int
PostOrderPrint(tree*
theTree);
void
PostOrderPrintNode(treeNode*
theNode);
int
setTreeHeight(tree*
theTree);
int
findHeight(treeNode*
theNode);
treeNode*
createTreeNode(int
data);
int
destroyTreeNode(treeNode*
oldNode);
treeNode*
addNode(treeNode*
currNode,
treeNode*
newNode);
/*int
addNodeToTree(treeNode*
child,
treeNode*
newNode);*/
int
printTreeNode(treeNode*
theNode);
#include
<stdlib.h>
#include
<stdio.h>
#include
"tree.h"
#include
"./ref/tree.h"
#include
"something.h"
void
testUnused()
{
printf("Hello
errors!\n");
}
int
main()
{
tree*
temp
=
createBinaryTree();
a=b;
printf("******EMPTY-LIST-PRINT******\n");
InOrderPrint(temp);
addToTree(temp,
100);
addToTree(temp,
50);
addToTree(temp,
107);
addToTree(temp,
5);
addToTree(temp,
70);
addToTree(temp,
90);
addToTree(temp,
210);
addToTree(temp,
93);
addToTree(temp,
80);
addToTree(temp,
190);
addToTree(temp,
97);
printf("******IN-ORDER-PRINT******\n");
InOrderPrint(temp);
printf("******PRE-ORDER-PRINT******\n");
PreOrderPrint(temp);
printf("******POST-ORDER-PRINT******\n");
PostOrderPrint(temp);
printf("Total
height
is
%d\n",
temp->totalHeight);
string start = 6
NUMBER OF arrows IN WORD temp->totalHeight); : 1
destroyBinaryTree(temp);
temp
=
NULL;
destroyBinaryTree(temp);
a=a+a+a+a+a;
}
/*
C:
The
Complete
Reference,
4th
Ed.
(Paperback)
by
Herbert
Schildt
ISBN:
0072121246
Publisher:
McGraw-Hill
Osborne
Media;
4
edition
(April
26,
2000)
*/
/*
This
program
displays
a
binary
tree.
*/
#include
<stdlib.h>
#include
<stdio.h>
struct
tree
{
char
info;
struct
tree
*left;
struct
tree
*right;
};
struct
tree
*root;
/*
first
node
in
tree
*/
struct
tree
*stree(struct
tree
*root,
struct
tree
*r,
char
info);
void
print_tree(struct
tree
*root,
int
l);
int
main(void)
{
char
s[80];
root
=
NULL;
/*
initialize
the
root
*/
do
{
printf("Enter
a
letter:
");
gets(s);
root
=
stree(root,
root,
*s);
}
while(*s);
print_tree(root,
0);
return
0;
}
struct
tree
*stree(
struct
tree
*root,
struct
tree
*r,
char
info)
{
if(!r)
{
r
=
(struct
tree
*)
malloc(sizeof(struct
tree));
if(!r)
{
printf("Out
of
Memory\n");
exit(0);
}
r->left
string start = 3
NUMBER OF arrows IN WORD r->left : 1
=
NULL;
r->right
string start = 3
NUMBER OF arrows IN WORD r->right : 1
=
NULL;
r->info
string start = 3
NUMBER OF arrows IN WORD r->info : 1
=
info;
if(!root)
return
r;
/*
first
entry
*/
if(info
<
root->info)
string start = 6
NUMBER OF arrows IN WORD root->info) : 1
root->left
string start = 6
NUMBER OF arrows IN WORD root->left : 1
=
r;
else
root->right
string start = 6
NUMBER OF arrows IN WORD root->right : 1
=
r;
return
r;
}
if(info
<
r->info)
string start = 3
NUMBER OF arrows IN WORD r->info) : 1
stree(r,
r->left,
string start = 3
NUMBER OF arrows IN WORD r->left, : 1
info);
else
stree(r,
r->right,
string start = 3
NUMBER OF arrows IN WORD r->right, : 1
info);
return
root;
}
void
print_tree(struct
tree
*r,
int
l)
{
int
i;
if(!r)
return;
print_tree(r->right,
string start = 14
NUMBER OF arrows IN WORD print_tree(r->right, : 1
l+1);
for(i=0;
i<l;
++i)
printf("
");
printf("%c\n",
r->info);
string start = 3
NUMBER OF arrows IN WORD r->info); : 1
print_tree(r->left,
string start = 14
NUMBER OF arrows IN WORD print_tree(r->left, : 1
l+1);
}
#include
<stdlib.h>
#include
<stdio.h>
#include
"tree.h"
tree*
createBinaryTree()
{
tree*
newTree
=
malloc(sizeof(tree));
newTree->totalHeight
string start = 9
NUMBER OF arrows IN WORD newTree->totalHeight : 1
=
-1;
newTree->treeData
string start = 9
NUMBER OF arrows IN WORD newTree->treeData : 1
=
NULL;
return
newTree;
}
int
destroyBinaryTree(tree*
oldTree)
{
if
(oldTree
==
NULL)
{
return
0;
}
if
(oldTree->treeData
string start = 10
NUMBER OF arrows IN WORD (oldTree->treeData : 1
!=
NULL)
{
oldTree->treeData
string start = 9
NUMBER OF arrows IN WORD oldTree->treeData : 1
=
PostOrderDestroyTree(oldTree->treeData);
string start = 30
NUMBER OF arrows IN WORD PostOrderDestroyTree(oldTree->treeData); : 1
}
free(oldTree);
oldTree
=
NULL;
return
1;//FINISH
LATER
ONCE
YOU
CAN
DESTROY
ALL
NODES
}
treeNode*
PostOrderDestroyTree(treeNode*
theNode)
{
if
(theNode->lchild
string start = 10
NUMBER OF arrows IN WORD (theNode->lchild : 1
!=
NULL)
{
theNode->lchild
string start = 9
NUMBER OF arrows IN WORD theNode->lchild : 1
=
PostOrderDestroyTree(theNode->lchild);
string start = 30
NUMBER OF arrows IN WORD PostOrderDestroyTree(theNode->lchild); : 1
}
if
(theNode->rchild
string start = 10
NUMBER OF arrows IN WORD (theNode->rchild : 1
!=
NULL)
{
theNode->rchild
string start = 9
NUMBER OF arrows IN WORD theNode->rchild : 1
=
PostOrderDestroyTree(theNode->rchild);
string start = 30
NUMBER OF arrows IN WORD PostOrderDestroyTree(theNode->rchild); : 1
}
if
(theNode
!=
NULL)
{
destroyTreeNode(theNode);
}
return
NULL;
}
int
addToTree(tree*
theTree,
int
data)
{
if
(theTree
==
NULL)
{
return
0;
}
treeNode*
rootNode
=
theTree->treeData;
string start = 9
NUMBER OF arrows IN WORD theTree->treeData; : 1
treeNode*
newNode
=
createTreeNode(data);
if
(rootNode
==
NULL)
{
//newNode->height
string start = 11
NUMBER OF arrows IN WORD //newNode->height : 1
=
0;
theTree->totalHeight
string start = 9
NUMBER OF arrows IN WORD theTree->totalHeight : 1
=
0;
theTree->treeData
string start = 9
NUMBER OF arrows IN WORD theTree->treeData : 1
=
newNode;
}
else
{
rootNode
=
addNode(rootNode,
newNode);
setTreeHeight(theTree);
}
return
1;
}
#include
"./ref/missing_file.h"
treeNode*
addNode(treeNode*
currNode,
treeNode*
newNode)
{
if
(currNode
==
NULL)
{
currNode
=
newNode;
return
currNode;
}
else
if
(currNode->data
string start = 11
NUMBER OF arrows IN WORD (currNode->data : 1
>
newNode->data)
string start = 9
NUMBER OF arrows IN WORD newNode->data) : 1
{
currNode->lchild
string start = 10
NUMBER OF arrows IN WORD currNode->lchild : 1
=
addNode(currNode->lchild,
string start = 18
NUMBER OF arrows IN WORD addNode(currNode->lchild, : 1
newNode);
}
else
if
(currNode->data
string start = 11
NUMBER OF arrows IN WORD (currNode->data : 1
<=
newNode->data)
string start = 9
NUMBER OF arrows IN WORD newNode->data) : 1
{
currNode->rchild
string start = 10
NUMBER OF arrows IN WORD currNode->rchild : 1
=
addNode(currNode->rchild,
string start = 18
NUMBER OF arrows IN WORD addNode(currNode->rchild, : 1
newNode);
}
return
currNode;
}
/*int
addNodeToTree(treeNode*
theNode,
int
data,
int
height)
{
int
newHeight
=
height+1;
if(theNode
==
NULL)
{
}
}*/
#include
"More/problems/to/add.h"
int
PreOrderPrint(tree*
theTree)
{
if
(theTree
==
NULL
||
theTree->treeData
string start = 9
NUMBER OF arrows IN WORD theTree->treeData : 1
==
NULL)
{
return
0;
}
PreOrderPrintNode(theTree->treeData);
string start = 27
NUMBER OF arrows IN WORD PreOrderPrintNode(theTree->treeData); : 1
return
1;
}
void
PreOrderPrintNode(treeNode*
theNode)
{
if
(theNode
!=
NULL)
{
printTreeNode(theNode);
}
if
(theNode->lchild
string start = 10
NUMBER OF arrows IN WORD (theNode->lchild : 1
!=
NULL)
{
PreOrderPrintNode(theNode->lchild);
string start = 27
NUMBER OF arrows IN WORD PreOrderPrintNode(theNode->lchild); : 1
}
if
(theNode->rchild
string start = 10
NUMBER OF arrows IN WORD (theNode->rchild : 1
!=
NULL)
{
PreOrderPrintNode(theNode->rchild);
string start = 27
NUMBER OF arrows IN WORD PreOrderPrintNode(theNode->rchild); : 1
}
}
int
InOrderPrint(tree*
theTree)
{
if
(theTree
==
NULL
||
theTree->treeData
string start = 9
NUMBER OF arrows IN WORD theTree->treeData : 1
==
NULL)
{
return
0;
}
InOrderPrintNode(theTree->treeData);
string start = 26
NUMBER OF arrows IN WORD InOrderPrintNode(theTree->treeData); : 1
return
1;
}
void
InOrderPrintNode(treeNode*
theNode)
{
if
(theNode->lchild
string start = 10
NUMBER OF arrows IN WORD (theNode->lchild : 1
!=
NULL)
{
InOrderPrintNode(theNode->lchild);
string start = 26
NUMBER OF arrows IN WORD InOrderPrintNode(theNode->lchild); : 1
}
if
(theNode
!=
NULL)
{
printTreeNode(theNode);
}
if
(theNode->rchild
string start = 10
NUMBER OF arrows IN WORD (theNode->rchild : 1
!=
NULL)
{
InOrderPrintNode(theNode->rchild);
string start = 26
NUMBER OF arrows IN WORD InOrderPrintNode(theNode->rchild); : 1
}
}
int
PostOrderPrint(tree*
theTree)
{
if
(theTree
==
NULL
||
theTree->treeData
string start = 9
NUMBER OF arrows IN WORD theTree->treeData : 1
==
NULL)
{
return
0;
}
PostOrderPrintNode(theTree->treeData);
string start = 28
NUMBER OF arrows IN WORD PostOrderPrintNode(theTree->treeData); : 1
return
1;
}
void
PostOrderPrintNode(treeNode*
theNode)
{
if
(theNode->lchild
string start = 10
NUMBER OF arrows IN WORD (theNode->lchild : 1
!=
NULL)
{
PostOrderPrintNode(theNode->lchild);
string start = 28
NUMBER OF arrows IN WORD PostOrderPrintNode(theNode->lchild); : 1
}
if
(theNode->rchild
string start = 10
NUMBER OF arrows IN WORD (theNode->rchild : 1
!=
NULL)
{
PostOrderPrintNode(theNode->rchild);
string start = 28
NUMBER OF arrows IN WORD PostOrderPrintNode(theNode->rchild); : 1
}
if
(theNode
!=
NULL)
{
printTreeNode(theNode);
}
}
int
setTreeHeight(tree*
theTree)
{
if
(theTree
==
NULL
||
theTree->treeData
string start = 9
NUMBER OF arrows IN WORD theTree->treeData : 1
==
NULL)
{
return
0;
}
theTree->totalHeight
string start = 9
NUMBER OF arrows IN WORD theTree->totalHeight : 1
=
findHeight(theTree->treeData);
string start = 20
NUMBER OF arrows IN WORD findHeight(theTree->treeData); : 1
return
1;
}
int
findHeight(treeNode*
theNode)
{
if
(theNode
==
NULL)
{
return
-1;
}
int
lHeight
=
findHeight(theNode->lchild);
string start = 20
NUMBER OF arrows IN WORD findHeight(theNode->lchild); : 1
int
rHeight
=
findHeight(theNode->rchild);
string start = 20
NUMBER OF arrows IN WORD findHeight(theNode->rchild); : 1
if
(lHeight
>
rHeight)
{
return
lHeight+1;
}
return
rHeight+1;
}
treeNode*
createTreeNode(int
data)
{
treeNode*
newNode
=
malloc(sizeof(treeNode));
newNode->data
string start = 9
NUMBER OF arrows IN WORD newNode->data : 1
=
data;
newNode->lchild
string start = 9
NUMBER OF arrows IN WORD newNode->lchild : 1
=
NULL;
newNode->rchild
string start = 9
NUMBER OF arrows IN WORD newNode->rchild : 1
=
NULL;
return
newNode;
}
//dbiufbiuf*/
int
destroyTreeNode(treeNode*
oldNode)
{
if
(oldNode
==
NULL)
{
return
0;
}
if
(oldNode->lchild
string start = 10
NUMBER OF arrows IN WORD (oldNode->lchild : 1
!=
NULL)
{
return
0;
}
free
(oldNode->lchild);
string start = 10
NUMBER OF arrows IN WORD (oldNode->lchild); : 1
if
(oldNode->rchild
string start = 10
NUMBER OF arrows IN WORD (oldNode->rchild : 1
!=
NULL)
{
return
0;
}
free
(oldNode->rchild);
string start = 10
NUMBER OF arrows IN WORD (oldNode->rchild); : 1
free(oldNode);
return
1;
}
/*int
addNodeToTree(treeNode*
child,
treeNode*
newNode);*/
int
printTreeNode(treeNode*
theNode)
{
if
(theNode
==
NULL)
{
return
0;
}
printf("%d\n",
theNode->data);
string start = 9
NUMBER OF arrows IN WORD theNode->data); : 1
return
1;
}
